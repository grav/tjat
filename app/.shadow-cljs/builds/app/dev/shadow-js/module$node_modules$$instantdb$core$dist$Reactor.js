["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@instantdb/core/dist/Reactor.js"],"~:js","shadow$provide.module$node_modules$$instantdb$core$dist$Reactor = function(global, require, module, exports) {\n  function isClient() {\n    const isChrome = \"undefined\" !== typeof chrome;\n    return \"undefined\" !== typeof window || isChrome;\n  }\n  function querySubsFromJSON(str) {\n    var _a;\n    str = JSON.parse(str);\n    for (const key in str) {\n      const v = str[key];\n      if (null === (_a = null === v || void 0 === v ? void 0 : v.result) || void 0 === _a ? 0 : _a.store) {\n        v.result.store = s.fromJSON(v.result.store);\n      }\n    }\n    return str;\n  }\n  function querySubsToJSON(querySubs) {\n    var _a;\n    const jsonSubs = {};\n    for (const key in querySubs) {\n      const sub = querySubs[key], jsonSub = Object.assign({}, sub);\n      if (null === (_a = sub.result) || void 0 === _a ? 0 : _a.store) {\n        jsonSub.result = Object.assign(Object.assign({}, sub.result), {store:s.toJSON(sub.result.store)});\n      }\n      jsonSubs[key] = jsonSub;\n    }\n    return JSON.stringify(jsonSubs);\n  }\n  var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = {enumerable:!0, get:function() {\n        return m[k];\n      }};\n    }\n    Object.defineProperty(o, k2, desc);\n  } : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    o[k2] = m[k];\n  }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {enumerable:!0, value:v});\n  } : function(o, v) {\n    o[\"default\"] = v;\n  });\n  global = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) {\n      return mod;\n    }\n    var result = {};\n    if (null != mod) {\n      for (var k in mod) {\n        \"default\" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);\n      }\n    }\n    __setModuleDefault(result, mod);\n    return result;\n  };\n  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P ? value : new P(function(resolve) {\n        resolve(value);\n      });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n  module = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\"default\":mod};\n  };\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  const log_1 = module(require(\"module$node_modules$$instantdb$core$dist$utils$log\")), weakHash_1 = module(require(\"module$node_modules$$instantdb$core$dist$utils$weakHash\")), instaql_1 = module(require(\"module$node_modules$$instantdb$core$dist$instaql\")), instaml = global(require(\"module$node_modules$$instantdb$core$dist$instaml\")), s = global(require(\"module$node_modules$$instantdb$core$dist$store\")), uuid_1 = module(require(\"module$node_modules$$instantdb$core$dist$utils$uuid\")), IndexedDBStorage_1 = \n  module(require(\"module$node_modules$$instantdb$core$dist$IndexedDBStorage\")), WindowNetworkListener_1 = module(require(\"module$node_modules$$instantdb$core$dist$WindowNetworkListener\")), authAPI = global(require(\"module$node_modules$$instantdb$core$dist$authAPI\")), StorageApi = global(require(\"module$node_modules$$instantdb$core$dist$StorageAPI\")), presence_1 = require(\"module$node_modules$$instantdb$core$dist$presence\"), Deferred_1 = require(\"module$node_modules$$instantdb$core$dist$utils$Deferred\"), \n  PersistedObject_1 = require(\"module$node_modules$$instantdb$core$dist$utils$PersistedObject\"), instaqlResult_1 = require(\"module$node_modules$$instantdb$core$dist$model$instaqlResult\"), object_1 = require(\"module$node_modules$$instantdb$core$dist$utils$object\"), linkIndex_1 = require(\"module$node_modules$$instantdb$core$dist$utils$linkIndex\"), version_1 = module(require(\"module$node_modules$$instantdb$core$dist$version\")), defaultConfig = {apiURI:\"https://api.instantdb.com\", websocketURI:\"wss://api.instantdb.com/runtime/session\"};\n  let _wsId = 0;\n  const ignoreLogging = {\"set-presence\":!0, \"set-presence-ok\":!0, \"refresh-presence\":!0, \"patch-presence\":!0};\n  class Reactor {\n    constructor(config, Storage = IndexedDBStorage_1.default, NetworkListener = WindowNetworkListener_1.default, versions) {\n      this._isOnline = !0;\n      this._isShutdown = !1;\n      this.status = \"connecting\";\n      this.queryCbs = {};\n      this.queryOnceDfds = {};\n      this.authCbs = [];\n      this.attrsCbs = [];\n      this.mutationErrorCbs = [];\n      this.connectionStatusCbs = [];\n      this.mutationDeferredStore = new Map();\n      this._reconnectTimeoutId = null;\n      this._reconnectTimeoutMs = 0;\n      this._localIdPromises = {};\n      this._linkIndex = this._oauthCallbackResponse = this._errorMessage = null;\n      this._rooms = {};\n      this._roomsPendingLeave = {};\n      this._presence = {};\n      this._broadcastQueue = [];\n      this._broadcastSubs = {};\n      this._currentUserCached = {isLoading:!0, error:void 0, user:void 0};\n      this._beforeUnloadCbs = [];\n      this._dataForQueryCache = {};\n      this._onMergeQuerySubs = (_storageSubs, inMemorySubs) => {\n        const storageSubs = _storageSubs || {}, ret = Object.assign({}, inMemorySubs);\n        Object.entries(inMemorySubs).forEach(([hash, querySub]) => {\n          var _a;\n          const storageResult = null === (_a = null === storageSubs || void 0 === storageSubs ? void 0 : storageSubs[hash]) || void 0 === _a ? void 0 : _a.result;\n          querySub = querySub.result;\n          storageResult && !querySub && (ret[hash].result = storageResult);\n        });\n        Object.keys(storageSubs).filter(k => !inMemorySubs[k]).slice(0, 10).forEach(k => {\n          ret[k] = storageSubs[k];\n        });\n        this.querySubs.set(_ => ret);\n        this.loadedNotifyAll();\n      };\n      this._onMergePendingMutations = (storageMuts, inMemoryMuts) => {\n        const ret = new Map([...storageMuts.entries(), ...inMemoryMuts.entries()]);\n        this.pendingMutations.set(_ => ret);\n        this.loadedNotifyAll();\n        this._rewriteMutations(this.attrs, storageMuts).forEach((mut, k) => {\n          inMemoryMuts.has(k) || mut[\"tx-id\"] || this._sendMutation(k, mut);\n        });\n      };\n      this.getPreviousResult = q => {\n        q = (0,weakHash_1.default)(q);\n        return this.dataForQuery(q);\n      };\n      this.notifyOne = hash => {\n        var _a, _b;\n        const cbs = null !== (_a = this.queryCbs[hash]) && void 0 !== _a ? _a : [];\n        _a = null === (_b = this._dataForQueryCache[hash]) || void 0 === _b ? void 0 : _b.data;\n        const data = this.dataForQuery(hash);\n        data && ((0,object_1.areObjectsDeepEqual)(data, _a) || cbs.forEach(r => r.cb(data)));\n      };\n      this.notifyOneQueryOnce = hash => {\n        var _a;\n        const dfds = null !== (_a = this.queryOnceDfds[hash]) && void 0 !== _a ? _a : [], data = this.dataForQuery(hash);\n        dfds.forEach(r => {\n          this._completeQueryOnce(r.q, hash, r.dfd);\n          r.dfd.resolve(data);\n        });\n      };\n      this.notifyQueryError = (hash, error) => {\n        (this.queryCbs[hash] || []).forEach(r => r.cb({error}));\n      };\n      this.pushTx = chunks => {\n        try {\n          const txSteps = instaml.transform({attrs:this.optimisticAttrs(), schema:this.config.schema}, chunks);\n          return this.pushOps(txSteps);\n        } catch (e) {\n          return this.pushOps([], e);\n        }\n      };\n      this.pushOps = (txSteps, error) => {\n        const eventId = (0,uuid_1.default)(), mutation = {op:\"transact\", \"tx-steps\":txSteps, error};\n        this.pendingMutations.set(prev => {\n          prev.set(eventId, mutation);\n          return prev;\n        });\n        txSteps = new Deferred_1.Deferred();\n        this.mutationDeferredStore.set(eventId, txSteps);\n        this._sendMutation(eventId, mutation);\n        this.notifyAll();\n        return txSteps.promise;\n      };\n      this._wsOnOpen = e => {\n        e = e.target;\n        this._ws !== e ? log_1.default.info(\"[socket][open]\", e._id, \"skip; this is no longer the current ws\") : (log_1.default.info(\"[socket][open]\", this._ws._id), this._setStatus(\"opened\"), this.getCurrentUser().then(resp => {\n          var _a;\n          this._trySend((0,uuid_1.default)(), {op:\"init\", \"app-id\":this.config.appId, \"refresh-token\":null === (_a = resp.user) || void 0 === _a ? void 0 : _a.refresh_token, versions:this.versions, \"__admin-token\":this.config.__adminToken});\n        }));\n      };\n      this._wsOnMessage = e => {\n        const targetWs = e.target, m = JSON.parse(e.data.toString());\n        this._ws !== targetWs ? log_1.default.info(\"[socket][message]\", targetWs._id, m, \"skip; this is no longer the current ws\") : this._handleReceive(targetWs._id, JSON.parse(e.data.toString()));\n      };\n      this._wsOnError = e => {\n        const targetWs = e.target;\n        this._ws !== targetWs ? log_1.default.info(\"[socket][error]\", targetWs._id, \"skip; this is no longer the current ws\") : log_1.default.error(\"[socket][error]\", targetWs._id, e);\n      };\n      this._wsOnClose = e => {\n        const targetWs = e.target;\n        if (this._ws !== targetWs) {\n          log_1.default.info(\"[socket][close]\", targetWs._id, \"skip; this is no longer the current ws\");\n        } else {\n          this._setStatus(\"closed\");\n          for (const room of Object.values(this._rooms)) {\n            room.isConnected = !1;\n          }\n          this._isShutdown ? log_1.default.info(\"[socket][close]\", targetWs._id, \"Reactor has been shut down and will not reconnect\") : (log_1.default.info(\"[socket][close]\", targetWs._id, \"schedule reconnect, ms \\x3d\", this._reconnectTimeoutMs), setTimeout(() => {\n            this._reconnectTimeoutMs = Math.min(this._reconnectTimeoutMs + 1000, 10000);\n            this._isOnline ? this._startSocket() : log_1.default.info(\"[socket][close]\", targetWs._id, \"we are offline, no need to start socket\");\n          }, this._reconnectTimeoutMs));\n        }\n      };\n      this.config = Object.assign(Object.assign({}, defaultConfig), config);\n      this.versions = Object.assign(Object.assign({}, versions || {}), {\"@instantdb/core\":version_1.default});\n      this.config.schema && (this._linkIndex = (0,linkIndex_1.createLinkIndex)(this.config.schema));\n      isClient() && (\"function\" === typeof BroadcastChannel && (this._broadcastChannel = new BroadcastChannel(\"@instantdb\"), this._broadcastChannel.addEventListener(\"message\", e => __awaiter(this, void 0, void 0, function*() {\n        var _a;\n        \"auth\" === (null === (_a = e.data) || void 0 === _a ? void 0 : _a.type) && (_a = yield this.getCurrentUser(), this.updateUser(_a.user));\n      }))), this._oauthCallbackResponse = this._oauthLoginInit(), this._initStorage(Storage), this.getCurrentUser(), NetworkListener.getIsOnline().then(isOnline => {\n        this._isOnline = isOnline;\n        this._startSocket();\n        NetworkListener.listen(isOnline => {\n          isOnline !== this._isOnline && (log_1.default.info(\"[network] online \\x3d\", isOnline), (this._isOnline = isOnline) ? this._startSocket() : (log_1.default.info(\"Changing status from\", this.status, \"to\", \"closed\"), this._setStatus(\"closed\")));\n        });\n      }), \"undefined\" !== typeof addEventListener && (this._beforeUnload = this._beforeUnload.bind(this), addEventListener(\"beforeunload\", this._beforeUnload)));\n    }\n    _initStorage(Storage) {\n      this._persister = new Storage(`instant_${this.config.appId}_5`);\n      this.querySubs = new PersistedObject_1.PersistedObject(this._persister, \"querySubs\", {}, this._onMergeQuerySubs, querySubsToJSON, querySubsFromJSON);\n      this.pendingMutations = new PersistedObject_1.PersistedObject(this._persister, \"pendingMutations\", new Map(), this._onMergePendingMutations, x => JSON.stringify([...x.entries()]), x => new Map(JSON.parse(x)));\n      this._beforeUnloadCbs.push(() => {\n        this.pendingMutations.flush();\n        this.querySubs.flush();\n      });\n    }\n    _beforeUnload() {\n      for (const cb of this._beforeUnloadCbs) {\n        cb();\n      }\n    }\n    _finishTransaction(status, clientId, errDetails) {\n      const dfd = this.mutationDeferredStore.get(clientId);\n      this.mutationDeferredStore.delete(clientId);\n      const ok = \"error\" !== status && \"timeout\" !== status;\n      dfd || ok || console.error(\"Mutation failed\", Object.assign({status, clientId}, errDetails));\n      dfd && (ok ? dfd.resolve({status, clientId}) : dfd.reject(Object.assign({status, clientId}, errDetails)));\n    }\n    _setStatus(status, err) {\n      this.status = status;\n      this._errorMessage = err;\n      this.notifyConnectionStatusSubs(status);\n    }\n    _flushEnqueuedRoomData(roomId) {\n      var _a, _b;\n      const enqueuedUserPresence = null === (_b = null === (_a = this._presence[roomId]) || void 0 === _a ? void 0 : _a.result) || void 0 === _b ? void 0 : _b.user;\n      _a = this._broadcastQueue[roomId];\n      this._broadcastQueue[roomId] = [];\n      enqueuedUserPresence && this._trySetPresence(roomId, enqueuedUserPresence);\n      if (_a) {\n        for (const item of _a) {\n          const {topic, roomType, data} = item;\n          this._tryBroadcast(roomId, roomType, topic, data);\n        }\n      }\n    }\n    _handleReceive(wsId, msg) {\n      var _a, _b, _c, _d;\n      const enableCardinalityInference = !!this.config.schema && (\"cardinalityInference\" in this.config ? !!this.config.cardinalityInference : !0);\n      ignoreLogging[msg.op] || log_1.default.info(\"[receive]\", wsId, msg.op, msg);\n      switch(msg.op) {\n        case \"init-ok\":\n          this._setStatus(\"authenticated\");\n          this._reconnectTimeoutMs = 0;\n          this._setAttrs(msg.attrs);\n          this._flushPendingMessages();\n          this._sessionId = msg[\"session-id\"];\n          for (const roomId of Object.keys(this._rooms)) {\n            this._tryJoinRoom(roomId);\n          }\n          break;\n        case \"add-query-exists\":\n          this.notifyOneQueryOnce((0,weakHash_1.default)(msg.q));\n          break;\n        case \"add-query-ok\":\n          const {q, result} = msg, hash = (0,weakHash_1.default)(q), pageInfo = null === (_b = null === (_a = null === result || void 0 === result ? void 0 : result[0]) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[\"page-info\"], aggregate = null === (_d = null === (_c = null === result || void 0 === result ? void 0 : result[0]) || void 0 === _c ? void 0 : _c.data) || void 0 === _d ? void 0 : _d.aggregate;\n          msg = (0,instaqlResult_1.extractTriples)(result);\n          const store = s.createStore(this.attrs, msg, enableCardinalityInference, this._linkIndex);\n          this.querySubs.set(prev => {\n            prev[hash].result = {store, pageInfo, aggregate};\n            return prev;\n          });\n          this.notifyOne(hash);\n          this.notifyOneQueryOnce(hash);\n          break;\n        case \"refresh-ok\":\n          const {computations, attrs} = msg;\n          this._setAttrs(attrs);\n          msg = computations.map(x => {\n            var _a, _b, _c, _d;\n            const result = x[\"instaql-result\"];\n            x = (0,weakHash_1.default)(x[\"instaql-query\"]);\n            var triples = (0,instaqlResult_1.extractTriples)(result);\n            triples = s.createStore(this.attrs, triples, enableCardinalityInference, this._linkIndex);\n            const pageInfo = null === (_b = null === (_a = null === result || void 0 === result ? void 0 : result[0]) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[\"page-info\"];\n            _a = null === (_d = null === (_c = null === result || void 0 === result ? void 0 : result[0]) || void 0 === _c ? void 0 : _c.data) || void 0 === _d ? void 0 : _d.aggregate;\n            return {hash:x, store:triples, pageInfo, aggregate:_a};\n          });\n          msg.forEach(({hash, store, pageInfo, aggregate}) => {\n            this.querySubs.set(prev => {\n              prev[hash].result = {store, pageInfo, aggregate};\n              return prev;\n            });\n          });\n          msg.forEach(({hash}) => {\n            this.notifyOne(hash);\n          });\n          break;\n        case \"transact-ok\":\n          const {\"client-event-id\":eventId} = msg;\n          msg = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue).get(eventId);\n          if (!msg) {\n            break;\n          }\n          this.pendingMutations.set(prev => {\n            prev.delete(eventId);\n            return prev;\n          });\n          const txStepsToApply = msg[\"tx-steps\"];\n          this.querySubs.set(prev => {\n            var _a;\n            for (const [hash, sub] of Object.entries(prev)) {\n              var store = null === (_a = null === sub || void 0 === sub ? void 0 : sub.result) || void 0 === _a ? void 0 : _a.store;\n              store && (store = s.transact(store, txStepsToApply), prev[hash].result.store = store);\n            }\n            return prev;\n          });\n          msg = msg[\"tx-steps\"].filter(([action, ..._args]) => \"add-attr\" === action).map(([, attr]) => attr).concat(Object.values(this.attrs));\n          this._setAttrs(msg);\n          this._finishTransaction(\"synced\", eventId);\n          break;\n        case \"patch-presence\":\n          wsId = msg[\"room-id\"];\n          this._patchPresencePeers(wsId, msg.edits);\n          this._notifyPresenceSubs(wsId);\n          break;\n        case \"refresh-presence\":\n          wsId = msg[\"room-id\"];\n          this._setPresencePeers(wsId, msg.data);\n          this._notifyPresenceSubs(wsId);\n          break;\n        case \"server-broadcast\":\n          this._notifyBroadcastSubs(msg[\"room-id\"], msg.topic, msg);\n          break;\n        case \"join-room-ok\":\n          msg = msg[\"room-id\"];\n          wsId = this._rooms[msg];\n          if (!wsId) {\n            this._roomsPendingLeave[msg] && (this._tryLeaveRoom(msg), delete this._roomsPendingLeave[msg]);\n            break;\n          }\n          wsId.isConnected = !0;\n          this._notifyPresenceSubs(msg);\n          this._flushEnqueuedRoomData(msg);\n          break;\n        case \"join-room-error\":\n          wsId = msg[\"room-id\"];\n          if (_a = this._rooms[wsId]) {\n            _a.error = msg.error;\n          }\n          this._notifyPresenceSubs(wsId);\n          break;\n        case \"error\":\n          this._handleReceiveError(msg);\n      }\n    }\n    _handleMutationError(status, eventId, errDetails) {\n      const mut = this.pendingMutations.currentValue.get(eventId);\n      !mut || \"timeout\" === status && mut[\"tx-id\"] || (this.pendingMutations.set(prev => {\n        prev.delete(eventId);\n        return prev;\n      }), this.notifyAll(), this.notifyAttrsSubs(), this.notifyMutationErrorSubs(errDetails), this._finishTransaction(status, eventId, errDetails));\n    }\n    _handleReceiveError(msg) {\n      var _a, _b, _c, _d, _e, eventId = msg[\"client-event-id\"];\n      const prevMutation = this.pendingMutations.currentValue.get(eventId), errorMessage = {message:msg.message || \"Uh-oh, something went wrong. Ping Joe \\x26 Stopa.\"};\n      msg.hint && (errorMessage.hint = msg.hint);\n      prevMutation ? this._handleMutationError(\"error\", eventId, {message:msg.message, hint:msg.hint}) : (null === (_a = msg[\"original-event\"]) || void 0 === _a ? 0 : _a.hasOwnProperty(\"q\")) && \"add-query\" === (null === (_b = msg[\"original-event\"]) || void 0 === _b ? void 0 : _b.op) ? (msg = null === (_c = msg[\"original-event\"]) || void 0 === _c ? void 0 : _c.q, _c = (0,weakHash_1.default)(msg), this.notifyQueryError((0,weakHash_1.default)(msg), errorMessage), this.notifyQueryOnceError(msg, _c, eventId, \n      errorMessage)) : \"init\" === (null === (_d = msg[\"original-event\"]) || void 0 === _d ? void 0 : _d.op) ? \"record-not-found\" === msg.type && \"app-user\" === (null === (_e = msg.hint) || void 0 === _e ? void 0 : _e[\"record-type\"]) ? this.changeCurrentUser(null) : (this._setStatus(\"errored\", errorMessage), this.notifyAll()) : (eventId = Object.assign({}, msg), delete eventId.message, delete eventId.hint, console.error(msg.message, eventId), msg.hint && console.error(\"This error comes with some debugging information. Here it is: \\n\", \n      msg.hint));\n    }\n    notifyQueryOnceError(q, hash, eventId, e) {\n      var _a;\n      const r = null === (_a = this.queryOnceDfds[hash]) || void 0 === _a ? void 0 : _a.find(r => r.eventId === eventId);\n      r && (r.dfd.reject(e), this._completeQueryOnce(q, hash, r.dfd));\n    }\n    _setAttrs(attrs) {\n      this.attrs = attrs.reduce((acc, attr) => {\n        acc[attr.id] = attr;\n        return acc;\n      }, {});\n      this.notifyAttrsSubs();\n    }\n    _startQuerySub(q, hash) {\n      const eventId = (0,uuid_1.default)();\n      this.querySubs.set(prev => {\n        prev[hash] = prev[hash] || {q, result:null, eventId};\n        return prev;\n      });\n      this._trySendAuthed(eventId, {op:\"add-query\", q});\n      return eventId;\n    }\n    subscribeQuery(q, cb) {\n      var _a;\n      const hash = (0,weakHash_1.default)(q), prevResult = this.getPreviousResult(q);\n      prevResult && cb(prevResult);\n      this.queryCbs[hash] = null !== (_a = this.queryCbs[hash]) && void 0 !== _a ? _a : [];\n      this.queryCbs[hash].push({q, cb});\n      this._startQuerySub(q, hash);\n      return () => {\n        this._unsubQuery(q, hash, cb);\n      };\n    }\n    queryOnce(q) {\n      var _a;\n      const dfd = new Deferred_1.Deferred();\n      if (!this._isOnline) {\n        return dfd.reject(Error(\"We can't run `queryOnce`, because the device is offline.\")), dfd.promise;\n      }\n      if (!this.querySubs) {\n        return dfd.reject(Error(\"We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query\")), dfd.promise;\n      }\n      const hash = (0,weakHash_1.default)(q), eventId = this._startQuerySub(q, hash);\n      this.queryOnceDfds[hash] = null !== (_a = this.queryOnceDfds[hash]) && void 0 !== _a ? _a : [];\n      this.queryOnceDfds[hash].push({q, dfd, eventId});\n      setTimeout(() => dfd.reject(Error(\"Query timed out\")), 30000);\n      return dfd.promise;\n    }\n    _completeQueryOnce(q, hash, dfd) {\n      this.queryOnceDfds[hash] && (this.queryOnceDfds[hash] = this.queryOnceDfds[hash].filter(r => r.dfd !== dfd), this._cleanupQuery(q, hash));\n    }\n    _unsubQuery(q, hash, cb) {\n      this.queryCbs[hash] && (this.queryCbs[hash] = this.queryCbs[hash].filter(r => r.cb !== cb), this._cleanupQuery(q, hash));\n    }\n    _cleanupQuery(q, hash) {\n      var _a, _b;\n      (null === (_a = this.queryCbs[hash]) || void 0 === _a ? 0 : _a.length) || (null === (_b = this.queryOnceDfds[hash]) || void 0 === _b ? 0 : _b.length) || (delete this.queryCbs[hash], delete this.queryOnceDfds[hash], this._trySendAuthed((0,uuid_1.default)(), {op:\"remove-query\", q}));\n    }\n    _rewriteMutations(attrs, muts) {\n      if (!attrs) {\n        return muts;\n      }\n      const mapping = {attrIdMap:{}, refSwapAttrIds:new Set()}, rewritten = new Map();\n      for (const [k, mut] of muts.entries()) {\n        muts = rewritten;\n        var JSCompiler_temp_const = muts.set, JSCompiler_temp_const$jscomp$0 = Object, JSCompiler_temp_const$jscomp$1 = JSCompiler_temp_const$jscomp$0.assign, JSCompiler_temp_const$jscomp$2 = Object.assign({}, mut), txSteps = mut[\"tx-steps\"];\n        const retTxSteps = [];\n        for (const txStep of txSteps) {\n          [txSteps] = txStep;\n          if (\"add-attr\" === txSteps) {\n            [, txSteps] = txStep;\n            const [, etype, label] = txSteps[\"forward-identity\"];\n            var existing = instaml.getAttrByFwdIdentName(attrs, etype, label);\n            if (existing) {\n              mapping.attrIdMap[txSteps.id] = existing.id;\n              continue;\n            }\n            if (\"ref\" === txSteps[\"value-type\"]) {\n              const [, etype, label] = txSteps[\"forward-identity\"];\n              if (existing = instaml.getAttrByReverseIdentName(attrs, etype, label)) {\n                mapping.attrIdMap[txSteps.id] = existing.id;\n                mapping.refSwapAttrIds.add(txSteps.id);\n                continue;\n              }\n            }\n          }\n          txSteps = instaml.rewriteStep(mapping, txStep);\n          retTxSteps.push(txSteps);\n        }\n        JSCompiler_temp_const.call(muts, k, JSCompiler_temp_const$jscomp$1.call(JSCompiler_temp_const$jscomp$0, JSCompiler_temp_const$jscomp$2, {\"tx-steps\":retTxSteps}));\n      }\n      return rewritten;\n    }\n    optimisticAttrs() {\n      var _a, pendingMutationSteps = [...this.pendingMutations.currentValue.values()].flatMap(x => x[\"tx-steps\"]);\n      const deletedAttrIds = new Set(pendingMutationSteps.filter(([action]) => \"delete-attr\" === action).map(([, id]) => id)), pendingAttrs = [];\n      for (const [_action, attr] of pendingMutationSteps) {\n        \"add-attr\" === _action ? pendingAttrs.push(attr) : \"update-attr\" === _action && attr.id && (null === (_a = this.attrs) || void 0 === _a ? 0 : _a[attr.id]) && (pendingMutationSteps = Object.assign(Object.assign({}, this.attrs[attr.id]), attr), pendingAttrs.push(pendingMutationSteps));\n      }\n      _a = [...Object.values(this.attrs || {}), ...pendingAttrs].filter(a => !deletedAttrIds.has(a.id));\n      return Object.fromEntries(_a.map(a => [a.id, a]));\n    }\n    dataForQuery(hash) {\n      var errorMessage = this._errorMessage;\n      if (errorMessage) {\n        return {error:errorMessage};\n      }\n      if (this.querySubs && this.pendingMutations) {\n        errorMessage = this.querySubs.version();\n        var querySubs = this.querySubs.currentValue, pendingMutationsVersion = this.pendingMutations.version(), pendingMutations = this.pendingMutations.currentValue, {q, result} = querySubs[hash] || {};\n        if (result) {\n          if ((querySubs = this._dataForQueryCache[hash]) && errorMessage === querySubs.querySubVersion && pendingMutationsVersion === querySubs.pendingMutationsVersion) {\n            return querySubs.data;\n          }\n          var {store, pageInfo, aggregate} = result;\n          pendingMutations = [...this._rewriteMutations(store.attrs, pendingMutations).values()].flatMap(x => x[\"tx-steps\"]);\n          pendingMutations = s.transact(store, pendingMutations);\n          pendingMutations = (0,instaql_1.default)({store:pendingMutations, pageInfo, aggregate}, q);\n          this._dataForQueryCache[hash] = {querySubVersion:errorMessage, pendingMutationsVersion, data:pendingMutations};\n          return pendingMutations;\n        }\n      }\n    }\n    notifyAll() {\n      Object.keys(this.queryCbs).forEach(hash => {\n        this.notifyOne(hash);\n      });\n    }\n    loadedNotifyAll() {\n      this.pendingMutations.isLoading() || this.querySubs.isLoading() || this.notifyAll();\n    }\n    shutdown() {\n      var _a;\n      this._isShutdown = !0;\n      null === (_a = this._ws) || void 0 === _a || _a.close();\n    }\n    _sendMutation(eventId, mutation) {\n      if (mutation.error) {\n        this._handleMutationError(\"error\", eventId, {error:mutation.error, message:mutation.error.message});\n      } else {\n        if (\"authenticated\" !== this.status) {\n          this._finishTransaction(\"enqueued\", eventId);\n        } else {\n          var timeoutMs = Math.max(5000, 5000 * this.pendingMutations.currentValue.size);\n          this._isOnline ? (this._trySend(eventId, mutation), setTimeout(() => {\n            this._finishTransaction(\"pending\", eventId);\n          }, 3000), setTimeout(() => {\n            this._isOnline && this._handleMutationError(\"timeout\", eventId, {message:\"transaction timed out\"});\n          }, timeoutMs)) : this._finishTransaction(\"enqueued\", eventId);\n        }\n      }\n    }\n    _flushPendingMessages() {\n      Object.keys(this.queryCbs).map(hash => this.querySubs.currentValue[hash]).filter(x => x).forEach(({eventId, q}) => {\n        this._trySendAuthed(eventId, {op:\"add-query\", q});\n      });\n      Object.values(this.queryOnceDfds).flat().forEach(({eventId, q}) => {\n        this._trySendAuthed(eventId, {op:\"add-query\", q});\n      });\n      this._rewriteMutations(this.attrs, this.pendingMutations.currentValue).forEach((mut, eventId) => {\n        mut[\"tx-id\"] || this._sendMutation(eventId, mut);\n      });\n    }\n    _trySendAuthed(...args) {\n      \"authenticated\" === this.status && this._trySend(...args);\n    }\n    _trySend(eventId, msg, opts) {\n      1 === this._ws.readyState && (ignoreLogging[msg.op] || log_1.default.info(\"[send]\", this._ws._id, msg.op, msg), this._ws.send(JSON.stringify(Object.assign({\"client-event-id\":eventId}, msg))));\n    }\n    _startSocket() {\n      if (this._ws && 0 == this._ws.readyState) {\n        log_1.default.info(\"[socket][start]\", this._ws._id, \"maintained as current ws, we were still in a connecting state\");\n      } else {\n        var prevWs = this._ws, ws = new WebSocket(`${this.config.websocketURI}?app_id=${this.config.appId}`);\n        ws._id = _wsId++;\n        this._ws = ws;\n        this._ws.onopen = this._wsOnOpen;\n        this._ws.onmessage = this._wsOnMessage;\n        this._ws.onclose = this._wsOnClose;\n        this._ws.onerror = this._wsOnError;\n        log_1.default.info(\"[socket][start]\", this._ws._id);\n        1 === (null === prevWs || void 0 === prevWs ? void 0 : prevWs.readyState) && (log_1.default.info(\"[socket][start]\", this._ws._id, \"close previous ws id \\x3d \", prevWs._id), prevWs.close());\n      }\n    }\n    getLocalId(name) {\n      return __awaiter(this, void 0, void 0, function*() {\n        const k = `localToken_${name}`, id = yield this._persister.getItem(k);\n        if (id) {\n          return id;\n        }\n        if (this._localIdPromises[k]) {\n          return this._localIdPromises[k];\n        }\n        const newId = (0,uuid_1.default)();\n        this._localIdPromises[k] = this._persister.setItem(k, newId).then(() => newId);\n        return this._localIdPromises[k];\n      });\n    }\n    _replaceUrlAfterOAuth() {\n      if (\"undefined\" !== typeof URL) {\n        var url = new URL(window.location.href);\n        if (url.searchParams.get(\"_instant_oauth_redirect\")) {\n          const startUrl = url.toString();\n          url.searchParams.delete(\"_instant_oauth_redirect\");\n          url.searchParams.delete(\"code\");\n          url.searchParams.delete(\"error\");\n          const newPath = url.pathname + (url.searchParams.size ? \"?\" + url.searchParams : \"\") + url.hash;\n          history.replaceState(history.state, \"\", newPath);\n          if (\"object\" === typeof navigation && \"function\" === typeof navigation.addEventListener && \"function\" === typeof navigation.removeEventListener) {\n            let ran = !1;\n            const listener = e => {\n              var _a;\n              ran || (ran = !0, navigation.removeEventListener(\"navigate\", listener), e.userInitiated || \"replace\" !== e.navigationType || (null === (_a = e.destination) || void 0 === _a ? void 0 : _a.url) !== startUrl || history.replaceState(history.state, \"\", newPath));\n            };\n            navigation.addEventListener(\"navigate\", listener);\n          }\n        }\n      }\n    }\n    _oauthLoginInit() {\n      return __awaiter(this, void 0, void 0, function*() {\n        var _a, _b, _c, _d;\n        if (\"undefined\" === typeof window || \"undefined\" === typeof window.location || \"undefined\" === typeof URLSearchParams) {\n          return null;\n        }\n        var params = new URLSearchParams(window.location.search);\n        if (!params.get(\"_instant_oauth_redirect\")) {\n          return null;\n        }\n        const error = params.get(\"error\");\n        if (error) {\n          return this._replaceUrlAfterOAuth(), {error:{message:error}};\n        }\n        params = params.get(\"code\");\n        if (!params) {\n          return null;\n        }\n        this._replaceUrlAfterOAuth();\n        try {\n          const {user} = yield authAPI.exchangeCodeForToken({apiURI:this.config.apiURI, appId:this.config.appId, code:params});\n          this.setCurrentUser(user);\n          return null;\n        } catch (e) {\n          return \"record-not-found\" === (null === (_a = null === e || void 0 === e ? void 0 : e.body) || void 0 === _a ? void 0 : _a.type) && \"app-oauth-code\" === (null === (_c = null === (_b = null === e || void 0 === e ? void 0 : e.body) || void 0 === _b ? void 0 : _b.hint) || void 0 === _c ? void 0 : _c[\"record-type\"]) && (yield this._hasCurrentUser()) ? null : {error:{message:(null === (_d = null === e || void 0 === e ? void 0 : e.body) || void 0 === _d ? void 0 : _d.message) || \"Error logging in.\"}};\n        }\n      });\n    }\n    _waitForOAuthCallbackResponse() {\n      return __awaiter(this, void 0, void 0, function*() {\n        return yield this._oauthCallbackResponse;\n      });\n    }\n    __subscribeMutationErrors(cb) {\n      this.mutationErrorCbs.push(cb);\n      return () => {\n        this.mutationErrorCbs = this.mutationErrorCbs.filter(x => x !== cb);\n      };\n    }\n    subscribeAuth(cb) {\n      this.authCbs.push(cb);\n      const currUserCached = this._currentUserCached;\n      currUserCached.isLoading || cb(this._currentUserCached);\n      let unsubbed = !1;\n      this.getCurrentUser().then(resp => {\n        unsubbed || (0,object_1.areObjectsDeepEqual)(resp, currUserCached) || cb(resp);\n      });\n      return () => {\n        unsubbed = !0;\n        this.authCbs = this.authCbs.filter(x => x !== cb);\n      };\n    }\n    getAuth() {\n      return __awaiter(this, void 0, void 0, function*() {\n        const {user, error} = yield this.getCurrentUser();\n        if (error) {\n          throw error;\n        }\n        return user;\n      });\n    }\n    subscribeConnectionStatus(cb) {\n      this.connectionStatusCbs.push(cb);\n      return () => {\n        this.connectionStatusCbs = this.connectionStatusCbs.filter(x => x !== cb);\n      };\n    }\n    subscribeAttrs(cb) {\n      this.attrsCbs.push(cb);\n      this.attrs && cb(this.attrs);\n      return () => {\n        this.attrsCbs = this.attrsCbs.filter(x => x !== cb);\n      };\n    }\n    notifyAuthSubs(user) {\n      this.authCbs.forEach(cb => cb(user));\n    }\n    notifyMutationErrorSubs(error) {\n      this.mutationErrorCbs.forEach(cb => cb(error));\n    }\n    notifyAttrsSubs() {\n      if (this.attrs) {\n        var oas = this.optimisticAttrs();\n        this.attrsCbs.forEach(cb => cb(oas));\n      }\n    }\n    notifyConnectionStatusSubs(status) {\n      this.connectionStatusCbs.forEach(cb => cb(status));\n    }\n    setCurrentUser(user) {\n      return __awaiter(this, void 0, void 0, function*() {\n        yield this._persister.setItem(\"currentUser\", JSON.stringify(user));\n      });\n    }\n    getCurrentUserCached() {\n      return this._currentUserCached;\n    }\n    getCurrentUser() {\n      return __awaiter(this, void 0, void 0, function*() {\n        var oauthResp = yield this._waitForOAuthCallbackResponse();\n        if (null === oauthResp || void 0 === oauthResp ? 0 : oauthResp.error) {\n          return oauthResp = {error:oauthResp.error, user:void 0}, this._currentUserCached = Object.assign({isLoading:!1}, oauthResp), oauthResp;\n        }\n        oauthResp = yield this._persister.getItem(\"currentUser\");\n        oauthResp = {user:JSON.parse(oauthResp), error:void 0};\n        this._currentUserCached = Object.assign({isLoading:!1}, oauthResp);\n        return oauthResp;\n      });\n    }\n    _hasCurrentUser() {\n      return __awaiter(this, void 0, void 0, function*() {\n        const user = yield this._persister.getItem(\"currentUser\");\n        return null != JSON.parse(user);\n      });\n    }\n    changeCurrentUser(newUser) {\n      return __awaiter(this, void 0, void 0, function*() {\n        var _a;\n        const {user:oldUser} = yield this.getCurrentUser();\n        if (!(0,object_1.areObjectsDeepEqual)(oldUser, newUser)) {\n          yield this.setCurrentUser(newUser);\n          this.updateUser(newUser);\n          try {\n            null === (_a = this._broadcastChannel) || void 0 === _a || _a.postMessage({type:\"auth\"});\n          } catch (error) {\n            console.error(\"Error posting message to broadcast channel\", error);\n          }\n        }\n      });\n    }\n    updateUser(newUser) {\n      newUser = {error:void 0, user:newUser};\n      this._currentUserCached = Object.assign({isLoading:!1}, newUser);\n      this._dataForQueryCache = {};\n      this.querySubs.set(prev => {\n        Object.keys(prev).forEach(k => {\n          delete prev[k].result;\n        });\n        return prev;\n      });\n      this._reconnectTimeoutMs = 0;\n      this._ws.close();\n      this._oauthCallbackResponse = null;\n      this.notifyAuthSubs(newUser);\n    }\n    sendMagicCode({email}) {\n      return authAPI.sendMagicCode({apiURI:this.config.apiURI, appId:this.config.appId, email});\n    }\n    signInWithMagicCode(_a) {\n      return __awaiter(this, arguments, void 0, function*({email, code}) {\n        email = yield authAPI.verifyMagicCode({apiURI:this.config.apiURI, appId:this.config.appId, email, code});\n        yield this.changeCurrentUser(email.user);\n        return email;\n      });\n    }\n    signInWithCustomToken(authToken) {\n      return __awaiter(this, void 0, void 0, function*() {\n        const res = yield authAPI.verifyRefreshToken({apiURI:this.config.apiURI, appId:this.config.appId, refreshToken:authToken});\n        yield this.changeCurrentUser(res.user);\n        return res;\n      });\n    }\n    signOut() {\n      return __awaiter(this, void 0, void 0, function*() {\n        var _a, currentUser = yield this.getCurrentUser();\n        if (currentUser = null === (_a = null === currentUser || void 0 === currentUser ? void 0 : currentUser.user) || void 0 === _a ? void 0 : _a.refresh_token) {\n          try {\n            yield authAPI.signOut({apiURI:this.config.apiURI, appId:this.config.appId, refreshToken:currentUser});\n          } catch (e) {\n          }\n        }\n        yield this.changeCurrentUser(null);\n      });\n    }\n    createAuthorizationURL({clientName, redirectURL}) {\n      const {apiURI, appId} = this.config;\n      return `${apiURI}/runtime/oauth/start?app_id=${appId}&client_name=${clientName}&redirect_uri=${redirectURL}`;\n    }\n    exchangeCodeForToken(_a) {\n      return __awaiter(this, arguments, void 0, function*({code, codeVerifier}) {\n        code = yield authAPI.exchangeCodeForToken({apiURI:this.config.apiURI, appId:this.config.appId, code, codeVerifier});\n        yield this.changeCurrentUser(code.user);\n        return code;\n      });\n    }\n    issuerURI() {\n      const {apiURI, appId} = this.config;\n      return `${apiURI}/runtime/${appId}`;\n    }\n    signInWithIdToken(_a) {\n      return __awaiter(this, arguments, void 0, function*({idToken, clientName, nonce}) {\n        var _b, currentUser = yield this.getCurrentUser();\n        currentUser = null === (_b = null === currentUser || void 0 === currentUser ? void 0 : currentUser.user) || void 0 === _b ? void 0 : _b.refresh_token;\n        idToken = yield authAPI.signInWithIdToken({apiURI:this.config.apiURI, appId:this.config.appId, idToken, clientName, nonce, refreshToken:currentUser});\n        yield this.changeCurrentUser(idToken.user);\n        return idToken;\n      });\n    }\n    joinRoom(roomId) {\n      this._rooms[roomId] || (this._rooms[roomId] = {isConnected:!1, error:void 0});\n      this._presence[roomId] = this._presence[roomId] || {};\n      this._tryJoinRoom(roomId);\n      return () => {\n        this._cleanupRoom(roomId);\n      };\n    }\n    _cleanupRoom(roomId) {\n      var _a, _b, _c, _d;\n      null !== (_b = null === (_a = this._presence[roomId]) || void 0 === _a ? void 0 : _a.handlers) && void 0 !== _b && _b.length || Object.keys(null !== (_c = this._broadcastSubs[roomId]) && void 0 !== _c ? _c : {}).length || (_a = null === (_d = this._rooms[roomId]) || void 0 === _d ? void 0 : _d.isConnected, delete this._rooms[roomId], delete this._presence[roomId], delete this._broadcastSubs[roomId], _a ? this._tryLeaveRoom(roomId) : this._roomsPendingLeave[roomId] = !0);\n    }\n    getPresence(roomType, roomId, opts = {}) {\n      roomType = this._rooms[roomId];\n      roomId = this._presence[roomId];\n      return roomType && roomId && roomId.result ? Object.assign(Object.assign({}, (0,presence_1.buildPresenceSlice)(roomId.result, opts, this._sessionId)), {isLoading:!roomType.isConnected, error:roomType.error}) : null;\n    }\n    publishPresence(roomType, roomId, partialData) {\n      roomType = this._rooms[roomId];\n      const presence = this._presence[roomId];\n      roomType && presence && (presence.result = presence.result || {}, partialData = Object.assign(Object.assign({}, presence.result.user), partialData), presence.result.user = partialData, roomType.isConnected && (this._trySetPresence(roomId, partialData), this._notifyPresenceSubs(roomId)));\n    }\n    _trySetPresence(roomId, data) {\n      this._trySendAuthed((0,uuid_1.default)(), {op:\"set-presence\", \"room-id\":roomId, data});\n    }\n    _tryJoinRoom(roomId) {\n      this._trySendAuthed((0,uuid_1.default)(), {op:\"join-room\", \"room-id\":roomId});\n      delete this._roomsPendingLeave[roomId];\n    }\n    _tryLeaveRoom(roomId) {\n      this._trySendAuthed((0,uuid_1.default)(), {op:\"leave-room\", \"room-id\":roomId});\n    }\n    subscribePresence(roomType, roomId, opts, cb) {\n      const leaveRoom = this.joinRoom(roomId), handler = Object.assign(Object.assign({}, opts), {roomId, cb, prev:null});\n      this._presence[roomId] = this._presence[roomId] || {};\n      this._presence[roomId].handlers = this._presence[roomId].handlers || [];\n      this._presence[roomId].handlers.push(handler);\n      this._notifyPresenceSub(roomId, handler);\n      return () => {\n        var _a, _b, _c;\n        this._presence[roomId].handlers = null !== (_c = null === (_b = null === (_a = this._presence[roomId]) || void 0 === _a ? void 0 : _a.handlers) || void 0 === _b ? void 0 : _b.filter(x => x !== handler)) && void 0 !== _c ? _c : [];\n        leaveRoom();\n      };\n    }\n    _notifyPresenceSubs(roomId) {\n      var _a, _b;\n      null === (_b = null === (_a = this._presence[roomId]) || void 0 === _a ? void 0 : _a.handlers) || void 0 === _b || _b.forEach(handler => {\n        this._notifyPresenceSub(roomId, handler);\n      });\n    }\n    _notifyPresenceSub(roomId, handler) {\n      !(roomId = this.getPresence(\"\", roomId, handler)) || handler.prev && !(0,presence_1.hasPresenceResponseChanged)(roomId, handler.prev) || (handler.prev = roomId, handler.cb(roomId));\n    }\n    _patchPresencePeers(roomId, edits) {\n      var _a, _b, _c, _d;\n      const peers = (null === (_b = null === (_a = this._presence[roomId]) || void 0 === _a ? void 0 : _a.result) || void 0 === _b ? void 0 : _b.peers) || {};\n      _a = Object.fromEntries(Object.entries(peers).map(([k, v]) => [k, {data:v}]));\n      _a[this._sessionId] = {data:null === (_d = null === (_c = this._presence[roomId]) || void 0 === _c ? void 0 : _c.result) || void 0 === _d ? void 0 : _d.user};\n      for (let [path, op, value] of edits) {\n        if (\"+\" === op || \"r\" === op) {\n          _a = (0,object_1.assocIn)(_a, path, value);\n        }\n        \"-\" === op && (_a = (0,object_1.dissocIn)(_a, path));\n      }\n      this._setPresencePeers(roomId, _a);\n    }\n    _setPresencePeers(roomId, data) {\n      data = Object.assign({}, data);\n      delete data[this._sessionId];\n      data = Object.fromEntries(Object.entries(data).map(([k, v]) => [k, v.data]));\n      this._presence = (0,object_1.assocIn)(this._presence, [roomId, \"result\", \"peers\"], data);\n    }\n    publishTopic({roomType, roomId, topic, data}) {\n      var _a;\n      const room = this._rooms[roomId];\n      room && (room.isConnected ? this._tryBroadcast(roomId, roomType, topic, data) : (this._broadcastQueue[roomId] = null !== (_a = this._broadcastQueue[roomId]) && void 0 !== _a ? _a : [], this._broadcastQueue[roomId].push({topic, roomType, data})));\n    }\n    _tryBroadcast(roomId, roomType, topic, data) {\n      this._trySendAuthed((0,uuid_1.default)(), {op:\"client-broadcast\", \"room-id\":roomId, roomType, topic, data});\n    }\n    subscribeTopic(roomId, topic, cb) {\n      const leaveRoom = this.joinRoom(roomId);\n      this._broadcastSubs[roomId] = this._broadcastSubs[roomId] || {};\n      this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic] || [];\n      this._broadcastSubs[roomId][topic].push(cb);\n      this._presence[roomId] = this._presence[roomId] || {};\n      return () => {\n        this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic].filter(x => x !== cb);\n        this._broadcastSubs[roomId][topic].length || delete this._broadcastSubs[roomId][topic];\n        leaveRoom();\n      };\n    }\n    _notifyBroadcastSubs(room, topic, msg) {\n      var _a, _b, _c;\n      null === (_c = null === (_b = null === (_a = this._broadcastSubs) || void 0 === _a ? void 0 : _a[room]) || void 0 === _b ? void 0 : _b[topic]) || void 0 === _c || _c.forEach(cb => {\n        var _a, _b, _c, _d, _e, _f;\n        const data = null === (_a = msg.data) || void 0 === _a ? void 0 : _a.data;\n        _a = msg.data[\"peer-id\"] === this._sessionId ? null === (_c = null === (_b = this._presence[room]) || void 0 === _b ? void 0 : _b.result) || void 0 === _c ? void 0 : _c.user : null === (_f = null === (_e = null === (_d = this._presence[room]) || void 0 === _d ? void 0 : _d.result) || void 0 === _e ? void 0 : _e.peers) || void 0 === _f ? void 0 : _f[msg.data[\"peer-id\"]];\n        return cb(data, _a);\n      });\n    }\n    uploadFile(path, file, opts) {\n      return __awaiter(this, void 0, void 0, function*() {\n        var _a, currentUser = yield this.getCurrentUser();\n        currentUser = null === (_a = null === currentUser || void 0 === currentUser ? void 0 : currentUser.user) || void 0 === _a ? void 0 : _a.refresh_token;\n        return StorageApi.uploadFile(Object.assign(Object.assign({}, opts), {apiURI:this.config.apiURI, appId:this.config.appId, path, file, refreshToken:currentUser}));\n      });\n    }\n    deleteFile(path) {\n      return __awaiter(this, void 0, void 0, function*() {\n        var _a, currentUser = yield this.getCurrentUser();\n        currentUser = null === (_a = null === currentUser || void 0 === currentUser ? void 0 : currentUser.user) || void 0 === _a ? void 0 : _a.refresh_token;\n        return yield StorageApi.deleteFile({apiURI:this.config.apiURI, appId:this.config.appId, path, refreshToken:currentUser});\n      });\n    }\n    upload(path, file) {\n      return __awaiter(this, void 0, void 0, function*() {\n        var _a, currentUser = yield this.getCurrentUser();\n        currentUser = null === (_a = null === currentUser || void 0 === currentUser ? void 0 : currentUser.user) || void 0 === _a ? void 0 : _a.refresh_token;\n        _a = yield StorageApi.getSignedUploadUrl({apiURI:this.config.apiURI, appId:this.config.appId, fileName:path || file.name, refreshToken:currentUser});\n        return yield StorageApi.upload(_a, file);\n      });\n    }\n    getDownloadUrl(path) {\n      return __awaiter(this, void 0, void 0, function*() {\n        var _a, currentUser = yield this.getCurrentUser();\n        currentUser = null === (_a = null === currentUser || void 0 === currentUser ? void 0 : currentUser.user) || void 0 === _a ? void 0 : _a.refresh_token;\n        return yield StorageApi.getDownloadUrl({apiURI:this.config.apiURI, appId:this.config.appId, path, refreshToken:currentUser});\n      });\n    }\n  }\n  exports.default = Reactor;\n};\n","~:source","shadow$provide[\"module$node_modules$$instantdb$core$dist$Reactor\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-check\nconst log_1 = __importDefault(require(\"./utils/log\"));\nconst weakHash_1 = __importDefault(require(\"./utils/weakHash\"));\nconst instaql_1 = __importDefault(require(\"./instaql\"));\nconst instaml = __importStar(require(\"./instaml\"));\nconst s = __importStar(require(\"./store\"));\nconst uuid_1 = __importDefault(require(\"./utils/uuid\"));\nconst IndexedDBStorage_1 = __importDefault(require(\"./IndexedDBStorage\"));\nconst WindowNetworkListener_1 = __importDefault(require(\"./WindowNetworkListener\"));\nconst authAPI = __importStar(require(\"./authAPI\"));\nconst StorageApi = __importStar(require(\"./StorageAPI\"));\nconst presence_1 = require(\"./presence\");\nconst Deferred_1 = require(\"./utils/Deferred\");\nconst PersistedObject_1 = require(\"./utils/PersistedObject\");\nconst instaqlResult_1 = require(\"./model/instaqlResult\");\nconst object_1 = require(\"./utils/object\");\nconst linkIndex_1 = require(\"./utils/linkIndex\");\nconst version_1 = __importDefault(require(\"./version\"));\nconst STATUS = {\n    CONNECTING: 'connecting',\n    OPENED: 'opened',\n    AUTHENTICATED: 'authenticated',\n    CLOSED: 'closed',\n    ERRORED: 'errored',\n};\nconst QUERY_ONCE_TIMEOUT = 30000;\nconst WS_CONNECTING_STATUS = 0;\nconst WS_OPEN_STATUS = 1;\nconst defaultConfig = {\n    apiURI: 'https://api.instantdb.com',\n    websocketURI: 'wss://api.instantdb.com/runtime/session',\n};\n// Param that the backend adds if this is an oauth redirect\nconst OAUTH_REDIRECT_PARAM = '_instant_oauth_redirect';\nconst currentUserKey = `currentUser`;\nlet _wsId = 0;\nfunction createWebSocket(uri) {\n    const ws = new WebSocket(uri);\n    // @ts-ignore\n    ws._id = _wsId++;\n    return ws;\n}\nfunction isClient() {\n    const hasWindow = typeof window !== 'undefined';\n    // this checks if we are running in a chrome extension\n    // @ts-expect-error\n    const isChrome = typeof chrome !== 'undefined';\n    return hasWindow || isChrome;\n}\nconst ignoreLogging = {\n    'set-presence': true,\n    'set-presence-ok': true,\n    'refresh-presence': true,\n    'patch-presence': true,\n};\nfunction querySubsFromJSON(str) {\n    var _a;\n    const parsed = JSON.parse(str);\n    for (const key in parsed) {\n        const v = parsed[key];\n        if ((_a = v === null || v === void 0 ? void 0 : v.result) === null || _a === void 0 ? void 0 : _a.store) {\n            v.result.store = s.fromJSON(v.result.store);\n        }\n    }\n    return parsed;\n}\nfunction querySubsToJSON(querySubs) {\n    var _a;\n    const jsonSubs = {};\n    for (const key in querySubs) {\n        const sub = querySubs[key];\n        const jsonSub = Object.assign({}, sub);\n        if ((_a = sub.result) === null || _a === void 0 ? void 0 : _a.store) {\n            jsonSub.result = Object.assign(Object.assign({}, sub.result), { store: s.toJSON(sub.result.store) });\n        }\n        jsonSubs[key] = jsonSub;\n    }\n    return JSON.stringify(jsonSubs);\n}\n/**\n * @template {import('./presence').RoomSchemaShape} [RoomSchema = {}]\n */\nclass Reactor {\n    constructor(config, Storage = IndexedDBStorage_1.default, NetworkListener = WindowNetworkListener_1.default, versions) {\n        this._isOnline = true;\n        this._isShutdown = false;\n        this.status = STATUS.CONNECTING;\n        /** @type {Record<string, Array<{ q: any, cb: (data: any) => any }>>} */\n        this.queryCbs = {};\n        /** @type {Record<string, Array<{ q: any, eventId: string, dfd: Deferred }>>} */\n        this.queryOnceDfds = {};\n        this.authCbs = [];\n        this.attrsCbs = [];\n        this.mutationErrorCbs = [];\n        this.connectionStatusCbs = [];\n        this.mutationDeferredStore = new Map();\n        this._reconnectTimeoutId = null;\n        this._reconnectTimeoutMs = 0;\n        this._localIdPromises = {};\n        this._errorMessage = null;\n        /** @type {Promise<null | {error: {message: string}}>}**/\n        this._oauthCallbackResponse = null;\n        /** @type {null | import('./utils/linkIndex').LinkIndex}} */\n        this._linkIndex = null;\n        /** @type {Record<string, {isConnected: boolean; error: any}>} */\n        this._rooms = {};\n        /** @type {Record<string, boolean>} */\n        this._roomsPendingLeave = {};\n        this._presence = {};\n        this._broadcastQueue = [];\n        this._broadcastSubs = {};\n        this._currentUserCached = { isLoading: true, error: undefined, user: undefined };\n        this._beforeUnloadCbs = [];\n        this._dataForQueryCache = {};\n        /**\n         *  merge querySubs from storage and in memory. Has the following side\n         *  effects:\n         *  - We notify all queryCbs because results may been added during merge\n         */\n        this._onMergeQuerySubs = (_storageSubs, inMemorySubs) => {\n            const storageSubs = _storageSubs || {};\n            const ret = Object.assign({}, inMemorySubs);\n            // Consider an inMemorySub with no result;\n            // If we have a result from storageSubs, let's add it\n            Object.entries(inMemorySubs).forEach(([hash, querySub]) => {\n                var _a;\n                const storageResult = (_a = storageSubs === null || storageSubs === void 0 ? void 0 : storageSubs[hash]) === null || _a === void 0 ? void 0 : _a.result;\n                const memoryResult = querySub.result;\n                if (storageResult && !memoryResult) {\n                    ret[hash].result = storageResult;\n                }\n            });\n            // Consider a storageSub with no corresponding inMemorySub\n            // This means that at least at this point,\n            // the user has not asked to subscribe to the query.\n            // We may _still_ want to add it, because in just a\n            // few milliseconds, the user will ask to subscribe to the\n            // query.\n            // For now, we can't really tell if the user will ask to subscribe\n            // or not. So for now let's just add the first 10 queries from storage.\n            // Eventually, we could be smarter about this. For example,\n            // we can keep usage information about which queries are popular.\n            const storageKsToAdd = Object.keys(storageSubs)\n                .filter((k) => !inMemorySubs[k])\n                .slice(0, 10);\n            storageKsToAdd.forEach((k) => {\n                ret[k] = storageSubs[k];\n            });\n            // Okay, now we have merged our querySubs\n            this.querySubs.set((_) => ret);\n            this.loadedNotifyAll();\n        };\n        /**\n         * merge pendingMutations from storage and in memory. Has a side effect of\n         * sending mutations that were stored but not acked\n         */\n        this._onMergePendingMutations = (storageMuts, inMemoryMuts) => {\n            const ret = new Map([...storageMuts.entries(), ...inMemoryMuts.entries()]);\n            this.pendingMutations.set((_) => ret);\n            this.loadedNotifyAll();\n            const rewrittenStorageMuts = this._rewriteMutations(this.attrs, storageMuts);\n            rewrittenStorageMuts.forEach((mut, k) => {\n                if (!inMemoryMuts.has(k) && !mut['tx-id']) {\n                    this._sendMutation(k, mut);\n                }\n            });\n        };\n        // ---------------------------\n        // Queries\n        this.getPreviousResult = (q) => {\n            const hash = (0, weakHash_1.default)(q);\n            return this.dataForQuery(hash);\n        };\n        /** Re-run instaql and call all callbacks with new data */\n        this.notifyOne = (hash) => {\n            var _a, _b;\n            const cbs = (_a = this.queryCbs[hash]) !== null && _a !== void 0 ? _a : [];\n            const prevData = (_b = this._dataForQueryCache[hash]) === null || _b === void 0 ? void 0 : _b.data;\n            const data = this.dataForQuery(hash);\n            if (!data)\n                return;\n            if ((0, object_1.areObjectsDeepEqual)(data, prevData))\n                return;\n            cbs.forEach((r) => r.cb(data));\n        };\n        this.notifyOneQueryOnce = (hash) => {\n            var _a;\n            const dfds = (_a = this.queryOnceDfds[hash]) !== null && _a !== void 0 ? _a : [];\n            const data = this.dataForQuery(hash);\n            dfds.forEach((r) => {\n                this._completeQueryOnce(r.q, hash, r.dfd);\n                r.dfd.resolve(data);\n            });\n        };\n        this.notifyQueryError = (hash, error) => {\n            const cbs = this.queryCbs[hash] || [];\n            cbs.forEach((r) => r.cb({ error }));\n        };\n        /** Applies transactions locally and sends transact message to server */\n        this.pushTx = (chunks) => {\n            try {\n                const txSteps = instaml.transform({ attrs: this.optimisticAttrs(), schema: this.config.schema }, chunks);\n                return this.pushOps(txSteps);\n            }\n            catch (e) {\n                return this.pushOps([], e);\n            }\n        };\n        /**\n         * @param {*} txSteps\n         * @param {*} [error]\n         * @returns\n         */\n        this.pushOps = (txSteps, error) => {\n            const eventId = (0, uuid_1.default)();\n            const mutation = {\n                op: 'transact',\n                'tx-steps': txSteps,\n                error,\n            };\n            this.pendingMutations.set((prev) => {\n                prev.set(eventId, mutation);\n                return prev;\n            });\n            const dfd = new Deferred_1.Deferred();\n            this.mutationDeferredStore.set(eventId, dfd);\n            this._sendMutation(eventId, mutation);\n            this.notifyAll();\n            return dfd.promise;\n        };\n        this._wsOnOpen = (e) => {\n            const targetWs = e.target;\n            if (this._ws !== targetWs) {\n                log_1.default.info('[socket][open]', targetWs._id, 'skip; this is no longer the current ws');\n                return;\n            }\n            log_1.default.info('[socket][open]', this._ws._id);\n            this._setStatus(STATUS.OPENED);\n            this.getCurrentUser().then((resp) => {\n                var _a;\n                this._trySend((0, uuid_1.default)(), {\n                    op: 'init',\n                    'app-id': this.config.appId,\n                    'refresh-token': (_a = resp.user) === null || _a === void 0 ? void 0 : _a['refresh_token'],\n                    versions: this.versions,\n                    // If an admin token is provided for an app, we will\n                    // skip all permission checks. This is an advanced feature,\n                    // to let users write internal tools\n                    // This option is not exposed in `Config`, as it's\n                    // not ready for prime time\n                    '__admin-token': this.config.__adminToken,\n                });\n            });\n        };\n        this._wsOnMessage = (e) => {\n            const targetWs = e.target;\n            const m = JSON.parse(e.data.toString());\n            if (this._ws !== targetWs) {\n                log_1.default.info('[socket][message]', targetWs._id, m, 'skip; this is no longer the current ws');\n                return;\n            }\n            this._handleReceive(targetWs._id, JSON.parse(e.data.toString()));\n        };\n        this._wsOnError = (e) => {\n            const targetWs = e.target;\n            if (this._ws !== targetWs) {\n                log_1.default.info('[socket][error]', targetWs._id, 'skip; this is no longer the current ws');\n                return;\n            }\n            log_1.default.error('[socket][error]', targetWs._id, e);\n        };\n        this._wsOnClose = (e) => {\n            const targetWs = e.target;\n            if (this._ws !== targetWs) {\n                log_1.default.info('[socket][close]', targetWs._id, 'skip; this is no longer the current ws');\n                return;\n            }\n            this._setStatus(STATUS.CLOSED);\n            for (const room of Object.values(this._rooms)) {\n                room.isConnected = false;\n            }\n            if (this._isShutdown) {\n                log_1.default.info('[socket][close]', targetWs._id, 'Reactor has been shut down and will not reconnect');\n                return;\n            }\n            log_1.default.info('[socket][close]', targetWs._id, 'schedule reconnect, ms =', this._reconnectTimeoutMs);\n            setTimeout(() => {\n                this._reconnectTimeoutMs = Math.min(this._reconnectTimeoutMs + 1000, 10000);\n                if (!this._isOnline) {\n                    log_1.default.info('[socket][close]', targetWs._id, 'we are offline, no need to start socket');\n                    return;\n                }\n                this._startSocket();\n            }, this._reconnectTimeoutMs);\n        };\n        this.config = Object.assign(Object.assign({}, defaultConfig), config);\n        this.versions = Object.assign(Object.assign({}, (versions || {})), { '@instantdb/core': version_1.default });\n        if (this.config.schema) {\n            this._linkIndex = (0, linkIndex_1.createLinkIndex)(this.config.schema);\n        }\n        // This is to protect us against running\n        // server-side.\n        if (!isClient()) {\n            return;\n        }\n        if (typeof BroadcastChannel === 'function') {\n            this._broadcastChannel = new BroadcastChannel('@instantdb');\n            this._broadcastChannel.addEventListener('message', (e) => __awaiter(this, void 0, void 0, function* () {\n                var _a;\n                if (((_a = e.data) === null || _a === void 0 ? void 0 : _a.type) === 'auth') {\n                    const res = yield this.getCurrentUser();\n                    this.updateUser(res.user);\n                }\n            }));\n        }\n        this._oauthCallbackResponse = this._oauthLoginInit();\n        this._initStorage(Storage);\n        // kick off a request to cache it\n        this.getCurrentUser();\n        NetworkListener.getIsOnline().then((isOnline) => {\n            this._isOnline = isOnline;\n            this._startSocket();\n            NetworkListener.listen((isOnline) => {\n                // We do this because react native's NetInfo\n                // fires multiple online events.\n                // We only want to handle one state change\n                if (isOnline === this._isOnline) {\n                    return;\n                }\n                log_1.default.info('[network] online =', isOnline);\n                this._isOnline = isOnline;\n                if (this._isOnline) {\n                    this._startSocket();\n                }\n                else {\n                    log_1.default.info('Changing status from', this.status, 'to', STATUS.CLOSED);\n                    this._setStatus(STATUS.CLOSED);\n                }\n            });\n        });\n        if (typeof addEventListener !== 'undefined') {\n            this._beforeUnload = this._beforeUnload.bind(this);\n            addEventListener('beforeunload', this._beforeUnload);\n        }\n    }\n    _initStorage(Storage) {\n        this._persister = new Storage(`instant_${this.config.appId}_5`);\n        this.querySubs = new PersistedObject_1.PersistedObject(this._persister, 'querySubs', {}, this._onMergeQuerySubs, querySubsToJSON, querySubsFromJSON);\n        this.pendingMutations = new PersistedObject_1.PersistedObject(this._persister, 'pendingMutations', new Map(), this._onMergePendingMutations, (x) => {\n            return JSON.stringify([...x.entries()]);\n        }, (x) => {\n            return new Map(JSON.parse(x));\n        });\n        this._beforeUnloadCbs.push(() => {\n            this.pendingMutations.flush();\n            this.querySubs.flush();\n        });\n    }\n    _beforeUnload() {\n        for (const cb of this._beforeUnloadCbs) {\n            cb();\n        }\n    }\n    /**\n     * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status\n     * @param string clientId\n     * @param {{message?: string, hint?: string, error?: Error}} [errDetails]\n     */\n    _finishTransaction(status, clientId, errDetails) {\n        const dfd = this.mutationDeferredStore.get(clientId);\n        this.mutationDeferredStore.delete(clientId);\n        const ok = status !== 'error' && status !== 'timeout';\n        if (!dfd && !ok) {\n            // console.erroring here, as there are no listeners to let know\n            console.error('Mutation failed', Object.assign({ status, clientId }, errDetails));\n        }\n        if (!dfd) {\n            return;\n        }\n        if (ok) {\n            dfd.resolve({ status, clientId });\n        }\n        else {\n            dfd.reject(Object.assign({ status, clientId }, errDetails));\n        }\n    }\n    _setStatus(status, err) {\n        this.status = status;\n        this._errorMessage = err;\n        this.notifyConnectionStatusSubs(status);\n    }\n    _flushEnqueuedRoomData(roomId) {\n        var _a, _b;\n        const enqueuedUserPresence = (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b.user;\n        const enqueuedBroadcasts = this._broadcastQueue[roomId];\n        this._broadcastQueue[roomId] = [];\n        if (enqueuedUserPresence) {\n            this._trySetPresence(roomId, enqueuedUserPresence);\n        }\n        if (enqueuedBroadcasts) {\n            for (const item of enqueuedBroadcasts) {\n                const { topic, roomType, data } = item;\n                this._tryBroadcast(roomId, roomType, topic, data);\n            }\n        }\n    }\n    _handleReceive(wsId, msg) {\n        var _a, _b, _c, _d;\n        // opt-out, enabled by default if schema\n        const enableCardinalityInference = Boolean(this.config.schema) &&\n            ('cardinalityInference' in this.config\n                ? Boolean(this.config.cardinalityInference)\n                : true);\n        if (!ignoreLogging[msg.op]) {\n            log_1.default.info('[receive]', wsId, msg.op, msg);\n        }\n        switch (msg.op) {\n            case 'init-ok':\n                this._setStatus(STATUS.AUTHENTICATED);\n                this._reconnectTimeoutMs = 0;\n                this._setAttrs(msg.attrs);\n                this._flushPendingMessages();\n                // (EPH): set session-id, so we know\n                // which item is us\n                this._sessionId = msg['session-id'];\n                for (const roomId of Object.keys(this._rooms)) {\n                    this._tryJoinRoom(roomId);\n                }\n                break;\n            case 'add-query-exists':\n                this.notifyOneQueryOnce((0, weakHash_1.default)(msg.q));\n                break;\n            case 'add-query-ok':\n                const { q, result } = msg;\n                const hash = (0, weakHash_1.default)(q);\n                const pageInfo = (_b = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b['page-info'];\n                const aggregate = (_d = (_c = result === null || result === void 0 ? void 0 : result[0]) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d['aggregate'];\n                const triples = (0, instaqlResult_1.extractTriples)(result);\n                const store = s.createStore(this.attrs, triples, enableCardinalityInference, this._linkIndex);\n                this.querySubs.set((prev) => {\n                    prev[hash].result = { store, pageInfo, aggregate };\n                    return prev;\n                });\n                this.notifyOne(hash);\n                this.notifyOneQueryOnce(hash);\n                break;\n            case 'refresh-ok':\n                const { computations, attrs } = msg;\n                this._setAttrs(attrs);\n                const updates = computations.map((x) => {\n                    var _a, _b, _c, _d;\n                    const q = x['instaql-query'];\n                    const result = x['instaql-result'];\n                    const hash = (0, weakHash_1.default)(q);\n                    const triples = (0, instaqlResult_1.extractTriples)(result);\n                    const store = s.createStore(this.attrs, triples, enableCardinalityInference, this._linkIndex);\n                    const pageInfo = (_b = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b['page-info'];\n                    const aggregate = (_d = (_c = result === null || result === void 0 ? void 0 : result[0]) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d['aggregate'];\n                    return { hash, store, pageInfo, aggregate };\n                });\n                updates.forEach(({ hash, store, pageInfo, aggregate }) => {\n                    this.querySubs.set((prev) => {\n                        prev[hash].result = { store, pageInfo, aggregate };\n                        return prev;\n                    });\n                });\n                updates.forEach(({ hash }) => {\n                    this.notifyOne(hash);\n                });\n                break;\n            case 'transact-ok':\n                const { 'client-event-id': eventId, 'tx-id': txId } = msg;\n                const muts = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue);\n                const prevMutation = muts.get(eventId);\n                if (!prevMutation) {\n                    break;\n                }\n                // Now that this transaction is accepted,\n                // We can delete it from our queue.\n                this.pendingMutations.set((prev) => {\n                    prev.delete(eventId);\n                    return prev;\n                });\n                // We apply this transaction to all our existing queries\n                const txStepsToApply = prevMutation['tx-steps'];\n                this.querySubs.set((prev) => {\n                    var _a;\n                    for (const [hash, sub] of Object.entries(prev)) {\n                        const store = (_a = sub === null || sub === void 0 ? void 0 : sub.result) === null || _a === void 0 ? void 0 : _a.store;\n                        if (!store) {\n                            continue;\n                        }\n                        const newStore = s.transact(store, txStepsToApply);\n                        prev[hash].result.store = newStore;\n                    }\n                    return prev;\n                });\n                const newAttrs = prevMutation['tx-steps']\n                    .filter(([action, ..._args]) => action === 'add-attr')\n                    .map(([_action, attr]) => attr)\n                    .concat(Object.values(this.attrs));\n                this._setAttrs(newAttrs);\n                this._finishTransaction('synced', eventId);\n                break;\n            case 'patch-presence': {\n                const roomId = msg['room-id'];\n                this._patchPresencePeers(roomId, msg['edits']);\n                this._notifyPresenceSubs(roomId);\n                break;\n            }\n            case 'refresh-presence': {\n                const roomId = msg['room-id'];\n                this._setPresencePeers(roomId, msg['data']);\n                this._notifyPresenceSubs(roomId);\n                break;\n            }\n            case 'server-broadcast':\n                const room = msg['room-id'];\n                const topic = msg.topic;\n                this._notifyBroadcastSubs(room, topic, msg);\n                break;\n            case 'join-room-ok':\n                const loadingRoomId = msg['room-id'];\n                const joinedRoom = this._rooms[loadingRoomId];\n                if (!joinedRoom) {\n                    if (this._roomsPendingLeave[loadingRoomId]) {\n                        this._tryLeaveRoom(loadingRoomId);\n                        delete this._roomsPendingLeave[loadingRoomId];\n                    }\n                    break;\n                }\n                joinedRoom.isConnected = true;\n                this._notifyPresenceSubs(loadingRoomId);\n                this._flushEnqueuedRoomData(loadingRoomId);\n                break;\n            case 'join-room-error':\n                const errorRoomId = msg['room-id'];\n                const errorRoom = this._rooms[errorRoomId];\n                if (errorRoom) {\n                    errorRoom.error = msg['error'];\n                }\n                this._notifyPresenceSubs(errorRoomId);\n                break;\n            case 'error':\n                this._handleReceiveError(msg);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * @param {'timeout' | 'error'} status\n     * @param {string} eventId\n     * @param {{message?: string, hint?: string, error?: Error}} errDetails\n     */\n    _handleMutationError(status, eventId, errDetails) {\n        const mut = this.pendingMutations.currentValue.get(eventId);\n        if (mut && (status !== 'timeout' || !mut['tx-id'])) {\n            this.pendingMutations.set((prev) => {\n                prev.delete(eventId);\n                return prev;\n            });\n            this.notifyAll();\n            this.notifyAttrsSubs();\n            this.notifyMutationErrorSubs(errDetails);\n            this._finishTransaction(status, eventId, errDetails);\n        }\n    }\n    _handleReceiveError(msg) {\n        var _a, _b, _c, _d, _e;\n        const eventId = msg['client-event-id'];\n        const prevMutation = this.pendingMutations.currentValue.get(eventId);\n        const errorMessage = {\n            message: msg.message || 'Uh-oh, something went wrong. Ping Joe & Stopa.',\n        };\n        if (msg.hint) {\n            errorMessage.hint = msg.hint;\n        }\n        if (prevMutation) {\n            // This must be a transaction error\n            const errDetails = {\n                message: msg.message,\n                hint: msg.hint,\n            };\n            this._handleMutationError('error', eventId, errDetails);\n            return;\n        }\n        if (((_a = msg['original-event']) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('q')) &&\n            ((_b = msg['original-event']) === null || _b === void 0 ? void 0 : _b.op) === 'add-query') {\n            const q = (_c = msg['original-event']) === null || _c === void 0 ? void 0 : _c.q;\n            const hash = (0, weakHash_1.default)(q);\n            this.notifyQueryError((0, weakHash_1.default)(q), errorMessage);\n            this.notifyQueryOnceError(q, hash, eventId, errorMessage);\n            return;\n        }\n        const isInitError = ((_d = msg['original-event']) === null || _d === void 0 ? void 0 : _d.op) === 'init';\n        if (isInitError) {\n            if (msg.type === 'record-not-found' &&\n                ((_e = msg.hint) === null || _e === void 0 ? void 0 : _e['record-type']) === 'app-user') {\n                // User has been logged out\n                this.changeCurrentUser(null);\n                return;\n            }\n            // We failed to init\n            this._setStatus(STATUS.ERRORED, errorMessage);\n            this.notifyAll();\n            return;\n        }\n        // We've caught some error which has no corresponding listener.\n        // Let's console.error to let the user know.\n        const errorObj = Object.assign({}, msg);\n        delete errorObj.message;\n        delete errorObj.hint;\n        console.error(msg.message, errorObj);\n        if (msg.hint) {\n            console.error('This error comes with some debugging information. Here it is: \\n', msg.hint);\n        }\n    }\n    notifyQueryOnceError(q, hash, eventId, e) {\n        var _a;\n        const r = (_a = this.queryOnceDfds[hash]) === null || _a === void 0 ? void 0 : _a.find((r) => r.eventId === eventId);\n        if (!r)\n            return;\n        r.dfd.reject(e);\n        this._completeQueryOnce(q, hash, r.dfd);\n    }\n    _setAttrs(attrs) {\n        this.attrs = attrs.reduce((acc, attr) => {\n            acc[attr.id] = attr;\n            return acc;\n        }, {});\n        this.notifyAttrsSubs();\n    }\n    _startQuerySub(q, hash) {\n        const eventId = (0, uuid_1.default)();\n        this.querySubs.set((prev) => {\n            prev[hash] = prev[hash] || { q, result: null, eventId };\n            return prev;\n        });\n        this._trySendAuthed(eventId, { op: 'add-query', q });\n        return eventId;\n    }\n    /**\n     *  When a user subscribes to a query the following side effects occur:\n     *\n     *  - We update querySubs to include the new query\n     *  - We update queryCbs to include the new cb\n     *  - If we already have a result for the query we call cb immediately\n     *  - We send the server an `add-query` message\n     *\n     *  Returns an unsubscribe function\n     */\n    subscribeQuery(q, cb) {\n        var _a;\n        const hash = (0, weakHash_1.default)(q);\n        const prevResult = this.getPreviousResult(q);\n        if (prevResult) {\n            cb(prevResult);\n        }\n        this.queryCbs[hash] = (_a = this.queryCbs[hash]) !== null && _a !== void 0 ? _a : [];\n        this.queryCbs[hash].push({ q, cb });\n        this._startQuerySub(q, hash);\n        return () => {\n            this._unsubQuery(q, hash, cb);\n        };\n    }\n    queryOnce(q) {\n        var _a;\n        const dfd = new Deferred_1.Deferred();\n        if (!this._isOnline) {\n            dfd.reject(new Error(\"We can't run `queryOnce`, because the device is offline.\"));\n            return dfd.promise;\n        }\n        if (!this.querySubs) {\n            dfd.reject(new Error(\"We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query\"));\n            return dfd.promise;\n        }\n        const hash = (0, weakHash_1.default)(q);\n        const eventId = this._startQuerySub(q, hash);\n        this.queryOnceDfds[hash] = (_a = this.queryOnceDfds[hash]) !== null && _a !== void 0 ? _a : [];\n        this.queryOnceDfds[hash].push({ q, dfd, eventId });\n        setTimeout(() => dfd.reject(new Error('Query timed out')), QUERY_ONCE_TIMEOUT);\n        return dfd.promise;\n    }\n    _completeQueryOnce(q, hash, dfd) {\n        if (!this.queryOnceDfds[hash])\n            return;\n        this.queryOnceDfds[hash] = this.queryOnceDfds[hash].filter((r) => r.dfd !== dfd);\n        this._cleanupQuery(q, hash);\n    }\n    _unsubQuery(q, hash, cb) {\n        if (!this.queryCbs[hash])\n            return;\n        this.queryCbs[hash] = this.queryCbs[hash].filter((r) => r.cb !== cb);\n        this._cleanupQuery(q, hash);\n    }\n    _cleanupQuery(q, hash) {\n        var _a, _b;\n        const hasListeners = ((_a = this.queryCbs[hash]) === null || _a === void 0 ? void 0 : _a.length) || ((_b = this.queryOnceDfds[hash]) === null || _b === void 0 ? void 0 : _b.length);\n        if (hasListeners)\n            return;\n        delete this.queryCbs[hash];\n        delete this.queryOnceDfds[hash];\n        this._trySendAuthed((0, uuid_1.default)(), { op: 'remove-query', q });\n    }\n    // When we `pushTx`, it's possible that we don't yet have `this.attrs`\n    // This means that `tx-steps` in `pendingMutations` will include `add-attr`\n    // commands for attrs that already exist.\n    //\n    // This will also affect `add-triple` and `retract-triple` which\n    // reference attr-ids that do not match the server.\n    //\n    // We fix this by rewriting `tx-steps` in each `pendingMutation`.\n    // We remove `add-attr` commands for attrs that already exist.\n    // We update `add-triple` and `retract-triple` commands to use the\n    // server attr-ids.\n    _rewriteMutations(attrs, muts) {\n        if (!attrs)\n            return muts;\n        const findExistingAttr = (attr) => {\n            const [_, etype, label] = attr['forward-identity'];\n            const existing = instaml.getAttrByFwdIdentName(attrs, etype, label);\n            return existing;\n        };\n        const findReverseAttr = (attr) => {\n            const [_, etype, label] = attr['forward-identity'];\n            const revAttr = instaml.getAttrByReverseIdentName(attrs, etype, label);\n            return revAttr;\n        };\n        const mapping = { attrIdMap: {}, refSwapAttrIds: new Set() };\n        const rewriteTxSteps = (txSteps) => {\n            const retTxSteps = [];\n            for (const txStep of txSteps) {\n                const [action] = txStep;\n                // Handles add-attr\n                // If existing, we drop it, and track it\n                // to update add/retract triples\n                if (action === 'add-attr') {\n                    const [_action, attr] = txStep;\n                    const existing = findExistingAttr(attr);\n                    if (existing) {\n                        mapping.attrIdMap[attr.id] = existing.id;\n                        continue;\n                    }\n                    if (attr['value-type'] === 'ref') {\n                        const revAttr = findReverseAttr(attr);\n                        if (revAttr) {\n                            mapping.attrIdMap[attr.id] = revAttr.id;\n                            mapping.refSwapAttrIds.add(attr.id);\n                            continue;\n                        }\n                    }\n                }\n                // Handles add-triple|retract-triple\n                // If in mapping, we update the attr-id\n                const newTxStep = instaml.rewriteStep(mapping, txStep);\n                retTxSteps.push(newTxStep);\n            }\n            return retTxSteps;\n        };\n        const rewritten = new Map();\n        for (const [k, mut] of muts.entries()) {\n            rewritten.set(k, Object.assign(Object.assign({}, mut), { 'tx-steps': rewriteTxSteps(mut['tx-steps']) }));\n        }\n        return rewritten;\n    }\n    // ---------------------------\n    // Transact\n    optimisticAttrs() {\n        var _a;\n        const pendingMutationSteps = [\n            ...this.pendingMutations.currentValue.values(),\n        ] // hack due to Map()\n            .flatMap((x) => x['tx-steps']);\n        const deletedAttrIds = new Set(pendingMutationSteps\n            .filter(([action, _attr]) => action === 'delete-attr')\n            .map(([_action, id]) => id));\n        const pendingAttrs = [];\n        for (const [_action, attr] of pendingMutationSteps) {\n            if (_action === 'add-attr') {\n                pendingAttrs.push(attr);\n            }\n            else if (_action === 'update-attr' &&\n                attr.id &&\n                ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a[attr.id])) {\n                const fullAttr = Object.assign(Object.assign({}, this.attrs[attr.id]), attr);\n                pendingAttrs.push(fullAttr);\n            }\n        }\n        const attrsWithoutDeleted = [\n            ...Object.values(this.attrs || {}),\n            ...pendingAttrs,\n        ].filter((a) => !deletedAttrIds.has(a.id));\n        const attrsRecord = Object.fromEntries(attrsWithoutDeleted.map((a) => [a.id, a]));\n        return attrsRecord;\n    }\n    /** Runs instaql on a query and a store */\n    dataForQuery(hash) {\n        const errorMessage = this._errorMessage;\n        if (errorMessage) {\n            return { error: errorMessage };\n        }\n        if (!this.querySubs)\n            return;\n        if (!this.pendingMutations)\n            return;\n        const querySubVersion = this.querySubs.version();\n        const querySubs = this.querySubs.currentValue;\n        const pendingMutationsVersion = this.pendingMutations.version();\n        const pendingMutations = this.pendingMutations.currentValue;\n        const { q, result } = querySubs[hash] || {};\n        if (!result)\n            return;\n        const cached = this._dataForQueryCache[hash];\n        if (cached &&\n            querySubVersion === cached.querySubVersion &&\n            pendingMutationsVersion === cached.pendingMutationsVersion) {\n            return cached.data;\n        }\n        const { store, pageInfo, aggregate } = result;\n        const muts = this._rewriteMutations(store.attrs, pendingMutations);\n        const txSteps = [...muts.values()].flatMap((x) => x['tx-steps']);\n        const newStore = s.transact(store, txSteps);\n        const resp = (0, instaql_1.default)({ store: newStore, pageInfo, aggregate }, q);\n        this._dataForQueryCache[hash] = {\n            querySubVersion,\n            pendingMutationsVersion,\n            data: resp,\n        };\n        return resp;\n    }\n    /** Re-compute all subscriptions */\n    notifyAll() {\n        Object.keys(this.queryCbs).forEach((hash) => {\n            this.notifyOne(hash);\n        });\n    }\n    loadedNotifyAll() {\n        if (this.pendingMutations.isLoading() || this.querySubs.isLoading())\n            return;\n        this.notifyAll();\n    }\n    shutdown() {\n        var _a;\n        this._isShutdown = true;\n        (_a = this._ws) === null || _a === void 0 ? void 0 : _a.close();\n    }\n    /**\n     * Sends mutation to server and schedules a timeout to cancel it if\n     * we don't hear back in time.\n     * Note: If we're offline we don't schedule a timeout, we'll schedule it\n     * later once we're back online and send the mutation again\n     *\n     */\n    _sendMutation(eventId, mutation) {\n        if (mutation.error) {\n            this._handleMutationError('error', eventId, {\n                error: mutation.error,\n                message: mutation.error.message,\n            });\n            return;\n        }\n        if (this.status !== STATUS.AUTHENTICATED) {\n            this._finishTransaction('enqueued', eventId);\n            return;\n        }\n        const timeoutMs = Math.max(5000, this.pendingMutations.currentValue.size * 5000);\n        if (!this._isOnline) {\n            this._finishTransaction('enqueued', eventId);\n        }\n        else {\n            this._trySend(eventId, mutation);\n            // If a transaction is pending for over 3 seconds,\n            // we want to unblock the UX, so mark it as pending\n            // and keep trying to process the transaction in the background\n            setTimeout(() => {\n                this._finishTransaction('pending', eventId);\n            }, 3000);\n            setTimeout(() => {\n                if (!this._isOnline) {\n                    return;\n                }\n                // If we are here, this means that we have sent this mutation, we are online\n                // but we have not received a response. If it's this long, something must be wrong,\n                // so we error with a timeout.\n                this._handleMutationError('timeout', eventId, {\n                    message: 'transaction timed out',\n                });\n            }, timeoutMs);\n        }\n    }\n    // ---------------------------\n    // Websocket\n    /** Send messages we accumulated while we were connecting */\n    _flushPendingMessages() {\n        const subs = Object.keys(this.queryCbs).map((hash) => {\n            return this.querySubs.currentValue[hash];\n        });\n        // Note: we should not have any nulls in subs, but we're\n        // doing this defensively just in case.\n        const safeSubs = subs.filter((x) => x);\n        safeSubs.forEach(({ eventId, q }) => {\n            this._trySendAuthed(eventId, { op: 'add-query', q });\n        });\n        Object.values(this.queryOnceDfds)\n            .flat()\n            .forEach(({ eventId, q }) => {\n            this._trySendAuthed(eventId, { op: 'add-query', q });\n        });\n        const muts = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue);\n        muts.forEach((mut, eventId) => {\n            if (!mut['tx-id']) {\n                this._sendMutation(eventId, mut);\n            }\n        });\n    }\n    _trySendAuthed(...args) {\n        if (this.status !== STATUS.AUTHENTICATED) {\n            return;\n        }\n        this._trySend(...args);\n    }\n    _trySend(eventId, msg, opts) {\n        if (this._ws.readyState !== WS_OPEN_STATUS) {\n            return;\n        }\n        if (!ignoreLogging[msg.op]) {\n            log_1.default.info('[send]', this._ws._id, msg.op, msg);\n        }\n        this._ws.send(JSON.stringify(Object.assign({ 'client-event-id': eventId }, msg)));\n    }\n    _startSocket() {\n        if (this._ws && this._ws.readyState == WS_CONNECTING_STATUS) {\n            // Our current websocket is in a 'connecting' state.\n            // There's no need to start another one, as the socket is\n            // effectively fresh.\n            log_1.default.info('[socket][start]', this._ws._id, 'maintained as current ws, we were still in a connecting state');\n            return;\n        }\n        const prevWs = this._ws;\n        this._ws = createWebSocket(`${this.config.websocketURI}?app_id=${this.config.appId}`);\n        this._ws.onopen = this._wsOnOpen;\n        this._ws.onmessage = this._wsOnMessage;\n        this._ws.onclose = this._wsOnClose;\n        this._ws.onerror = this._wsOnError;\n        log_1.default.info('[socket][start]', this._ws._id);\n        if ((prevWs === null || prevWs === void 0 ? void 0 : prevWs.readyState) === WS_OPEN_STATUS) {\n            // When the network dies, it doesn't always mean that our\n            // socket connection will fire a close event.\n            //\n            // We _could_ re-use the old socket, if the network drop was a\n            // few seconds. But, to be safe right now we always create a new socket.\n            //\n            // This means that we have to make sure to kill the previous one ourselves.\n            // c.f https://issues.chromium.org/issues/41343684\n            log_1.default.info('[socket][start]', this._ws._id, 'close previous ws id = ', prevWs._id);\n            prevWs.close();\n        }\n    }\n    /**\n     * Given a key, returns a stable local id, unique to this device and app.\n     *\n     * This can be useful if you want to create guest ids for example.\n     *\n     * Note: If the user deletes their local storage, this id will change.\n     *\n     * We use this._localIdPromises to ensure that we only generate a local\n     * id once, even if multiple callers call this function concurrently.\n     */\n    getLocalId(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const k = `localToken_${name}`;\n            const id = yield this._persister.getItem(k);\n            if (id)\n                return id;\n            if (this._localIdPromises[k]) {\n                return this._localIdPromises[k];\n            }\n            const newId = (0, uuid_1.default)();\n            this._localIdPromises[k] = this._persister\n                .setItem(k, newId)\n                .then(() => newId);\n            return this._localIdPromises[k];\n        });\n    }\n    // ----\n    // Auth\n    _replaceUrlAfterOAuth() {\n        if (typeof URL === 'undefined') {\n            return;\n        }\n        const url = new URL(window.location.href);\n        if (url.searchParams.get(OAUTH_REDIRECT_PARAM)) {\n            const startUrl = url.toString();\n            url.searchParams.delete(OAUTH_REDIRECT_PARAM);\n            url.searchParams.delete('code');\n            url.searchParams.delete('error');\n            const newPath = url.pathname +\n                (url.searchParams.size ? '?' + url.searchParams : '') +\n                url.hash;\n            // Note: In next.js, this will revert to the old state if user navigates\n            //       back. We would need to allow framework specific routing to work\n            //       around that problem.\n            history.replaceState(history.state, '', newPath);\n            // navigation is part of the HTML spec, but not supported by Safari\n            // or Firefox yet:\n            // https://developer.mozilla.org/en-US/docs/Web/API/Navigation_API#browser_compatibility\n            if (\n            // @ts-ignore (waiting for ts support)\n            typeof navigation === 'object' &&\n                // @ts-ignore (waiting for ts support)\n                typeof navigation.addEventListener === 'function' &&\n                // @ts-ignore (waiting for ts support)\n                typeof navigation.removeEventListener === 'function') {\n                let ran = false;\n                // The next.js app router will reset the URL when the router loads.\n                // This puts it back after the router loads.\n                const listener = (e) => {\n                    var _a;\n                    if (!ran) {\n                        ran = true;\n                        // @ts-ignore (waiting for ts support)\n                        navigation.removeEventListener('navigate', listener);\n                        if (!e.userInitiated &&\n                            e.navigationType === 'replace' &&\n                            ((_a = e.destination) === null || _a === void 0 ? void 0 : _a.url) === startUrl) {\n                            history.replaceState(history.state, '', newPath);\n                        }\n                    }\n                };\n                // @ts-ignore (waiting for ts support)\n                navigation.addEventListener('navigate', listener);\n            }\n        }\n    }\n    /**\n     *\n     * @returns Promise<null | {error: {message: string}}>\n     */\n    _oauthLoginInit() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            if (typeof window === 'undefined' ||\n                typeof window.location === 'undefined' ||\n                typeof URLSearchParams === 'undefined') {\n                return null;\n            }\n            const params = new URLSearchParams(window.location.search);\n            if (!params.get(OAUTH_REDIRECT_PARAM)) {\n                return null;\n            }\n            const error = params.get('error');\n            if (error) {\n                this._replaceUrlAfterOAuth();\n                return { error: { message: error } };\n            }\n            const code = params.get('code');\n            if (!code) {\n                return null;\n            }\n            this._replaceUrlAfterOAuth();\n            try {\n                const { user } = yield authAPI.exchangeCodeForToken({\n                    apiURI: this.config.apiURI,\n                    appId: this.config.appId,\n                    code,\n                });\n                this.setCurrentUser(user);\n                return null;\n            }\n            catch (e) {\n                if (((_a = e === null || e === void 0 ? void 0 : e.body) === null || _a === void 0 ? void 0 : _a.type) === 'record-not-found' &&\n                    ((_c = (_b = e === null || e === void 0 ? void 0 : e.body) === null || _b === void 0 ? void 0 : _b.hint) === null || _c === void 0 ? void 0 : _c['record-type']) === 'app-oauth-code' &&\n                    (yield this._hasCurrentUser())) {\n                    // We probably just weren't able to clean up the URL, so\n                    // let's just ignore this error\n                    return null;\n                }\n                const message = ((_d = e === null || e === void 0 ? void 0 : e.body) === null || _d === void 0 ? void 0 : _d.message) || 'Error logging in.';\n                return { error: { message } };\n            }\n        });\n    }\n    _waitForOAuthCallbackResponse() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this._oauthCallbackResponse;\n        });\n    }\n    __subscribeMutationErrors(cb) {\n        this.mutationErrorCbs.push(cb);\n        return () => {\n            this.mutationErrorCbs = this.mutationErrorCbs.filter((x) => x !== cb);\n        };\n    }\n    subscribeAuth(cb) {\n        this.authCbs.push(cb);\n        const currUserCached = this._currentUserCached;\n        if (!currUserCached.isLoading) {\n            cb(this._currentUserCached);\n        }\n        let unsubbed = false;\n        this.getCurrentUser().then((resp) => {\n            if (unsubbed)\n                return;\n            if ((0, object_1.areObjectsDeepEqual)(resp, currUserCached))\n                return;\n            cb(resp);\n        });\n        return () => {\n            unsubbed = true;\n            this.authCbs = this.authCbs.filter((x) => x !== cb);\n        };\n    }\n    getAuth() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { user, error } = yield this.getCurrentUser();\n            if (error) {\n                throw error;\n            }\n            return user;\n        });\n    }\n    subscribeConnectionStatus(cb) {\n        this.connectionStatusCbs.push(cb);\n        return () => {\n            this.connectionStatusCbs = this.connectionStatusCbs.filter((x) => x !== cb);\n        };\n    }\n    subscribeAttrs(cb) {\n        this.attrsCbs.push(cb);\n        if (this.attrs) {\n            cb(this.attrs);\n        }\n        return () => {\n            this.attrsCbs = this.attrsCbs.filter((x) => x !== cb);\n        };\n    }\n    notifyAuthSubs(user) {\n        this.authCbs.forEach((cb) => cb(user));\n    }\n    notifyMutationErrorSubs(error) {\n        this.mutationErrorCbs.forEach((cb) => cb(error));\n    }\n    notifyAttrsSubs() {\n        if (!this.attrs)\n            return;\n        const oas = this.optimisticAttrs();\n        this.attrsCbs.forEach((cb) => cb(oas));\n    }\n    notifyConnectionStatusSubs(status) {\n        this.connectionStatusCbs.forEach((cb) => cb(status));\n    }\n    setCurrentUser(user) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._persister.setItem(currentUserKey, JSON.stringify(user));\n        });\n    }\n    getCurrentUserCached() {\n        return this._currentUserCached;\n    }\n    getCurrentUser() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const oauthResp = yield this._waitForOAuthCallbackResponse();\n            if (oauthResp === null || oauthResp === void 0 ? void 0 : oauthResp.error) {\n                const errorV = { error: oauthResp.error, user: undefined };\n                this._currentUserCached = Object.assign({ isLoading: false }, errorV);\n                return errorV;\n            }\n            const user = yield this._persister.getItem(currentUserKey);\n            const userV = { user: JSON.parse(user), error: undefined };\n            this._currentUserCached = Object.assign({ isLoading: false }, userV);\n            return userV;\n        });\n    }\n    _hasCurrentUser() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const user = yield this._persister.getItem(currentUserKey);\n            return JSON.parse(user) != null;\n        });\n    }\n    changeCurrentUser(newUser) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const { user: oldUser } = yield this.getCurrentUser();\n            if ((0, object_1.areObjectsDeepEqual)(oldUser, newUser)) {\n                // We were already logged in as the newUser, don't\n                // bother updating\n                return;\n            }\n            yield this.setCurrentUser(newUser);\n            // We need to remove all `result` from querySubs,\n            // as they are no longer valid for the new user\n            this.updateUser(newUser);\n            try {\n                (_a = this._broadcastChannel) === null || _a === void 0 ? void 0 : _a.postMessage({ type: 'auth' });\n            }\n            catch (error) {\n                console.error('Error posting message to broadcast channel', error);\n            }\n        });\n    }\n    updateUser(newUser) {\n        const newV = { error: undefined, user: newUser };\n        this._currentUserCached = Object.assign({ isLoading: false }, newV);\n        this._dataForQueryCache = {};\n        this.querySubs.set((prev) => {\n            Object.keys(prev).forEach((k) => {\n                delete prev[k].result;\n            });\n            return prev;\n        });\n        this._reconnectTimeoutMs = 0;\n        this._ws.close();\n        this._oauthCallbackResponse = null;\n        this.notifyAuthSubs(newV);\n    }\n    sendMagicCode({ email }) {\n        return authAPI.sendMagicCode({\n            apiURI: this.config.apiURI,\n            appId: this.config.appId,\n            email: email,\n        });\n    }\n    signInWithMagicCode(_a) {\n        return __awaiter(this, arguments, void 0, function* ({ email, code }) {\n            const res = yield authAPI.verifyMagicCode({\n                apiURI: this.config.apiURI,\n                appId: this.config.appId,\n                email,\n                code,\n            });\n            yield this.changeCurrentUser(res.user);\n            return res;\n        });\n    }\n    signInWithCustomToken(authToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const res = yield authAPI.verifyRefreshToken({\n                apiURI: this.config.apiURI,\n                appId: this.config.appId,\n                refreshToken: authToken,\n            });\n            yield this.changeCurrentUser(res.user);\n            return res;\n        });\n    }\n    signOut() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const currentUser = yield this.getCurrentUser();\n            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;\n            if (refreshToken) {\n                try {\n                    yield authAPI.signOut({\n                        apiURI: this.config.apiURI,\n                        appId: this.config.appId,\n                        refreshToken,\n                    });\n                }\n                catch (e) { }\n            }\n            yield this.changeCurrentUser(null);\n        });\n    }\n    /**\n     * Creates an OAuth authorization URL.\n     * @param {Object} params - The parameters to create the authorization URL.\n     * @param {string} params.clientName - The name of the client requesting authorization.\n     * @param {string} params.redirectURL - The URL to redirect users to after authorization.\n     * @returns {string} The created authorization URL.\n     */\n    createAuthorizationURL({ clientName, redirectURL }) {\n        const { apiURI, appId } = this.config;\n        return `${apiURI}/runtime/oauth/start?app_id=${appId}&client_name=${clientName}&redirect_uri=${redirectURL}`;\n    }\n    /**\n     * @param {Object} params\n     * @param {string} params.code - The code received from the OAuth service.\n     * @param {string} [params.codeVerifier] - The code verifier used to generate the code challenge.\n     */\n    exchangeCodeForToken(_a) {\n        return __awaiter(this, arguments, void 0, function* ({ code, codeVerifier }) {\n            const res = yield authAPI.exchangeCodeForToken({\n                apiURI: this.config.apiURI,\n                appId: this.config.appId,\n                code: code,\n                codeVerifier,\n            });\n            yield this.changeCurrentUser(res.user);\n            return res;\n        });\n    }\n    issuerURI() {\n        const { apiURI, appId } = this.config;\n        return `${apiURI}/runtime/${appId}`;\n    }\n    /**\n     * @param {Object} params\n     * @param {string} params.clientName - The name of the client requesting authorization.\n     * @param {string} params.idToken - The id_token from the external service\n     * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service\n     */\n    signInWithIdToken(_a) {\n        return __awaiter(this, arguments, void 0, function* ({ idToken, clientName, nonce }) {\n            var _b;\n            const currentUser = yield this.getCurrentUser();\n            const refreshToken = (_b = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _b === void 0 ? void 0 : _b.refresh_token;\n            const res = yield authAPI.signInWithIdToken({\n                apiURI: this.config.apiURI,\n                appId: this.config.appId,\n                idToken,\n                clientName,\n                nonce,\n                refreshToken,\n            });\n            yield this.changeCurrentUser(res.user);\n            return res;\n        });\n    }\n    // --------\n    // Rooms\n    joinRoom(roomId) {\n        if (!this._rooms[roomId]) {\n            this._rooms[roomId] = {\n                isConnected: false,\n                error: undefined,\n            };\n        }\n        this._presence[roomId] = this._presence[roomId] || {};\n        this._tryJoinRoom(roomId);\n        return () => {\n            this._cleanupRoom(roomId);\n        };\n    }\n    _cleanupRoom(roomId) {\n        var _a, _b, _c, _d;\n        if (!((_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.length) &&\n            !Object.keys((_c = this._broadcastSubs[roomId]) !== null && _c !== void 0 ? _c : {}).length) {\n            const isConnected = (_d = this._rooms[roomId]) === null || _d === void 0 ? void 0 : _d.isConnected;\n            delete this._rooms[roomId];\n            delete this._presence[roomId];\n            delete this._broadcastSubs[roomId];\n            if (isConnected) {\n                this._tryLeaveRoom(roomId);\n            }\n            else {\n                this._roomsPendingLeave[roomId] = true;\n            }\n        }\n    }\n    // --------\n    // Presence\n    // TODO: look into typing again\n    getPresence(roomType, roomId, opts = {}) {\n        const room = this._rooms[roomId];\n        const presence = this._presence[roomId];\n        if (!room || !presence || !presence.result)\n            return null;\n        return Object.assign(Object.assign({}, (0, presence_1.buildPresenceSlice)(presence.result, opts, this._sessionId)), { isLoading: !room.isConnected, error: room.error });\n    }\n    // TODO: look into typing again\n    publishPresence(roomType, roomId, partialData) {\n        const room = this._rooms[roomId];\n        const presence = this._presence[roomId];\n        if (!room || !presence) {\n            return;\n        }\n        presence.result = presence.result || {};\n        const data = Object.assign(Object.assign({}, presence.result.user), partialData);\n        presence.result.user = data;\n        if (!room.isConnected) {\n            return;\n        }\n        this._trySetPresence(roomId, data);\n        this._notifyPresenceSubs(roomId);\n    }\n    _trySetPresence(roomId, data) {\n        this._trySendAuthed((0, uuid_1.default)(), {\n            op: 'set-presence',\n            'room-id': roomId,\n            data,\n        });\n    }\n    _tryJoinRoom(roomId) {\n        this._trySendAuthed((0, uuid_1.default)(), { op: 'join-room', 'room-id': roomId });\n        delete this._roomsPendingLeave[roomId];\n    }\n    _tryLeaveRoom(roomId) {\n        this._trySendAuthed((0, uuid_1.default)(), { op: 'leave-room', 'room-id': roomId });\n    }\n    // TODO: look into typing again\n    subscribePresence(roomType, roomId, opts, cb) {\n        const leaveRoom = this.joinRoom(roomId);\n        const handler = Object.assign(Object.assign({}, opts), { roomId, cb, prev: null });\n        this._presence[roomId] = this._presence[roomId] || {};\n        this._presence[roomId].handlers = this._presence[roomId].handlers || [];\n        this._presence[roomId].handlers.push(handler);\n        this._notifyPresenceSub(roomId, handler);\n        return () => {\n            var _a, _b, _c;\n            this._presence[roomId].handlers =\n                (_c = (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.filter((x) => x !== handler)) !== null && _c !== void 0 ? _c : [];\n            leaveRoom();\n        };\n    }\n    _notifyPresenceSubs(roomId) {\n        var _a, _b;\n        (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.forEach((handler) => {\n            this._notifyPresenceSub(roomId, handler);\n        });\n    }\n    _notifyPresenceSub(roomId, handler) {\n        const slice = this.getPresence('', roomId, handler);\n        if (!slice) {\n            return;\n        }\n        if (handler.prev && !(0, presence_1.hasPresenceResponseChanged)(slice, handler.prev)) {\n            return;\n        }\n        handler.prev = slice;\n        handler.cb(slice);\n    }\n    _patchPresencePeers(roomId, edits) {\n        var _a, _b, _c, _d;\n        const peers = ((_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b.peers) || {};\n        let sessions = Object.fromEntries(Object.entries(peers).map(([k, v]) => [k, { data: v }]));\n        sessions[this._sessionId] = { data: (_d = (_c = this._presence[roomId]) === null || _c === void 0 ? void 0 : _c.result) === null || _d === void 0 ? void 0 : _d.user };\n        for (let [path, op, value] of edits) {\n            if (op === '+' || op === 'r') {\n                sessions = (0, object_1.assocIn)(sessions, path, value);\n            }\n            if (op === '-') {\n                sessions = (0, object_1.dissocIn)(sessions, path);\n            }\n        }\n        this._setPresencePeers(roomId, sessions);\n    }\n    _setPresencePeers(roomId, data) {\n        const sessions = Object.assign({}, data);\n        // no need to keep track of `user`\n        delete sessions[this._sessionId];\n        const peers = Object.fromEntries(Object.entries(sessions).map(([k, v]) => [k, v.data]));\n        this._presence = (0, object_1.assocIn)(this._presence, [roomId, 'result', 'peers'], peers);\n    }\n    // --------\n    // Broadcast\n    publishTopic({ roomType, roomId, topic, data }) {\n        var _a;\n        const room = this._rooms[roomId];\n        if (!room) {\n            return;\n        }\n        if (!room.isConnected) {\n            this._broadcastQueue[roomId] = (_a = this._broadcastQueue[roomId]) !== null && _a !== void 0 ? _a : [];\n            this._broadcastQueue[roomId].push({ topic, roomType, data });\n            return;\n        }\n        this._tryBroadcast(roomId, roomType, topic, data);\n    }\n    _tryBroadcast(roomId, roomType, topic, data) {\n        this._trySendAuthed((0, uuid_1.default)(), {\n            op: 'client-broadcast',\n            'room-id': roomId,\n            roomType,\n            topic,\n            data,\n        });\n    }\n    subscribeTopic(roomId, topic, cb) {\n        const leaveRoom = this.joinRoom(roomId);\n        this._broadcastSubs[roomId] = this._broadcastSubs[roomId] || {};\n        this._broadcastSubs[roomId][topic] =\n            this._broadcastSubs[roomId][topic] || [];\n        this._broadcastSubs[roomId][topic].push(cb);\n        this._presence[roomId] = this._presence[roomId] || {};\n        return () => {\n            this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic].filter((x) => x !== cb);\n            if (!this._broadcastSubs[roomId][topic].length) {\n                delete this._broadcastSubs[roomId][topic];\n            }\n            leaveRoom();\n        };\n    }\n    _notifyBroadcastSubs(room, topic, msg) {\n        var _a, _b, _c;\n        (_c = (_b = (_a = this._broadcastSubs) === null || _a === void 0 ? void 0 : _a[room]) === null || _b === void 0 ? void 0 : _b[topic]) === null || _c === void 0 ? void 0 : _c.forEach((cb) => {\n            var _a, _b, _c, _d, _e, _f;\n            const data = (_a = msg.data) === null || _a === void 0 ? void 0 : _a.data;\n            const peer = msg.data['peer-id'] === this._sessionId\n                ? (_c = (_b = this._presence[room]) === null || _b === void 0 ? void 0 : _b.result) === null || _c === void 0 ? void 0 : _c.user\n                : (_f = (_e = (_d = this._presence[room]) === null || _d === void 0 ? void 0 : _d.result) === null || _e === void 0 ? void 0 : _e.peers) === null || _f === void 0 ? void 0 : _f[msg.data['peer-id']];\n            return cb(data, peer);\n        });\n    }\n    // --------\n    // Storage\n    uploadFile(path, file, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const currentUser = yield this.getCurrentUser();\n            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;\n            return StorageApi.uploadFile(Object.assign(Object.assign({}, opts), { apiURI: this.config.apiURI, appId: this.config.appId, path: path, file, refreshToken: refreshToken }));\n        });\n    }\n    deleteFile(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const currentUser = yield this.getCurrentUser();\n            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;\n            const result = yield StorageApi.deleteFile({\n                apiURI: this.config.apiURI,\n                appId: this.config.appId,\n                path,\n                refreshToken: refreshToken,\n            });\n            return result;\n        });\n    }\n    // Deprecated Storage API (Jan 2025)\n    // ---------------------------------\n    upload(path, file) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const currentUser = yield this.getCurrentUser();\n            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;\n            const fileName = path || file.name;\n            const url = yield StorageApi.getSignedUploadUrl({\n                apiURI: this.config.apiURI,\n                appId: this.config.appId,\n                fileName: fileName,\n                refreshToken: refreshToken,\n            });\n            const isSuccess = yield StorageApi.upload(url, file);\n            return isSuccess;\n        });\n    }\n    getDownloadUrl(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const currentUser = yield this.getCurrentUser();\n            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;\n            const url = yield StorageApi.getDownloadUrl({\n                apiURI: this.config.apiURI,\n                appId: this.config.appId,\n                path: path,\n                refreshToken: refreshToken,\n            });\n            return url;\n        });\n    }\n}\nexports.default = Reactor;\n//# sourceMappingURL=Reactor.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$instantdb$core$dist$presence","~$module$node_modules$$instantdb$core$dist$store","~$module$node_modules$$instantdb$core$dist$utils$PersistedObject","~$module$node_modules$$instantdb$core$dist$StorageAPI","~$module$node_modules$$instantdb$core$dist$utils$log","~$module$node_modules$$instantdb$core$dist$instaql","~$module$node_modules$$instantdb$core$dist$utils$Deferred","~$shadow.js","~$module$node_modules$$instantdb$core$dist$utils$object","~$module$node_modules$$instantdb$core$dist$version","~$module$node_modules$$instantdb$core$dist$utils$uuid","~$module$node_modules$$instantdb$core$dist$model$instaqlResult","~$module$node_modules$$instantdb$core$dist$utils$weakHash","~$module$node_modules$$instantdb$core$dist$WindowNetworkListener","~$module$node_modules$$instantdb$core$dist$utils$linkIndex","~$module$node_modules$$instantdb$core$dist$IndexedDBStorage","~$module$node_modules$$instantdb$core$dist$authAPI","~$module$node_modules$$instantdb$core$dist$instaml"]],"~:properties",["^5",["message","roomType","refSwapAttrIds","hint","notifyOneQueryOnce","attrs","onerror","versions","onclose","_ws","_errorMessage","mutationDeferredStore","cb","_wsOnMessage","config","_broadcastSubs","_broadcastChannel","_onMergeQuerySubs","q","_roomsPendingLeave","handlers","_beforeUnloadCbs","hash","_beforeUnload","user","__esModule","querySubVersion","path","_isOnline","codeVerifier","_persister","schema","pageInfo","isConnected","error","notifyOne","queryCbs","email","apiURI","refreshToken","notifyQueryError","queryOnceDfds","_rooms","value","aggregate","enumerable","websocketURI","status","isLoading","prev","mutationErrorCbs","querySubs","fileName","_onMergePendingMutations","getPreviousResult","clientId","_isShutdown","clientName","_wsOnClose","pendingMutations","type","appId","_sessionId","onopen","attrsCbs","_id","_linkIndex","_localIdPromises","_oauthCallbackResponse","_dataForQueryCache","file","nonce","roomId","_reconnectTimeoutId","op","authCbs","_wsOnOpen","attrIdMap","_reconnectTimeoutMs","pushTx","_presence","_currentUserCached","_broadcastQueue","connectionStatusCbs","data","pendingMutationsVersion","get","_wsOnError","dfd","pushOps","default","store","idToken","code","onmessage","eventId","result","topic"]],"~:compiled-at",1756239699995,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$instantdb$core$dist$Reactor.js\",\n\"lineCount\":940,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@instantdb/core/dist/Reactor.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$instantdb$core$dist$Reactor\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\\n    if (k2 === undefined) k2 = k;\\n    var desc = Object.getOwnPropertyDescriptor(m, k);\\n    if (!desc || (\\\"get\\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\\n      desc = { enumerable: true, get: function() { return m[k]; } };\\n    }\\n    Object.defineProperty(o, k2, desc);\\n}) : (function(o, m, k, k2) {\\n    if (k2 === undefined) k2 = k;\\n    o[k2] = m[k];\\n}));\\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\\n    Object.defineProperty(o, \\\"default\\\", { enumerable: true, value: v });\\n}) : function(o, v) {\\n    o[\\\"default\\\"] = v;\\n});\\nvar __importStar = (this && this.__importStar) || function (mod) {\\n    if (mod && mod.__esModule) return mod;\\n    var result = {};\\n    if (mod != null) for (var k in mod) if (k !== \\\"default\\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\\n    __setModuleDefault(result, mod);\\n    return result;\\n};\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nvar __importDefault = (this && this.__importDefault) || function (mod) {\\n    return (mod && mod.__esModule) ? mod : { \\\"default\\\": mod };\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\n// @ts-check\\nconst log_1 = __importDefault(require(\\\"./utils/log\\\"));\\nconst weakHash_1 = __importDefault(require(\\\"./utils/weakHash\\\"));\\nconst instaql_1 = __importDefault(require(\\\"./instaql\\\"));\\nconst instaml = __importStar(require(\\\"./instaml\\\"));\\nconst s = __importStar(require(\\\"./store\\\"));\\nconst uuid_1 = __importDefault(require(\\\"./utils/uuid\\\"));\\nconst IndexedDBStorage_1 = __importDefault(require(\\\"./IndexedDBStorage\\\"));\\nconst WindowNetworkListener_1 = __importDefault(require(\\\"./WindowNetworkListener\\\"));\\nconst authAPI = __importStar(require(\\\"./authAPI\\\"));\\nconst StorageApi = __importStar(require(\\\"./StorageAPI\\\"));\\nconst presence_1 = require(\\\"./presence\\\");\\nconst Deferred_1 = require(\\\"./utils/Deferred\\\");\\nconst PersistedObject_1 = require(\\\"./utils/PersistedObject\\\");\\nconst instaqlResult_1 = require(\\\"./model/instaqlResult\\\");\\nconst object_1 = require(\\\"./utils/object\\\");\\nconst linkIndex_1 = require(\\\"./utils/linkIndex\\\");\\nconst version_1 = __importDefault(require(\\\"./version\\\"));\\nconst STATUS = {\\n    CONNECTING: 'connecting',\\n    OPENED: 'opened',\\n    AUTHENTICATED: 'authenticated',\\n    CLOSED: 'closed',\\n    ERRORED: 'errored',\\n};\\nconst QUERY_ONCE_TIMEOUT = 30000;\\nconst WS_CONNECTING_STATUS = 0;\\nconst WS_OPEN_STATUS = 1;\\nconst defaultConfig = {\\n    apiURI: 'https://api.instantdb.com',\\n    websocketURI: 'wss://api.instantdb.com/runtime/session',\\n};\\n// Param that the backend adds if this is an oauth redirect\\nconst OAUTH_REDIRECT_PARAM = '_instant_oauth_redirect';\\nconst currentUserKey = `currentUser`;\\nlet _wsId = 0;\\nfunction createWebSocket(uri) {\\n    const ws = new WebSocket(uri);\\n    // @ts-ignore\\n    ws._id = _wsId++;\\n    return ws;\\n}\\nfunction isClient() {\\n    const hasWindow = typeof window !== 'undefined';\\n    // this checks if we are running in a chrome extension\\n    // @ts-expect-error\\n    const isChrome = typeof chrome !== 'undefined';\\n    return hasWindow || isChrome;\\n}\\nconst ignoreLogging = {\\n    'set-presence': true,\\n    'set-presence-ok': true,\\n    'refresh-presence': true,\\n    'patch-presence': true,\\n};\\nfunction querySubsFromJSON(str) {\\n    var _a;\\n    const parsed = JSON.parse(str);\\n    for (const key in parsed) {\\n        const v = parsed[key];\\n        if ((_a = v === null || v === void 0 ? void 0 : v.result) === null || _a === void 0 ? void 0 : _a.store) {\\n            v.result.store = s.fromJSON(v.result.store);\\n        }\\n    }\\n    return parsed;\\n}\\nfunction querySubsToJSON(querySubs) {\\n    var _a;\\n    const jsonSubs = {};\\n    for (const key in querySubs) {\\n        const sub = querySubs[key];\\n        const jsonSub = Object.assign({}, sub);\\n        if ((_a = sub.result) === null || _a === void 0 ? void 0 : _a.store) {\\n            jsonSub.result = Object.assign(Object.assign({}, sub.result), { store: s.toJSON(sub.result.store) });\\n        }\\n        jsonSubs[key] = jsonSub;\\n    }\\n    return JSON.stringify(jsonSubs);\\n}\\n/**\\n * @template {import('./presence').RoomSchemaShape} [RoomSchema = {}]\\n */\\nclass Reactor {\\n    constructor(config, Storage = IndexedDBStorage_1.default, NetworkListener = WindowNetworkListener_1.default, versions) {\\n        this._isOnline = true;\\n        this._isShutdown = false;\\n        this.status = STATUS.CONNECTING;\\n        /** @type {Record<string, Array<{ q: any, cb: (data: any) => any }>>} */\\n        this.queryCbs = {};\\n        /** @type {Record<string, Array<{ q: any, eventId: string, dfd: Deferred }>>} */\\n        this.queryOnceDfds = {};\\n        this.authCbs = [];\\n        this.attrsCbs = [];\\n        this.mutationErrorCbs = [];\\n        this.connectionStatusCbs = [];\\n        this.mutationDeferredStore = new Map();\\n        this._reconnectTimeoutId = null;\\n        this._reconnectTimeoutMs = 0;\\n        this._localIdPromises = {};\\n        this._errorMessage = null;\\n        /** @type {Promise<null | {error: {message: string}}>}**/\\n        this._oauthCallbackResponse = null;\\n        /** @type {null | import('./utils/linkIndex').LinkIndex}} */\\n        this._linkIndex = null;\\n        /** @type {Record<string, {isConnected: boolean; error: any}>} */\\n        this._rooms = {};\\n        /** @type {Record<string, boolean>} */\\n        this._roomsPendingLeave = {};\\n        this._presence = {};\\n        this._broadcastQueue = [];\\n        this._broadcastSubs = {};\\n        this._currentUserCached = { isLoading: true, error: undefined, user: undefined };\\n        this._beforeUnloadCbs = [];\\n        this._dataForQueryCache = {};\\n        /**\\n         *  merge querySubs from storage and in memory. Has the following side\\n         *  effects:\\n         *  - We notify all queryCbs because results may been added during merge\\n         */\\n        this._onMergeQuerySubs = (_storageSubs, inMemorySubs) => {\\n            const storageSubs = _storageSubs || {};\\n            const ret = Object.assign({}, inMemorySubs);\\n            // Consider an inMemorySub with no result;\\n            // If we have a result from storageSubs, let's add it\\n            Object.entries(inMemorySubs).forEach(([hash, querySub]) => {\\n                var _a;\\n                const storageResult = (_a = storageSubs === null || storageSubs === void 0 ? void 0 : storageSubs[hash]) === null || _a === void 0 ? void 0 : _a.result;\\n                const memoryResult = querySub.result;\\n                if (storageResult && !memoryResult) {\\n                    ret[hash].result = storageResult;\\n                }\\n            });\\n            // Consider a storageSub with no corresponding inMemorySub\\n            // This means that at least at this point,\\n            // the user has not asked to subscribe to the query.\\n            // We may _still_ want to add it, because in just a\\n            // few milliseconds, the user will ask to subscribe to the\\n            // query.\\n            // For now, we can't really tell if the user will ask to subscribe\\n            // or not. So for now let's just add the first 10 queries from storage.\\n            // Eventually, we could be smarter about this. For example,\\n            // we can keep usage information about which queries are popular.\\n            const storageKsToAdd = Object.keys(storageSubs)\\n                .filter((k) => !inMemorySubs[k])\\n                .slice(0, 10);\\n            storageKsToAdd.forEach((k) => {\\n                ret[k] = storageSubs[k];\\n            });\\n            // Okay, now we have merged our querySubs\\n            this.querySubs.set((_) => ret);\\n            this.loadedNotifyAll();\\n        };\\n        /**\\n         * merge pendingMutations from storage and in memory. Has a side effect of\\n         * sending mutations that were stored but not acked\\n         */\\n        this._onMergePendingMutations = (storageMuts, inMemoryMuts) => {\\n            const ret = new Map([...storageMuts.entries(), ...inMemoryMuts.entries()]);\\n            this.pendingMutations.set((_) => ret);\\n            this.loadedNotifyAll();\\n            const rewrittenStorageMuts = this._rewriteMutations(this.attrs, storageMuts);\\n            rewrittenStorageMuts.forEach((mut, k) => {\\n                if (!inMemoryMuts.has(k) && !mut['tx-id']) {\\n                    this._sendMutation(k, mut);\\n                }\\n            });\\n        };\\n        // ---------------------------\\n        // Queries\\n        this.getPreviousResult = (q) => {\\n            const hash = (0, weakHash_1.default)(q);\\n            return this.dataForQuery(hash);\\n        };\\n        /** Re-run instaql and call all callbacks with new data */\\n        this.notifyOne = (hash) => {\\n            var _a, _b;\\n            const cbs = (_a = this.queryCbs[hash]) !== null && _a !== void 0 ? _a : [];\\n            const prevData = (_b = this._dataForQueryCache[hash]) === null || _b === void 0 ? void 0 : _b.data;\\n            const data = this.dataForQuery(hash);\\n            if (!data)\\n                return;\\n            if ((0, object_1.areObjectsDeepEqual)(data, prevData))\\n                return;\\n            cbs.forEach((r) => r.cb(data));\\n        };\\n        this.notifyOneQueryOnce = (hash) => {\\n            var _a;\\n            const dfds = (_a = this.queryOnceDfds[hash]) !== null && _a !== void 0 ? _a : [];\\n            const data = this.dataForQuery(hash);\\n            dfds.forEach((r) => {\\n                this._completeQueryOnce(r.q, hash, r.dfd);\\n                r.dfd.resolve(data);\\n            });\\n        };\\n        this.notifyQueryError = (hash, error) => {\\n            const cbs = this.queryCbs[hash] || [];\\n            cbs.forEach((r) => r.cb({ error }));\\n        };\\n        /** Applies transactions locally and sends transact message to server */\\n        this.pushTx = (chunks) => {\\n            try {\\n                const txSteps = instaml.transform({ attrs: this.optimisticAttrs(), schema: this.config.schema }, chunks);\\n                return this.pushOps(txSteps);\\n            }\\n            catch (e) {\\n                return this.pushOps([], e);\\n            }\\n        };\\n        /**\\n         * @param {*} txSteps\\n         * @param {*} [error]\\n         * @returns\\n         */\\n        this.pushOps = (txSteps, error) => {\\n            const eventId = (0, uuid_1.default)();\\n            const mutation = {\\n                op: 'transact',\\n                'tx-steps': txSteps,\\n                error,\\n            };\\n            this.pendingMutations.set((prev) => {\\n                prev.set(eventId, mutation);\\n                return prev;\\n            });\\n            const dfd = new Deferred_1.Deferred();\\n            this.mutationDeferredStore.set(eventId, dfd);\\n            this._sendMutation(eventId, mutation);\\n            this.notifyAll();\\n            return dfd.promise;\\n        };\\n        this._wsOnOpen = (e) => {\\n            const targetWs = e.target;\\n            if (this._ws !== targetWs) {\\n                log_1.default.info('[socket][open]', targetWs._id, 'skip; this is no longer the current ws');\\n                return;\\n            }\\n            log_1.default.info('[socket][open]', this._ws._id);\\n            this._setStatus(STATUS.OPENED);\\n            this.getCurrentUser().then((resp) => {\\n                var _a;\\n                this._trySend((0, uuid_1.default)(), {\\n                    op: 'init',\\n                    'app-id': this.config.appId,\\n                    'refresh-token': (_a = resp.user) === null || _a === void 0 ? void 0 : _a['refresh_token'],\\n                    versions: this.versions,\\n                    // If an admin token is provided for an app, we will\\n                    // skip all permission checks. This is an advanced feature,\\n                    // to let users write internal tools\\n                    // This option is not exposed in `Config`, as it's\\n                    // not ready for prime time\\n                    '__admin-token': this.config.__adminToken,\\n                });\\n            });\\n        };\\n        this._wsOnMessage = (e) => {\\n            const targetWs = e.target;\\n            const m = JSON.parse(e.data.toString());\\n            if (this._ws !== targetWs) {\\n                log_1.default.info('[socket][message]', targetWs._id, m, 'skip; this is no longer the current ws');\\n                return;\\n            }\\n            this._handleReceive(targetWs._id, JSON.parse(e.data.toString()));\\n        };\\n        this._wsOnError = (e) => {\\n            const targetWs = e.target;\\n            if (this._ws !== targetWs) {\\n                log_1.default.info('[socket][error]', targetWs._id, 'skip; this is no longer the current ws');\\n                return;\\n            }\\n            log_1.default.error('[socket][error]', targetWs._id, e);\\n        };\\n        this._wsOnClose = (e) => {\\n            const targetWs = e.target;\\n            if (this._ws !== targetWs) {\\n                log_1.default.info('[socket][close]', targetWs._id, 'skip; this is no longer the current ws');\\n                return;\\n            }\\n            this._setStatus(STATUS.CLOSED);\\n            for (const room of Object.values(this._rooms)) {\\n                room.isConnected = false;\\n            }\\n            if (this._isShutdown) {\\n                log_1.default.info('[socket][close]', targetWs._id, 'Reactor has been shut down and will not reconnect');\\n                return;\\n            }\\n            log_1.default.info('[socket][close]', targetWs._id, 'schedule reconnect, ms =', this._reconnectTimeoutMs);\\n            setTimeout(() => {\\n                this._reconnectTimeoutMs = Math.min(this._reconnectTimeoutMs + 1000, 10000);\\n                if (!this._isOnline) {\\n                    log_1.default.info('[socket][close]', targetWs._id, 'we are offline, no need to start socket');\\n                    return;\\n                }\\n                this._startSocket();\\n            }, this._reconnectTimeoutMs);\\n        };\\n        this.config = Object.assign(Object.assign({}, defaultConfig), config);\\n        this.versions = Object.assign(Object.assign({}, (versions || {})), { '@instantdb/core': version_1.default });\\n        if (this.config.schema) {\\n            this._linkIndex = (0, linkIndex_1.createLinkIndex)(this.config.schema);\\n        }\\n        // This is to protect us against running\\n        // server-side.\\n        if (!isClient()) {\\n            return;\\n        }\\n        if (typeof BroadcastChannel === 'function') {\\n            this._broadcastChannel = new BroadcastChannel('@instantdb');\\n            this._broadcastChannel.addEventListener('message', (e) => __awaiter(this, void 0, void 0, function* () {\\n                var _a;\\n                if (((_a = e.data) === null || _a === void 0 ? void 0 : _a.type) === 'auth') {\\n                    const res = yield this.getCurrentUser();\\n                    this.updateUser(res.user);\\n                }\\n            }));\\n        }\\n        this._oauthCallbackResponse = this._oauthLoginInit();\\n        this._initStorage(Storage);\\n        // kick off a request to cache it\\n        this.getCurrentUser();\\n        NetworkListener.getIsOnline().then((isOnline) => {\\n            this._isOnline = isOnline;\\n            this._startSocket();\\n            NetworkListener.listen((isOnline) => {\\n                // We do this because react native's NetInfo\\n                // fires multiple online events.\\n                // We only want to handle one state change\\n                if (isOnline === this._isOnline) {\\n                    return;\\n                }\\n                log_1.default.info('[network] online =', isOnline);\\n                this._isOnline = isOnline;\\n                if (this._isOnline) {\\n                    this._startSocket();\\n                }\\n                else {\\n                    log_1.default.info('Changing status from', this.status, 'to', STATUS.CLOSED);\\n                    this._setStatus(STATUS.CLOSED);\\n                }\\n            });\\n        });\\n        if (typeof addEventListener !== 'undefined') {\\n            this._beforeUnload = this._beforeUnload.bind(this);\\n            addEventListener('beforeunload', this._beforeUnload);\\n        }\\n    }\\n    _initStorage(Storage) {\\n        this._persister = new Storage(`instant_${this.config.appId}_5`);\\n        this.querySubs = new PersistedObject_1.PersistedObject(this._persister, 'querySubs', {}, this._onMergeQuerySubs, querySubsToJSON, querySubsFromJSON);\\n        this.pendingMutations = new PersistedObject_1.PersistedObject(this._persister, 'pendingMutations', new Map(), this._onMergePendingMutations, (x) => {\\n            return JSON.stringify([...x.entries()]);\\n        }, (x) => {\\n            return new Map(JSON.parse(x));\\n        });\\n        this._beforeUnloadCbs.push(() => {\\n            this.pendingMutations.flush();\\n            this.querySubs.flush();\\n        });\\n    }\\n    _beforeUnload() {\\n        for (const cb of this._beforeUnloadCbs) {\\n            cb();\\n        }\\n    }\\n    /**\\n     * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status\\n     * @param string clientId\\n     * @param {{message?: string, hint?: string, error?: Error}} [errDetails]\\n     */\\n    _finishTransaction(status, clientId, errDetails) {\\n        const dfd = this.mutationDeferredStore.get(clientId);\\n        this.mutationDeferredStore.delete(clientId);\\n        const ok = status !== 'error' && status !== 'timeout';\\n        if (!dfd && !ok) {\\n            // console.erroring here, as there are no listeners to let know\\n            console.error('Mutation failed', Object.assign({ status, clientId }, errDetails));\\n        }\\n        if (!dfd) {\\n            return;\\n        }\\n        if (ok) {\\n            dfd.resolve({ status, clientId });\\n        }\\n        else {\\n            dfd.reject(Object.assign({ status, clientId }, errDetails));\\n        }\\n    }\\n    _setStatus(status, err) {\\n        this.status = status;\\n        this._errorMessage = err;\\n        this.notifyConnectionStatusSubs(status);\\n    }\\n    _flushEnqueuedRoomData(roomId) {\\n        var _a, _b;\\n        const enqueuedUserPresence = (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b.user;\\n        const enqueuedBroadcasts = this._broadcastQueue[roomId];\\n        this._broadcastQueue[roomId] = [];\\n        if (enqueuedUserPresence) {\\n            this._trySetPresence(roomId, enqueuedUserPresence);\\n        }\\n        if (enqueuedBroadcasts) {\\n            for (const item of enqueuedBroadcasts) {\\n                const { topic, roomType, data } = item;\\n                this._tryBroadcast(roomId, roomType, topic, data);\\n            }\\n        }\\n    }\\n    _handleReceive(wsId, msg) {\\n        var _a, _b, _c, _d;\\n        // opt-out, enabled by default if schema\\n        const enableCardinalityInference = Boolean(this.config.schema) &&\\n            ('cardinalityInference' in this.config\\n                ? Boolean(this.config.cardinalityInference)\\n                : true);\\n        if (!ignoreLogging[msg.op]) {\\n            log_1.default.info('[receive]', wsId, msg.op, msg);\\n        }\\n        switch (msg.op) {\\n            case 'init-ok':\\n                this._setStatus(STATUS.AUTHENTICATED);\\n                this._reconnectTimeoutMs = 0;\\n                this._setAttrs(msg.attrs);\\n                this._flushPendingMessages();\\n                // (EPH): set session-id, so we know\\n                // which item is us\\n                this._sessionId = msg['session-id'];\\n                for (const roomId of Object.keys(this._rooms)) {\\n                    this._tryJoinRoom(roomId);\\n                }\\n                break;\\n            case 'add-query-exists':\\n                this.notifyOneQueryOnce((0, weakHash_1.default)(msg.q));\\n                break;\\n            case 'add-query-ok':\\n                const { q, result } = msg;\\n                const hash = (0, weakHash_1.default)(q);\\n                const pageInfo = (_b = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b['page-info'];\\n                const aggregate = (_d = (_c = result === null || result === void 0 ? void 0 : result[0]) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d['aggregate'];\\n                const triples = (0, instaqlResult_1.extractTriples)(result);\\n                const store = s.createStore(this.attrs, triples, enableCardinalityInference, this._linkIndex);\\n                this.querySubs.set((prev) => {\\n                    prev[hash].result = { store, pageInfo, aggregate };\\n                    return prev;\\n                });\\n                this.notifyOne(hash);\\n                this.notifyOneQueryOnce(hash);\\n                break;\\n            case 'refresh-ok':\\n                const { computations, attrs } = msg;\\n                this._setAttrs(attrs);\\n                const updates = computations.map((x) => {\\n                    var _a, _b, _c, _d;\\n                    const q = x['instaql-query'];\\n                    const result = x['instaql-result'];\\n                    const hash = (0, weakHash_1.default)(q);\\n                    const triples = (0, instaqlResult_1.extractTriples)(result);\\n                    const store = s.createStore(this.attrs, triples, enableCardinalityInference, this._linkIndex);\\n                    const pageInfo = (_b = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b['page-info'];\\n                    const aggregate = (_d = (_c = result === null || result === void 0 ? void 0 : result[0]) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d['aggregate'];\\n                    return { hash, store, pageInfo, aggregate };\\n                });\\n                updates.forEach(({ hash, store, pageInfo, aggregate }) => {\\n                    this.querySubs.set((prev) => {\\n                        prev[hash].result = { store, pageInfo, aggregate };\\n                        return prev;\\n                    });\\n                });\\n                updates.forEach(({ hash }) => {\\n                    this.notifyOne(hash);\\n                });\\n                break;\\n            case 'transact-ok':\\n                const { 'client-event-id': eventId, 'tx-id': txId } = msg;\\n                const muts = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue);\\n                const prevMutation = muts.get(eventId);\\n                if (!prevMutation) {\\n                    break;\\n                }\\n                // Now that this transaction is accepted,\\n                // We can delete it from our queue.\\n                this.pendingMutations.set((prev) => {\\n                    prev.delete(eventId);\\n                    return prev;\\n                });\\n                // We apply this transaction to all our existing queries\\n                const txStepsToApply = prevMutation['tx-steps'];\\n                this.querySubs.set((prev) => {\\n                    var _a;\\n                    for (const [hash, sub] of Object.entries(prev)) {\\n                        const store = (_a = sub === null || sub === void 0 ? void 0 : sub.result) === null || _a === void 0 ? void 0 : _a.store;\\n                        if (!store) {\\n                            continue;\\n                        }\\n                        const newStore = s.transact(store, txStepsToApply);\\n                        prev[hash].result.store = newStore;\\n                    }\\n                    return prev;\\n                });\\n                const newAttrs = prevMutation['tx-steps']\\n                    .filter(([action, ..._args]) => action === 'add-attr')\\n                    .map(([_action, attr]) => attr)\\n                    .concat(Object.values(this.attrs));\\n                this._setAttrs(newAttrs);\\n                this._finishTransaction('synced', eventId);\\n                break;\\n            case 'patch-presence': {\\n                const roomId = msg['room-id'];\\n                this._patchPresencePeers(roomId, msg['edits']);\\n                this._notifyPresenceSubs(roomId);\\n                break;\\n            }\\n            case 'refresh-presence': {\\n                const roomId = msg['room-id'];\\n                this._setPresencePeers(roomId, msg['data']);\\n                this._notifyPresenceSubs(roomId);\\n                break;\\n            }\\n            case 'server-broadcast':\\n                const room = msg['room-id'];\\n                const topic = msg.topic;\\n                this._notifyBroadcastSubs(room, topic, msg);\\n                break;\\n            case 'join-room-ok':\\n                const loadingRoomId = msg['room-id'];\\n                const joinedRoom = this._rooms[loadingRoomId];\\n                if (!joinedRoom) {\\n                    if (this._roomsPendingLeave[loadingRoomId]) {\\n                        this._tryLeaveRoom(loadingRoomId);\\n                        delete this._roomsPendingLeave[loadingRoomId];\\n                    }\\n                    break;\\n                }\\n                joinedRoom.isConnected = true;\\n                this._notifyPresenceSubs(loadingRoomId);\\n                this._flushEnqueuedRoomData(loadingRoomId);\\n                break;\\n            case 'join-room-error':\\n                const errorRoomId = msg['room-id'];\\n                const errorRoom = this._rooms[errorRoomId];\\n                if (errorRoom) {\\n                    errorRoom.error = msg['error'];\\n                }\\n                this._notifyPresenceSubs(errorRoomId);\\n                break;\\n            case 'error':\\n                this._handleReceiveError(msg);\\n                break;\\n            default:\\n                break;\\n        }\\n    }\\n    /**\\n     * @param {'timeout' | 'error'} status\\n     * @param {string} eventId\\n     * @param {{message?: string, hint?: string, error?: Error}} errDetails\\n     */\\n    _handleMutationError(status, eventId, errDetails) {\\n        const mut = this.pendingMutations.currentValue.get(eventId);\\n        if (mut && (status !== 'timeout' || !mut['tx-id'])) {\\n            this.pendingMutations.set((prev) => {\\n                prev.delete(eventId);\\n                return prev;\\n            });\\n            this.notifyAll();\\n            this.notifyAttrsSubs();\\n            this.notifyMutationErrorSubs(errDetails);\\n            this._finishTransaction(status, eventId, errDetails);\\n        }\\n    }\\n    _handleReceiveError(msg) {\\n        var _a, _b, _c, _d, _e;\\n        const eventId = msg['client-event-id'];\\n        const prevMutation = this.pendingMutations.currentValue.get(eventId);\\n        const errorMessage = {\\n            message: msg.message || 'Uh-oh, something went wrong. Ping Joe & Stopa.',\\n        };\\n        if (msg.hint) {\\n            errorMessage.hint = msg.hint;\\n        }\\n        if (prevMutation) {\\n            // This must be a transaction error\\n            const errDetails = {\\n                message: msg.message,\\n                hint: msg.hint,\\n            };\\n            this._handleMutationError('error', eventId, errDetails);\\n            return;\\n        }\\n        if (((_a = msg['original-event']) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('q')) &&\\n            ((_b = msg['original-event']) === null || _b === void 0 ? void 0 : _b.op) === 'add-query') {\\n            const q = (_c = msg['original-event']) === null || _c === void 0 ? void 0 : _c.q;\\n            const hash = (0, weakHash_1.default)(q);\\n            this.notifyQueryError((0, weakHash_1.default)(q), errorMessage);\\n            this.notifyQueryOnceError(q, hash, eventId, errorMessage);\\n            return;\\n        }\\n        const isInitError = ((_d = msg['original-event']) === null || _d === void 0 ? void 0 : _d.op) === 'init';\\n        if (isInitError) {\\n            if (msg.type === 'record-not-found' &&\\n                ((_e = msg.hint) === null || _e === void 0 ? void 0 : _e['record-type']) === 'app-user') {\\n                // User has been logged out\\n                this.changeCurrentUser(null);\\n                return;\\n            }\\n            // We failed to init\\n            this._setStatus(STATUS.ERRORED, errorMessage);\\n            this.notifyAll();\\n            return;\\n        }\\n        // We've caught some error which has no corresponding listener.\\n        // Let's console.error to let the user know.\\n        const errorObj = Object.assign({}, msg);\\n        delete errorObj.message;\\n        delete errorObj.hint;\\n        console.error(msg.message, errorObj);\\n        if (msg.hint) {\\n            console.error('This error comes with some debugging information. Here it is: \\\\n', msg.hint);\\n        }\\n    }\\n    notifyQueryOnceError(q, hash, eventId, e) {\\n        var _a;\\n        const r = (_a = this.queryOnceDfds[hash]) === null || _a === void 0 ? void 0 : _a.find((r) => r.eventId === eventId);\\n        if (!r)\\n            return;\\n        r.dfd.reject(e);\\n        this._completeQueryOnce(q, hash, r.dfd);\\n    }\\n    _setAttrs(attrs) {\\n        this.attrs = attrs.reduce((acc, attr) => {\\n            acc[attr.id] = attr;\\n            return acc;\\n        }, {});\\n        this.notifyAttrsSubs();\\n    }\\n    _startQuerySub(q, hash) {\\n        const eventId = (0, uuid_1.default)();\\n        this.querySubs.set((prev) => {\\n            prev[hash] = prev[hash] || { q, result: null, eventId };\\n            return prev;\\n        });\\n        this._trySendAuthed(eventId, { op: 'add-query', q });\\n        return eventId;\\n    }\\n    /**\\n     *  When a user subscribes to a query the following side effects occur:\\n     *\\n     *  - We update querySubs to include the new query\\n     *  - We update queryCbs to include the new cb\\n     *  - If we already have a result for the query we call cb immediately\\n     *  - We send the server an `add-query` message\\n     *\\n     *  Returns an unsubscribe function\\n     */\\n    subscribeQuery(q, cb) {\\n        var _a;\\n        const hash = (0, weakHash_1.default)(q);\\n        const prevResult = this.getPreviousResult(q);\\n        if (prevResult) {\\n            cb(prevResult);\\n        }\\n        this.queryCbs[hash] = (_a = this.queryCbs[hash]) !== null && _a !== void 0 ? _a : [];\\n        this.queryCbs[hash].push({ q, cb });\\n        this._startQuerySub(q, hash);\\n        return () => {\\n            this._unsubQuery(q, hash, cb);\\n        };\\n    }\\n    queryOnce(q) {\\n        var _a;\\n        const dfd = new Deferred_1.Deferred();\\n        if (!this._isOnline) {\\n            dfd.reject(new Error(\\\"We can't run `queryOnce`, because the device is offline.\\\"));\\n            return dfd.promise;\\n        }\\n        if (!this.querySubs) {\\n            dfd.reject(new Error(\\\"We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query\\\"));\\n            return dfd.promise;\\n        }\\n        const hash = (0, weakHash_1.default)(q);\\n        const eventId = this._startQuerySub(q, hash);\\n        this.queryOnceDfds[hash] = (_a = this.queryOnceDfds[hash]) !== null && _a !== void 0 ? _a : [];\\n        this.queryOnceDfds[hash].push({ q, dfd, eventId });\\n        setTimeout(() => dfd.reject(new Error('Query timed out')), QUERY_ONCE_TIMEOUT);\\n        return dfd.promise;\\n    }\\n    _completeQueryOnce(q, hash, dfd) {\\n        if (!this.queryOnceDfds[hash])\\n            return;\\n        this.queryOnceDfds[hash] = this.queryOnceDfds[hash].filter((r) => r.dfd !== dfd);\\n        this._cleanupQuery(q, hash);\\n    }\\n    _unsubQuery(q, hash, cb) {\\n        if (!this.queryCbs[hash])\\n            return;\\n        this.queryCbs[hash] = this.queryCbs[hash].filter((r) => r.cb !== cb);\\n        this._cleanupQuery(q, hash);\\n    }\\n    _cleanupQuery(q, hash) {\\n        var _a, _b;\\n        const hasListeners = ((_a = this.queryCbs[hash]) === null || _a === void 0 ? void 0 : _a.length) || ((_b = this.queryOnceDfds[hash]) === null || _b === void 0 ? void 0 : _b.length);\\n        if (hasListeners)\\n            return;\\n        delete this.queryCbs[hash];\\n        delete this.queryOnceDfds[hash];\\n        this._trySendAuthed((0, uuid_1.default)(), { op: 'remove-query', q });\\n    }\\n    // When we `pushTx`, it's possible that we don't yet have `this.attrs`\\n    // This means that `tx-steps` in `pendingMutations` will include `add-attr`\\n    // commands for attrs that already exist.\\n    //\\n    // This will also affect `add-triple` and `retract-triple` which\\n    // reference attr-ids that do not match the server.\\n    //\\n    // We fix this by rewriting `tx-steps` in each `pendingMutation`.\\n    // We remove `add-attr` commands for attrs that already exist.\\n    // We update `add-triple` and `retract-triple` commands to use the\\n    // server attr-ids.\\n    _rewriteMutations(attrs, muts) {\\n        if (!attrs)\\n            return muts;\\n        const findExistingAttr = (attr) => {\\n            const [_, etype, label] = attr['forward-identity'];\\n            const existing = instaml.getAttrByFwdIdentName(attrs, etype, label);\\n            return existing;\\n        };\\n        const findReverseAttr = (attr) => {\\n            const [_, etype, label] = attr['forward-identity'];\\n            const revAttr = instaml.getAttrByReverseIdentName(attrs, etype, label);\\n            return revAttr;\\n        };\\n        const mapping = { attrIdMap: {}, refSwapAttrIds: new Set() };\\n        const rewriteTxSteps = (txSteps) => {\\n            const retTxSteps = [];\\n            for (const txStep of txSteps) {\\n                const [action] = txStep;\\n                // Handles add-attr\\n                // If existing, we drop it, and track it\\n                // to update add/retract triples\\n                if (action === 'add-attr') {\\n                    const [_action, attr] = txStep;\\n                    const existing = findExistingAttr(attr);\\n                    if (existing) {\\n                        mapping.attrIdMap[attr.id] = existing.id;\\n                        continue;\\n                    }\\n                    if (attr['value-type'] === 'ref') {\\n                        const revAttr = findReverseAttr(attr);\\n                        if (revAttr) {\\n                            mapping.attrIdMap[attr.id] = revAttr.id;\\n                            mapping.refSwapAttrIds.add(attr.id);\\n                            continue;\\n                        }\\n                    }\\n                }\\n                // Handles add-triple|retract-triple\\n                // If in mapping, we update the attr-id\\n                const newTxStep = instaml.rewriteStep(mapping, txStep);\\n                retTxSteps.push(newTxStep);\\n            }\\n            return retTxSteps;\\n        };\\n        const rewritten = new Map();\\n        for (const [k, mut] of muts.entries()) {\\n            rewritten.set(k, Object.assign(Object.assign({}, mut), { 'tx-steps': rewriteTxSteps(mut['tx-steps']) }));\\n        }\\n        return rewritten;\\n    }\\n    // ---------------------------\\n    // Transact\\n    optimisticAttrs() {\\n        var _a;\\n        const pendingMutationSteps = [\\n            ...this.pendingMutations.currentValue.values(),\\n        ] // hack due to Map()\\n            .flatMap((x) => x['tx-steps']);\\n        const deletedAttrIds = new Set(pendingMutationSteps\\n            .filter(([action, _attr]) => action === 'delete-attr')\\n            .map(([_action, id]) => id));\\n        const pendingAttrs = [];\\n        for (const [_action, attr] of pendingMutationSteps) {\\n            if (_action === 'add-attr') {\\n                pendingAttrs.push(attr);\\n            }\\n            else if (_action === 'update-attr' &&\\n                attr.id &&\\n                ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a[attr.id])) {\\n                const fullAttr = Object.assign(Object.assign({}, this.attrs[attr.id]), attr);\\n                pendingAttrs.push(fullAttr);\\n            }\\n        }\\n        const attrsWithoutDeleted = [\\n            ...Object.values(this.attrs || {}),\\n            ...pendingAttrs,\\n        ].filter((a) => !deletedAttrIds.has(a.id));\\n        const attrsRecord = Object.fromEntries(attrsWithoutDeleted.map((a) => [a.id, a]));\\n        return attrsRecord;\\n    }\\n    /** Runs instaql on a query and a store */\\n    dataForQuery(hash) {\\n        const errorMessage = this._errorMessage;\\n        if (errorMessage) {\\n            return { error: errorMessage };\\n        }\\n        if (!this.querySubs)\\n            return;\\n        if (!this.pendingMutations)\\n            return;\\n        const querySubVersion = this.querySubs.version();\\n        const querySubs = this.querySubs.currentValue;\\n        const pendingMutationsVersion = this.pendingMutations.version();\\n        const pendingMutations = this.pendingMutations.currentValue;\\n        const { q, result } = querySubs[hash] || {};\\n        if (!result)\\n            return;\\n        const cached = this._dataForQueryCache[hash];\\n        if (cached &&\\n            querySubVersion === cached.querySubVersion &&\\n            pendingMutationsVersion === cached.pendingMutationsVersion) {\\n            return cached.data;\\n        }\\n        const { store, pageInfo, aggregate } = result;\\n        const muts = this._rewriteMutations(store.attrs, pendingMutations);\\n        const txSteps = [...muts.values()].flatMap((x) => x['tx-steps']);\\n        const newStore = s.transact(store, txSteps);\\n        const resp = (0, instaql_1.default)({ store: newStore, pageInfo, aggregate }, q);\\n        this._dataForQueryCache[hash] = {\\n            querySubVersion,\\n            pendingMutationsVersion,\\n            data: resp,\\n        };\\n        return resp;\\n    }\\n    /** Re-compute all subscriptions */\\n    notifyAll() {\\n        Object.keys(this.queryCbs).forEach((hash) => {\\n            this.notifyOne(hash);\\n        });\\n    }\\n    loadedNotifyAll() {\\n        if (this.pendingMutations.isLoading() || this.querySubs.isLoading())\\n            return;\\n        this.notifyAll();\\n    }\\n    shutdown() {\\n        var _a;\\n        this._isShutdown = true;\\n        (_a = this._ws) === null || _a === void 0 ? void 0 : _a.close();\\n    }\\n    /**\\n     * Sends mutation to server and schedules a timeout to cancel it if\\n     * we don't hear back in time.\\n     * Note: If we're offline we don't schedule a timeout, we'll schedule it\\n     * later once we're back online and send the mutation again\\n     *\\n     */\\n    _sendMutation(eventId, mutation) {\\n        if (mutation.error) {\\n            this._handleMutationError('error', eventId, {\\n                error: mutation.error,\\n                message: mutation.error.message,\\n            });\\n            return;\\n        }\\n        if (this.status !== STATUS.AUTHENTICATED) {\\n            this._finishTransaction('enqueued', eventId);\\n            return;\\n        }\\n        const timeoutMs = Math.max(5000, this.pendingMutations.currentValue.size * 5000);\\n        if (!this._isOnline) {\\n            this._finishTransaction('enqueued', eventId);\\n        }\\n        else {\\n            this._trySend(eventId, mutation);\\n            // If a transaction is pending for over 3 seconds,\\n            // we want to unblock the UX, so mark it as pending\\n            // and keep trying to process the transaction in the background\\n            setTimeout(() => {\\n                this._finishTransaction('pending', eventId);\\n            }, 3000);\\n            setTimeout(() => {\\n                if (!this._isOnline) {\\n                    return;\\n                }\\n                // If we are here, this means that we have sent this mutation, we are online\\n                // but we have not received a response. If it's this long, something must be wrong,\\n                // so we error with a timeout.\\n                this._handleMutationError('timeout', eventId, {\\n                    message: 'transaction timed out',\\n                });\\n            }, timeoutMs);\\n        }\\n    }\\n    // ---------------------------\\n    // Websocket\\n    /** Send messages we accumulated while we were connecting */\\n    _flushPendingMessages() {\\n        const subs = Object.keys(this.queryCbs).map((hash) => {\\n            return this.querySubs.currentValue[hash];\\n        });\\n        // Note: we should not have any nulls in subs, but we're\\n        // doing this defensively just in case.\\n        const safeSubs = subs.filter((x) => x);\\n        safeSubs.forEach(({ eventId, q }) => {\\n            this._trySendAuthed(eventId, { op: 'add-query', q });\\n        });\\n        Object.values(this.queryOnceDfds)\\n            .flat()\\n            .forEach(({ eventId, q }) => {\\n            this._trySendAuthed(eventId, { op: 'add-query', q });\\n        });\\n        const muts = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue);\\n        muts.forEach((mut, eventId) => {\\n            if (!mut['tx-id']) {\\n                this._sendMutation(eventId, mut);\\n            }\\n        });\\n    }\\n    _trySendAuthed(...args) {\\n        if (this.status !== STATUS.AUTHENTICATED) {\\n            return;\\n        }\\n        this._trySend(...args);\\n    }\\n    _trySend(eventId, msg, opts) {\\n        if (this._ws.readyState !== WS_OPEN_STATUS) {\\n            return;\\n        }\\n        if (!ignoreLogging[msg.op]) {\\n            log_1.default.info('[send]', this._ws._id, msg.op, msg);\\n        }\\n        this._ws.send(JSON.stringify(Object.assign({ 'client-event-id': eventId }, msg)));\\n    }\\n    _startSocket() {\\n        if (this._ws && this._ws.readyState == WS_CONNECTING_STATUS) {\\n            // Our current websocket is in a 'connecting' state.\\n            // There's no need to start another one, as the socket is\\n            // effectively fresh.\\n            log_1.default.info('[socket][start]', this._ws._id, 'maintained as current ws, we were still in a connecting state');\\n            return;\\n        }\\n        const prevWs = this._ws;\\n        this._ws = createWebSocket(`${this.config.websocketURI}?app_id=${this.config.appId}`);\\n        this._ws.onopen = this._wsOnOpen;\\n        this._ws.onmessage = this._wsOnMessage;\\n        this._ws.onclose = this._wsOnClose;\\n        this._ws.onerror = this._wsOnError;\\n        log_1.default.info('[socket][start]', this._ws._id);\\n        if ((prevWs === null || prevWs === void 0 ? void 0 : prevWs.readyState) === WS_OPEN_STATUS) {\\n            // When the network dies, it doesn't always mean that our\\n            // socket connection will fire a close event.\\n            //\\n            // We _could_ re-use the old socket, if the network drop was a\\n            // few seconds. But, to be safe right now we always create a new socket.\\n            //\\n            // This means that we have to make sure to kill the previous one ourselves.\\n            // c.f https://issues.chromium.org/issues/41343684\\n            log_1.default.info('[socket][start]', this._ws._id, 'close previous ws id = ', prevWs._id);\\n            prevWs.close();\\n        }\\n    }\\n    /**\\n     * Given a key, returns a stable local id, unique to this device and app.\\n     *\\n     * This can be useful if you want to create guest ids for example.\\n     *\\n     * Note: If the user deletes their local storage, this id will change.\\n     *\\n     * We use this._localIdPromises to ensure that we only generate a local\\n     * id once, even if multiple callers call this function concurrently.\\n     */\\n    getLocalId(name) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            const k = `localToken_${name}`;\\n            const id = yield this._persister.getItem(k);\\n            if (id)\\n                return id;\\n            if (this._localIdPromises[k]) {\\n                return this._localIdPromises[k];\\n            }\\n            const newId = (0, uuid_1.default)();\\n            this._localIdPromises[k] = this._persister\\n                .setItem(k, newId)\\n                .then(() => newId);\\n            return this._localIdPromises[k];\\n        });\\n    }\\n    // ----\\n    // Auth\\n    _replaceUrlAfterOAuth() {\\n        if (typeof URL === 'undefined') {\\n            return;\\n        }\\n        const url = new URL(window.location.href);\\n        if (url.searchParams.get(OAUTH_REDIRECT_PARAM)) {\\n            const startUrl = url.toString();\\n            url.searchParams.delete(OAUTH_REDIRECT_PARAM);\\n            url.searchParams.delete('code');\\n            url.searchParams.delete('error');\\n            const newPath = url.pathname +\\n                (url.searchParams.size ? '?' + url.searchParams : '') +\\n                url.hash;\\n            // Note: In next.js, this will revert to the old state if user navigates\\n            //       back. We would need to allow framework specific routing to work\\n            //       around that problem.\\n            history.replaceState(history.state, '', newPath);\\n            // navigation is part of the HTML spec, but not supported by Safari\\n            // or Firefox yet:\\n            // https://developer.mozilla.org/en-US/docs/Web/API/Navigation_API#browser_compatibility\\n            if (\\n            // @ts-ignore (waiting for ts support)\\n            typeof navigation === 'object' &&\\n                // @ts-ignore (waiting for ts support)\\n                typeof navigation.addEventListener === 'function' &&\\n                // @ts-ignore (waiting for ts support)\\n                typeof navigation.removeEventListener === 'function') {\\n                let ran = false;\\n                // The next.js app router will reset the URL when the router loads.\\n                // This puts it back after the router loads.\\n                const listener = (e) => {\\n                    var _a;\\n                    if (!ran) {\\n                        ran = true;\\n                        // @ts-ignore (waiting for ts support)\\n                        navigation.removeEventListener('navigate', listener);\\n                        if (!e.userInitiated &&\\n                            e.navigationType === 'replace' &&\\n                            ((_a = e.destination) === null || _a === void 0 ? void 0 : _a.url) === startUrl) {\\n                            history.replaceState(history.state, '', newPath);\\n                        }\\n                    }\\n                };\\n                // @ts-ignore (waiting for ts support)\\n                navigation.addEventListener('navigate', listener);\\n            }\\n        }\\n    }\\n    /**\\n     *\\n     * @returns Promise<null | {error: {message: string}}>\\n     */\\n    _oauthLoginInit() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            var _a, _b, _c, _d;\\n            if (typeof window === 'undefined' ||\\n                typeof window.location === 'undefined' ||\\n                typeof URLSearchParams === 'undefined') {\\n                return null;\\n            }\\n            const params = new URLSearchParams(window.location.search);\\n            if (!params.get(OAUTH_REDIRECT_PARAM)) {\\n                return null;\\n            }\\n            const error = params.get('error');\\n            if (error) {\\n                this._replaceUrlAfterOAuth();\\n                return { error: { message: error } };\\n            }\\n            const code = params.get('code');\\n            if (!code) {\\n                return null;\\n            }\\n            this._replaceUrlAfterOAuth();\\n            try {\\n                const { user } = yield authAPI.exchangeCodeForToken({\\n                    apiURI: this.config.apiURI,\\n                    appId: this.config.appId,\\n                    code,\\n                });\\n                this.setCurrentUser(user);\\n                return null;\\n            }\\n            catch (e) {\\n                if (((_a = e === null || e === void 0 ? void 0 : e.body) === null || _a === void 0 ? void 0 : _a.type) === 'record-not-found' &&\\n                    ((_c = (_b = e === null || e === void 0 ? void 0 : e.body) === null || _b === void 0 ? void 0 : _b.hint) === null || _c === void 0 ? void 0 : _c['record-type']) === 'app-oauth-code' &&\\n                    (yield this._hasCurrentUser())) {\\n                    // We probably just weren't able to clean up the URL, so\\n                    // let's just ignore this error\\n                    return null;\\n                }\\n                const message = ((_d = e === null || e === void 0 ? void 0 : e.body) === null || _d === void 0 ? void 0 : _d.message) || 'Error logging in.';\\n                return { error: { message } };\\n            }\\n        });\\n    }\\n    _waitForOAuthCallbackResponse() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            return yield this._oauthCallbackResponse;\\n        });\\n    }\\n    __subscribeMutationErrors(cb) {\\n        this.mutationErrorCbs.push(cb);\\n        return () => {\\n            this.mutationErrorCbs = this.mutationErrorCbs.filter((x) => x !== cb);\\n        };\\n    }\\n    subscribeAuth(cb) {\\n        this.authCbs.push(cb);\\n        const currUserCached = this._currentUserCached;\\n        if (!currUserCached.isLoading) {\\n            cb(this._currentUserCached);\\n        }\\n        let unsubbed = false;\\n        this.getCurrentUser().then((resp) => {\\n            if (unsubbed)\\n                return;\\n            if ((0, object_1.areObjectsDeepEqual)(resp, currUserCached))\\n                return;\\n            cb(resp);\\n        });\\n        return () => {\\n            unsubbed = true;\\n            this.authCbs = this.authCbs.filter((x) => x !== cb);\\n        };\\n    }\\n    getAuth() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            const { user, error } = yield this.getCurrentUser();\\n            if (error) {\\n                throw error;\\n            }\\n            return user;\\n        });\\n    }\\n    subscribeConnectionStatus(cb) {\\n        this.connectionStatusCbs.push(cb);\\n        return () => {\\n            this.connectionStatusCbs = this.connectionStatusCbs.filter((x) => x !== cb);\\n        };\\n    }\\n    subscribeAttrs(cb) {\\n        this.attrsCbs.push(cb);\\n        if (this.attrs) {\\n            cb(this.attrs);\\n        }\\n        return () => {\\n            this.attrsCbs = this.attrsCbs.filter((x) => x !== cb);\\n        };\\n    }\\n    notifyAuthSubs(user) {\\n        this.authCbs.forEach((cb) => cb(user));\\n    }\\n    notifyMutationErrorSubs(error) {\\n        this.mutationErrorCbs.forEach((cb) => cb(error));\\n    }\\n    notifyAttrsSubs() {\\n        if (!this.attrs)\\n            return;\\n        const oas = this.optimisticAttrs();\\n        this.attrsCbs.forEach((cb) => cb(oas));\\n    }\\n    notifyConnectionStatusSubs(status) {\\n        this.connectionStatusCbs.forEach((cb) => cb(status));\\n    }\\n    setCurrentUser(user) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            yield this._persister.setItem(currentUserKey, JSON.stringify(user));\\n        });\\n    }\\n    getCurrentUserCached() {\\n        return this._currentUserCached;\\n    }\\n    getCurrentUser() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            const oauthResp = yield this._waitForOAuthCallbackResponse();\\n            if (oauthResp === null || oauthResp === void 0 ? void 0 : oauthResp.error) {\\n                const errorV = { error: oauthResp.error, user: undefined };\\n                this._currentUserCached = Object.assign({ isLoading: false }, errorV);\\n                return errorV;\\n            }\\n            const user = yield this._persister.getItem(currentUserKey);\\n            const userV = { user: JSON.parse(user), error: undefined };\\n            this._currentUserCached = Object.assign({ isLoading: false }, userV);\\n            return userV;\\n        });\\n    }\\n    _hasCurrentUser() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            const user = yield this._persister.getItem(currentUserKey);\\n            return JSON.parse(user) != null;\\n        });\\n    }\\n    changeCurrentUser(newUser) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            var _a;\\n            const { user: oldUser } = yield this.getCurrentUser();\\n            if ((0, object_1.areObjectsDeepEqual)(oldUser, newUser)) {\\n                // We were already logged in as the newUser, don't\\n                // bother updating\\n                return;\\n            }\\n            yield this.setCurrentUser(newUser);\\n            // We need to remove all `result` from querySubs,\\n            // as they are no longer valid for the new user\\n            this.updateUser(newUser);\\n            try {\\n                (_a = this._broadcastChannel) === null || _a === void 0 ? void 0 : _a.postMessage({ type: 'auth' });\\n            }\\n            catch (error) {\\n                console.error('Error posting message to broadcast channel', error);\\n            }\\n        });\\n    }\\n    updateUser(newUser) {\\n        const newV = { error: undefined, user: newUser };\\n        this._currentUserCached = Object.assign({ isLoading: false }, newV);\\n        this._dataForQueryCache = {};\\n        this.querySubs.set((prev) => {\\n            Object.keys(prev).forEach((k) => {\\n                delete prev[k].result;\\n            });\\n            return prev;\\n        });\\n        this._reconnectTimeoutMs = 0;\\n        this._ws.close();\\n        this._oauthCallbackResponse = null;\\n        this.notifyAuthSubs(newV);\\n    }\\n    sendMagicCode({ email }) {\\n        return authAPI.sendMagicCode({\\n            apiURI: this.config.apiURI,\\n            appId: this.config.appId,\\n            email: email,\\n        });\\n    }\\n    signInWithMagicCode(_a) {\\n        return __awaiter(this, arguments, void 0, function* ({ email, code }) {\\n            const res = yield authAPI.verifyMagicCode({\\n                apiURI: this.config.apiURI,\\n                appId: this.config.appId,\\n                email,\\n                code,\\n            });\\n            yield this.changeCurrentUser(res.user);\\n            return res;\\n        });\\n    }\\n    signInWithCustomToken(authToken) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            const res = yield authAPI.verifyRefreshToken({\\n                apiURI: this.config.apiURI,\\n                appId: this.config.appId,\\n                refreshToken: authToken,\\n            });\\n            yield this.changeCurrentUser(res.user);\\n            return res;\\n        });\\n    }\\n    signOut() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            var _a;\\n            const currentUser = yield this.getCurrentUser();\\n            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;\\n            if (refreshToken) {\\n                try {\\n                    yield authAPI.signOut({\\n                        apiURI: this.config.apiURI,\\n                        appId: this.config.appId,\\n                        refreshToken,\\n                    });\\n                }\\n                catch (e) { }\\n            }\\n            yield this.changeCurrentUser(null);\\n        });\\n    }\\n    /**\\n     * Creates an OAuth authorization URL.\\n     * @param {Object} params - The parameters to create the authorization URL.\\n     * @param {string} params.clientName - The name of the client requesting authorization.\\n     * @param {string} params.redirectURL - The URL to redirect users to after authorization.\\n     * @returns {string} The created authorization URL.\\n     */\\n    createAuthorizationURL({ clientName, redirectURL }) {\\n        const { apiURI, appId } = this.config;\\n        return `${apiURI}/runtime/oauth/start?app_id=${appId}&client_name=${clientName}&redirect_uri=${redirectURL}`;\\n    }\\n    /**\\n     * @param {Object} params\\n     * @param {string} params.code - The code received from the OAuth service.\\n     * @param {string} [params.codeVerifier] - The code verifier used to generate the code challenge.\\n     */\\n    exchangeCodeForToken(_a) {\\n        return __awaiter(this, arguments, void 0, function* ({ code, codeVerifier }) {\\n            const res = yield authAPI.exchangeCodeForToken({\\n                apiURI: this.config.apiURI,\\n                appId: this.config.appId,\\n                code: code,\\n                codeVerifier,\\n            });\\n            yield this.changeCurrentUser(res.user);\\n            return res;\\n        });\\n    }\\n    issuerURI() {\\n        const { apiURI, appId } = this.config;\\n        return `${apiURI}/runtime/${appId}`;\\n    }\\n    /**\\n     * @param {Object} params\\n     * @param {string} params.clientName - The name of the client requesting authorization.\\n     * @param {string} params.idToken - The id_token from the external service\\n     * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service\\n     */\\n    signInWithIdToken(_a) {\\n        return __awaiter(this, arguments, void 0, function* ({ idToken, clientName, nonce }) {\\n            var _b;\\n            const currentUser = yield this.getCurrentUser();\\n            const refreshToken = (_b = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _b === void 0 ? void 0 : _b.refresh_token;\\n            const res = yield authAPI.signInWithIdToken({\\n                apiURI: this.config.apiURI,\\n                appId: this.config.appId,\\n                idToken,\\n                clientName,\\n                nonce,\\n                refreshToken,\\n            });\\n            yield this.changeCurrentUser(res.user);\\n            return res;\\n        });\\n    }\\n    // --------\\n    // Rooms\\n    joinRoom(roomId) {\\n        if (!this._rooms[roomId]) {\\n            this._rooms[roomId] = {\\n                isConnected: false,\\n                error: undefined,\\n            };\\n        }\\n        this._presence[roomId] = this._presence[roomId] || {};\\n        this._tryJoinRoom(roomId);\\n        return () => {\\n            this._cleanupRoom(roomId);\\n        };\\n    }\\n    _cleanupRoom(roomId) {\\n        var _a, _b, _c, _d;\\n        if (!((_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.length) &&\\n            !Object.keys((_c = this._broadcastSubs[roomId]) !== null && _c !== void 0 ? _c : {}).length) {\\n            const isConnected = (_d = this._rooms[roomId]) === null || _d === void 0 ? void 0 : _d.isConnected;\\n            delete this._rooms[roomId];\\n            delete this._presence[roomId];\\n            delete this._broadcastSubs[roomId];\\n            if (isConnected) {\\n                this._tryLeaveRoom(roomId);\\n            }\\n            else {\\n                this._roomsPendingLeave[roomId] = true;\\n            }\\n        }\\n    }\\n    // --------\\n    // Presence\\n    // TODO: look into typing again\\n    getPresence(roomType, roomId, opts = {}) {\\n        const room = this._rooms[roomId];\\n        const presence = this._presence[roomId];\\n        if (!room || !presence || !presence.result)\\n            return null;\\n        return Object.assign(Object.assign({}, (0, presence_1.buildPresenceSlice)(presence.result, opts, this._sessionId)), { isLoading: !room.isConnected, error: room.error });\\n    }\\n    // TODO: look into typing again\\n    publishPresence(roomType, roomId, partialData) {\\n        const room = this._rooms[roomId];\\n        const presence = this._presence[roomId];\\n        if (!room || !presence) {\\n            return;\\n        }\\n        presence.result = presence.result || {};\\n        const data = Object.assign(Object.assign({}, presence.result.user), partialData);\\n        presence.result.user = data;\\n        if (!room.isConnected) {\\n            return;\\n        }\\n        this._trySetPresence(roomId, data);\\n        this._notifyPresenceSubs(roomId);\\n    }\\n    _trySetPresence(roomId, data) {\\n        this._trySendAuthed((0, uuid_1.default)(), {\\n            op: 'set-presence',\\n            'room-id': roomId,\\n            data,\\n        });\\n    }\\n    _tryJoinRoom(roomId) {\\n        this._trySendAuthed((0, uuid_1.default)(), { op: 'join-room', 'room-id': roomId });\\n        delete this._roomsPendingLeave[roomId];\\n    }\\n    _tryLeaveRoom(roomId) {\\n        this._trySendAuthed((0, uuid_1.default)(), { op: 'leave-room', 'room-id': roomId });\\n    }\\n    // TODO: look into typing again\\n    subscribePresence(roomType, roomId, opts, cb) {\\n        const leaveRoom = this.joinRoom(roomId);\\n        const handler = Object.assign(Object.assign({}, opts), { roomId, cb, prev: null });\\n        this._presence[roomId] = this._presence[roomId] || {};\\n        this._presence[roomId].handlers = this._presence[roomId].handlers || [];\\n        this._presence[roomId].handlers.push(handler);\\n        this._notifyPresenceSub(roomId, handler);\\n        return () => {\\n            var _a, _b, _c;\\n            this._presence[roomId].handlers =\\n                (_c = (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.filter((x) => x !== handler)) !== null && _c !== void 0 ? _c : [];\\n            leaveRoom();\\n        };\\n    }\\n    _notifyPresenceSubs(roomId) {\\n        var _a, _b;\\n        (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.forEach((handler) => {\\n            this._notifyPresenceSub(roomId, handler);\\n        });\\n    }\\n    _notifyPresenceSub(roomId, handler) {\\n        const slice = this.getPresence('', roomId, handler);\\n        if (!slice) {\\n            return;\\n        }\\n        if (handler.prev && !(0, presence_1.hasPresenceResponseChanged)(slice, handler.prev)) {\\n            return;\\n        }\\n        handler.prev = slice;\\n        handler.cb(slice);\\n    }\\n    _patchPresencePeers(roomId, edits) {\\n        var _a, _b, _c, _d;\\n        const peers = ((_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b.peers) || {};\\n        let sessions = Object.fromEntries(Object.entries(peers).map(([k, v]) => [k, { data: v }]));\\n        sessions[this._sessionId] = { data: (_d = (_c = this._presence[roomId]) === null || _c === void 0 ? void 0 : _c.result) === null || _d === void 0 ? void 0 : _d.user };\\n        for (let [path, op, value] of edits) {\\n            if (op === '+' || op === 'r') {\\n                sessions = (0, object_1.assocIn)(sessions, path, value);\\n            }\\n            if (op === '-') {\\n                sessions = (0, object_1.dissocIn)(sessions, path);\\n            }\\n        }\\n        this._setPresencePeers(roomId, sessions);\\n    }\\n    _setPresencePeers(roomId, data) {\\n        const sessions = Object.assign({}, data);\\n        // no need to keep track of `user`\\n        delete sessions[this._sessionId];\\n        const peers = Object.fromEntries(Object.entries(sessions).map(([k, v]) => [k, v.data]));\\n        this._presence = (0, object_1.assocIn)(this._presence, [roomId, 'result', 'peers'], peers);\\n    }\\n    // --------\\n    // Broadcast\\n    publishTopic({ roomType, roomId, topic, data }) {\\n        var _a;\\n        const room = this._rooms[roomId];\\n        if (!room) {\\n            return;\\n        }\\n        if (!room.isConnected) {\\n            this._broadcastQueue[roomId] = (_a = this._broadcastQueue[roomId]) !== null && _a !== void 0 ? _a : [];\\n            this._broadcastQueue[roomId].push({ topic, roomType, data });\\n            return;\\n        }\\n        this._tryBroadcast(roomId, roomType, topic, data);\\n    }\\n    _tryBroadcast(roomId, roomType, topic, data) {\\n        this._trySendAuthed((0, uuid_1.default)(), {\\n            op: 'client-broadcast',\\n            'room-id': roomId,\\n            roomType,\\n            topic,\\n            data,\\n        });\\n    }\\n    subscribeTopic(roomId, topic, cb) {\\n        const leaveRoom = this.joinRoom(roomId);\\n        this._broadcastSubs[roomId] = this._broadcastSubs[roomId] || {};\\n        this._broadcastSubs[roomId][topic] =\\n            this._broadcastSubs[roomId][topic] || [];\\n        this._broadcastSubs[roomId][topic].push(cb);\\n        this._presence[roomId] = this._presence[roomId] || {};\\n        return () => {\\n            this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic].filter((x) => x !== cb);\\n            if (!this._broadcastSubs[roomId][topic].length) {\\n                delete this._broadcastSubs[roomId][topic];\\n            }\\n            leaveRoom();\\n        };\\n    }\\n    _notifyBroadcastSubs(room, topic, msg) {\\n        var _a, _b, _c;\\n        (_c = (_b = (_a = this._broadcastSubs) === null || _a === void 0 ? void 0 : _a[room]) === null || _b === void 0 ? void 0 : _b[topic]) === null || _c === void 0 ? void 0 : _c.forEach((cb) => {\\n            var _a, _b, _c, _d, _e, _f;\\n            const data = (_a = msg.data) === null || _a === void 0 ? void 0 : _a.data;\\n            const peer = msg.data['peer-id'] === this._sessionId\\n                ? (_c = (_b = this._presence[room]) === null || _b === void 0 ? void 0 : _b.result) === null || _c === void 0 ? void 0 : _c.user\\n                : (_f = (_e = (_d = this._presence[room]) === null || _d === void 0 ? void 0 : _d.result) === null || _e === void 0 ? void 0 : _e.peers) === null || _f === void 0 ? void 0 : _f[msg.data['peer-id']];\\n            return cb(data, peer);\\n        });\\n    }\\n    // --------\\n    // Storage\\n    uploadFile(path, file, opts) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            var _a;\\n            const currentUser = yield this.getCurrentUser();\\n            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;\\n            return StorageApi.uploadFile(Object.assign(Object.assign({}, opts), { apiURI: this.config.apiURI, appId: this.config.appId, path: path, file, refreshToken: refreshToken }));\\n        });\\n    }\\n    deleteFile(path) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            var _a;\\n            const currentUser = yield this.getCurrentUser();\\n            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;\\n            const result = yield StorageApi.deleteFile({\\n                apiURI: this.config.apiURI,\\n                appId: this.config.appId,\\n                path,\\n                refreshToken: refreshToken,\\n            });\\n            return result;\\n        });\\n    }\\n    // Deprecated Storage API (Jan 2025)\\n    // ---------------------------------\\n    upload(path, file) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            var _a;\\n            const currentUser = yield this.getCurrentUser();\\n            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;\\n            const fileName = path || file.name;\\n            const url = yield StorageApi.getSignedUploadUrl({\\n                apiURI: this.config.apiURI,\\n                appId: this.config.appId,\\n                fileName: fileName,\\n                refreshToken: refreshToken,\\n            });\\n            const isSuccess = yield StorageApi.upload(url, file);\\n            return isSuccess;\\n        });\\n    }\\n    getDownloadUrl(path) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            var _a;\\n            const currentUser = yield this.getCurrentUser();\\n            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;\\n            const url = yield StorageApi.getDownloadUrl({\\n                apiURI: this.config.apiURI,\\n                appId: this.config.appId,\\n                path: path,\\n                refreshToken: refreshToken,\\n            });\\n            return url;\\n        });\\n    }\\n}\\nexports.default = Reactor;\\n//# sourceMappingURL=Reactor.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"isClient\",\"isChrome\",\"chrome\",\"window\",\"querySubsFromJSON\",\"str\",\"_a\",\"parsed\",\"JSON\",\"parse\",\"key\",\"v\",\"result\",\"store\",\"s\",\"fromJSON\",\"querySubsToJSON\",\"querySubs\",\"jsonSubs\",\"sub\",\"jsonSub\",\"Object\",\"assign\",\"toJSON\",\"stringify\",\"__createBinding\",\"create\",\"o\",\"m\",\"k\",\"k2\",\"undefined\",\"desc\",\"getOwnPropertyDescriptor\",\"__esModule\",\"writable\",\"configurable\",\"enumerable\",\"get\",\"defineProperty\",\"__setModuleDefault\",\"value\",\"__importStar\",\"mod\",\"prototype\",\"hasOwnProperty\",\"call\",\"__awaiter\",\"thisArg\",\"_arguments\",\"P\",\"generator\",\"adopt\",\"resolve\",\"Promise\",\"reject\",\"fulfilled\",\"step\",\"next\",\"e\",\"rejected\",\"done\",\"then\",\"apply\",\"__importDefault\",\"log_1\",\"weakHash_1\",\"instaql_1\",\"instaml\",\"uuid_1\",\"IndexedDBStorage_1\",\"WindowNetworkListener_1\",\"authAPI\",\"StorageApi\",\"presence_1\",\"Deferred_1\",\"PersistedObject_1\",\"instaqlResult_1\",\"object_1\",\"linkIndex_1\",\"version_1\",\"defaultConfig\",\"apiURI\",\"websocketURI\",\"_wsId\",\"ignoreLogging\",\"Reactor\",\"constructor\",\"config\",\"Storage\",\"default\",\"NetworkListener\",\"versions\",\"_isOnline\",\"_isShutdown\",\"status\",\"CONNECTING\",\"queryCbs\",\"queryOnceDfds\",\"authCbs\",\"attrsCbs\",\"mutationErrorCbs\",\"connectionStatusCbs\",\"mutationDeferredStore\",\"Map\",\"_reconnectTimeoutId\",\"_reconnectTimeoutMs\",\"_localIdPromises\",\"_linkIndex\",\"_oauthCallbackResponse\",\"_errorMessage\",\"_rooms\",\"_roomsPendingLeave\",\"_presence\",\"_broadcastQueue\",\"_broadcastSubs\",\"_currentUserCached\",\"isLoading\",\"error\",\"user\",\"_beforeUnloadCbs\",\"_dataForQueryCache\",\"_onMergeQuerySubs\",\"_storageSubs\",\"inMemorySubs\",\"this._onMergeQuerySubs\",\"storageSubs\",\"ret\",\"entries\",\"forEach\",\"hash\",\"querySub\",\"storageResult\",\"memoryResult\",\"keys\",\"filter\",\"slice\",\"storageKsToAdd\",\"set\",\"_\",\"loadedNotifyAll\",\"_onMergePendingMutations\",\"storageMuts\",\"inMemoryMuts\",\"this._onMergePendingMutations\",\"pendingMutations\",\"_rewriteMutations\",\"rewrittenStorageMuts\",\"attrs\",\"mut\",\"has\",\"_sendMutation\",\"getPreviousResult\",\"q\",\"this.getPreviousResult\",\"dataForQuery\",\"notifyOne\",\"this.notifyOne\",\"_b\",\"cbs\",\"prevData\",\"data\",\"areObjectsDeepEqual\",\"r\",\"cb\",\"notifyOneQueryOnce\",\"this.notifyOneQueryOnce\",\"dfds\",\"_completeQueryOnce\",\"dfd\",\"notifyQueryError\",\"this.notifyQueryError\",\"pushTx\",\"chunks\",\"this.pushTx\",\"txSteps\",\"transform\",\"optimisticAttrs\",\"schema\",\"pushOps\",\"this.pushOps\",\"eventId\",\"mutation\",\"op\",\"prev\",\"Deferred\",\"notifyAll\",\"promise\",\"_wsOnOpen\",\"this._wsOnOpen\",\"targetWs\",\"target\",\"_ws\",\"info\",\"_id\",\"_setStatus\",\"OPENED\",\"getCurrentUser\",\"resp\",\"_trySend\",\"appId\",\"__adminToken\",\"_wsOnMessage\",\"this._wsOnMessage\",\"toString\",\"_handleReceive\",\"_wsOnError\",\"this._wsOnError\",\"_wsOnClose\",\"this._wsOnClose\",\"CLOSED\",\"room\",\"values\",\"isConnected\",\"setTimeout\",\"Math\",\"min\",\"_startSocket\",\"createLinkIndex\",\"BroadcastChannel\",\"_broadcastChannel\",\"addEventListener\",\"type\",\"res\",\"updateUser\",\"_oauthLoginInit\",\"_initStorage\",\"getIsOnline\",\"isOnline\",\"listen\",\"_beforeUnload\",\"bind\",\"_persister\",\"PersistedObject\",\"x\",\"push\",\"flush\",\"_finishTransaction\",\"clientId\",\"errDetails\",\"delete\",\"ok\",\"console\",\"err\",\"notifyConnectionStatusSubs\",\"_flushEnqueuedRoomData\",\"roomId\",\"enqueuedUserPresence\",\"enqueuedBroadcasts\",\"_trySetPresence\",\"item\",\"topic\",\"roomType\",\"_tryBroadcast\",\"wsId\",\"msg\",\"_c\",\"_d\",\"enableCardinalityInference\",\"cardinalityInference\",\"AUTHENTICATED\",\"_setAttrs\",\"_flushPendingMessages\",\"_sessionId\",\"_tryJoinRoom\",\"pageInfo\",\"aggregate\",\"triples\",\"extractTriples\",\"createStore\",\"computations\",\"updates\",\"map\",\"prevMutation\",\"muts\",\"currentValue\",\"txStepsToApply\",\"newStore\",\"transact\",\"newAttrs\",\"action\",\"_args\",\"attr\",\"concat\",\"_patchPresencePeers\",\"_notifyPresenceSubs\",\"_setPresencePeers\",\"_notifyBroadcastSubs\",\"loadingRoomId\",\"joinedRoom\",\"_tryLeaveRoom\",\"errorRoomId\",\"errorRoom\",\"_handleReceiveError\",\"_handleMutationError\",\"notifyAttrsSubs\",\"notifyMutationErrorSubs\",\"_e\",\"errorMessage\",\"message\",\"hint\",\"notifyQueryOnceError\",\"changeCurrentUser\",\"ERRORED\",\"errorObj\",\"find\",\"reduce\",\"acc\",\"id\",\"_startQuerySub\",\"_trySendAuthed\",\"subscribeQuery\",\"prevResult\",\"_unsubQuery\",\"queryOnce\",\"Error\",\"QUERY_ONCE_TIMEOUT\",\"_cleanupQuery\",\"length\",\"mapping\",\"attrIdMap\",\"refSwapAttrIds\",\"Set\",\"rewritten\",\"retTxSteps\",\"txStep\",\"etype\",\"label\",\"existing\",\"getAttrByFwdIdentName\",\"revAttr\",\"getAttrByReverseIdentName\",\"add\",\"newTxStep\",\"rewriteStep\",\"pendingMutationSteps\",\"flatMap\",\"deletedAttrIds\",\"pendingAttrs\",\"_action\",\"fullAttr\",\"attrsWithoutDeleted\",\"a\",\"fromEntries\",\"attrsRecord\",\"querySubVersion\",\"version\",\"pendingMutationsVersion\",\"cached\",\"shutdown\",\"close\",\"timeoutMs\",\"max\",\"size\",\"subs\",\"safeSubs\",\"flat\",\"args\",\"opts\",\"WS_OPEN_STATUS\",\"readyState\",\"send\",\"WS_CONNECTING_STATUS\",\"prevWs\",\"ws\",\"WebSocket\",\"uri\",\"onopen\",\"onmessage\",\"onclose\",\"onerror\",\"getLocalId\",\"name\",\"getItem\",\"newId\",\"setItem\",\"_replaceUrlAfterOAuth\",\"URL\",\"url\",\"location\",\"href\",\"searchParams\",\"OAUTH_REDIRECT_PARAM\",\"startUrl\",\"newPath\",\"pathname\",\"history\",\"replaceState\",\"state\",\"navigation\",\"removeEventListener\",\"ran\",\"listener\",\"userInitiated\",\"navigationType\",\"destination\",\"URLSearchParams\",\"params\",\"search\",\"code\",\"exchangeCodeForToken\",\"setCurrentUser\",\"body\",\"_hasCurrentUser\",\"_waitForOAuthCallbackResponse\",\"__subscribeMutationErrors\",\"subscribeAuth\",\"currUserCached\",\"unsubbed\",\"getAuth\",\"subscribeConnectionStatus\",\"subscribeAttrs\",\"notifyAuthSubs\",\"oas\",\"currentUserKey\",\"getCurrentUserCached\",\"oauthResp\",\"errorV\",\"userV\",\"newUser\",\"oldUser\",\"postMessage\",\"newV\",\"sendMagicCode\",\"email\",\"signInWithMagicCode\",\"arguments\",\"verifyMagicCode\",\"signInWithCustomToken\",\"authToken\",\"verifyRefreshToken\",\"refreshToken\",\"signOut\",\"currentUser\",\"refresh_token\",\"createAuthorizationURL\",\"clientName\",\"redirectURL\",\"codeVerifier\",\"issuerURI\",\"signInWithIdToken\",\"idToken\",\"nonce\",\"joinRoom\",\"_cleanupRoom\",\"handlers\",\"getPresence\",\"presence\",\"buildPresenceSlice\",\"publishPresence\",\"partialData\",\"subscribePresence\",\"leaveRoom\",\"handler\",\"_notifyPresenceSub\",\"hasPresenceResponseChanged\",\"edits\",\"peers\",\"sessions\",\"path\",\"assocIn\",\"dissocIn\",\"publishTopic\",\"subscribeTopic\",\"_f\",\"peer\",\"uploadFile\",\"file\",\"deleteFile\",\"upload\",\"getSignedUploadUrl\",\"fileName\",\"isSuccess\",\"getDownloadUrl\"]\n}\n"]