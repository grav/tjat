["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@instantdb/core/dist/store.js"],"~:js","shadow$provide.module$node_modules$$instantdb$core$dist$store = function(global, require, module, exports) {\n  function isRef(attr) {\n    return \"ref\" === attr[\"value-type\"];\n  }\n  function getInMap(obj, path) {\n    return path.reduce((acc, key) => acc && acc.get(key), obj);\n  }\n  function deleteInMap(m, path) {\n    if (0 === path.length) {\n      throw Error(\"path must have at least one element\");\n    }\n    if (1 === path.length) {\n      m.delete(path[0]);\n    } else {\n      var [head, ...tail] = path;\n      m.has(head) && deleteInMap(m.get(head), tail);\n    }\n  }\n  function setInMap(m, path, value) {\n    if (0 === path.length) {\n      throw Error(\"path must have at least one element\");\n    }\n    if (1 === path.length) {\n      m.set(path[0], value);\n    } else {\n      var [head, ...tail] = path;\n      path = m.get(head);\n      path || (path = new Map(), m.set(head, path));\n      setInMap(path, tail, value);\n    }\n  }\n  function createTripleIndexes(attrs, triples) {\n    const eav = new Map(), aev = new Map(), vae = new Map();\n    for (const triple of triples) {\n      const [eid, aid, v] = triple;\n      (triples = attrs[aid]) ? (isRef(triples) && setInMap(vae, [v, aid, eid], triple), setInMap(eav, [eid, aid, v], triple), setInMap(aev, [aid, eid, v], triple)) : console.warn(\"no such attr\", eid, attrs);\n    }\n    return {eav, aev, vae};\n  }\n  function createAttrIndexes(attrs) {\n    const blobAttrs = new Map(), primaryKeys = new Map(), forwardIdents = new Map(), revIdents = new Map();\n    for (const attr of Object.values(attrs)) {\n      const [, fwdEtype, fwdLabel] = attr[\"forward-identity\"];\n      attrs = attr[\"reverse-identity\"];\n      setInMap(forwardIdents, [fwdEtype, fwdLabel], attr);\n      \"blob\" === attr[\"value-type\"] && setInMap(blobAttrs, [fwdEtype, fwdLabel], attr);\n      attr[\"primary?\"] && setInMap(primaryKeys, [fwdEtype], attr);\n      if (attrs) {\n        const [, revEtype, revLabel] = attrs;\n        setInMap(revIdents, [revEtype, revLabel], attr);\n      }\n    }\n    return {blobAttrs, primaryKeys, forwardIdents, revIdents};\n  }\n  function createStore(attrs, triples, enableCardinalityInference, linkIndex) {\n    triples = createTripleIndexes(attrs, triples);\n    triples.attrs = attrs;\n    triples.attrIndexes = createAttrIndexes(attrs);\n    triples.cardinalityInference = enableCardinalityInference;\n    triples.linkIndex = linkIndex;\n    triples.__type = \"store\";\n    return triples;\n  }\n  function resolveLookupRefs(store, triple) {\n    var _a, _b;\n    if (Array.isArray(triple[0])) {\n      const [a, v] = triple[0];\n      var eid = store.aev.get(a);\n      if (!eid) {\n        return null;\n      }\n      eid = null === (_a = allMapValues(eid, 2).find(x => x[2] === v)) || void 0 === _a ? void 0 : _a[0];\n    } else {\n      eid = triple[0];\n    }\n    if (!eid) {\n      return null;\n    }\n    _a = triple[2];\n    if (Array.isArray(_a) && 2 === _a.length && store.aev.get(_a[0])) {\n      const [a, v] = _a;\n      store = store.aev.get(a);\n      if (!store) {\n        return null;\n      }\n      store = null === (_b = allMapValues(store, 2).find(x => x[2] === v)) || void 0 === _b ? void 0 : _b[0];\n      if (!store) {\n        return null;\n      }\n      const [, aid, , ...rest] = triple;\n      return [eid, aid, store, ...rest];\n    }\n    [, ...triple] = triple;\n    return [eid, ...triple];\n  }\n  function getCreatedAt(store, attr, triple) {\n    const [eid, aid, v] = triple;\n    let createdAt;\n    (store = getInMap(store.ea, [eid, aid, v])) && (createdAt = store[3]);\n    return createdAt || 10 * Date.now() + _seed++;\n  }\n  function deleteEntity(store, args) {\n    var _a, _b;\n    const [lookup, etype] = args;\n    if (args = resolveLookupRefs(store, [lookup])) {\n      [args] = args;\n      var eMap = store.eav.get(args);\n      if (eMap) {\n        for (const a of eMap.keys()) {\n          const attr = store.attrs[a];\n          attr && \"cascade\" === attr[\"on-delete-reverse\"] && allMapValues(eMap.get(a), 1).forEach(([, , v]) => {\n            var _a;\n            return deleteEntity(store, [v, null === (_a = attr[\"reverse-identity\"]) || void 0 === _a ? void 0 : _a[1]]);\n          });\n          etype && attr && (null === (_a = attr[\"forward-identity\"]) || void 0 === _a ? void 0 : _a[1]) !== etype || (deleteInMap(store.aev, [a, args]), deleteInMap(store.eav, [args, a]));\n        }\n        0 === eMap.size && deleteInMap(store.eav, [args]);\n      }\n      (_a = store.vae.get(args) && allMapValues(store.vae.get(args), 2)) && _a.forEach(triple => {\n        var _a, _b;\n        const [e, a, v] = triple;\n        triple = store.attrs[a];\n        etype && triple && (null === (_a = triple[\"reverse-identity\"]) || void 0 === _a ? void 0 : _a[1]) !== etype || (deleteInMap(store.eav, [e, a, v]), deleteInMap(store.aev, [a, e, v]), deleteInMap(store.vae, [v, a, e]));\n        triple && \"cascade\" === triple[\"on-delete\"] && deleteEntity(store, [e, null === (_b = triple[\"forward-identity\"]) || void 0 === _b ? void 0 : _b[1]]);\n      });\n      0 === (null === (_b = store.vae.get(args)) || void 0 === _b ? void 0 : _b.size) && deleteInMap(store.vae, [args]);\n    }\n  }\n  function resetIndexMap(store, newTriples) {\n    const newIndexMap = createTripleIndexes(store.attrs, newTriples);\n    Object.keys(newIndexMap).forEach(key => {\n      store[key] = newIndexMap[key];\n    });\n  }\n  function addAttr(store, [attr]) {\n    store.attrs[attr.id] = attr;\n    store.attrIndexes = createAttrIndexes(store.attrs);\n  }\n  function deleteAttr(store, [id]) {\n    if (store.attrs[id]) {\n      var newTriples = allMapValues(store.eav, 3).filter(([, aid]) => aid !== id);\n      delete store.attrs[id];\n      store.attrIndexes = createAttrIndexes(store.attrs);\n      resetIndexMap(store, newTriples);\n    }\n  }\n  function updateAttr(store, [partialAttr]) {\n    const attr = store.attrs[partialAttr.id];\n    attr && (store.attrs[partialAttr.id] = Object.assign(Object.assign({}, attr), partialAttr), store.attrIndexes = createAttrIndexes(store.attrs), resetIndexMap(store, allMapValues(store.eav, 3)));\n  }\n  function allMapValues(m, level, res = []) {\n    if (!m || 0 === level) {\n      return res;\n    }\n    if (1 === level) {\n      for (const v of m.values()) {\n        res.push(v);\n      }\n      return res;\n    }\n    for (const v of m.values()) {\n      allMapValues(v, level - 1, res);\n    }\n    return res;\n  }\n  function triplesByValue(store, m, v) {\n    var _a;\n    const res = [];\n    if (null === v || void 0 === v ? 0 : v.hasOwnProperty(\"$not\")) {\n      for (const candidate of m.keys()) {\n        v.$not !== candidate && res.push(m.get(candidate));\n      }\n      return res;\n    }\n    if (null === v || void 0 === v ? 0 : v.hasOwnProperty(\"$isNull\")) {\n      const {attrId, isNull, reverse} = v.$isNull;\n      if (reverse) {\n        for (const candidate of m.keys()) {\n          var _b = store.vae.get(candidate);\n          var isValNull = !_b || (null === (_a = _b.get(attrId)) || void 0 === _a ? void 0 : _a.get(null)) || !_b.get(attrId);\n          (isNull ? isValNull : !isValNull) && res.push(m.get(candidate));\n        }\n      } else {\n        store = store.aev.get(attrId);\n        for (isValNull of m.keys()) {\n          _a = !store || (null === (_b = store.get(isValNull)) || void 0 === _b ? void 0 : _b.get(null)) || !store.get(isValNull), (isNull ? _a : !_a) && res.push(m.get(isValNull));\n        }\n      }\n      return res;\n    }\n    if (null === v || void 0 === v ? 0 : v.$comparator) {\n      return allMapValues(m, 1).filter(v.$op);\n    }\n    store = v.in || v.$in || [v];\n    for (const value of store) {\n      (store = m.get(value)) && res.push(store);\n    }\n    return res;\n  }\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.toJSON = function(store) {\n    return {__type:store.__type, attrs:store.attrs, triples:allMapValues(store.eav, 3), cardinalityInference:store.cardinalityInference, linkIndex:store.linkIndex};\n  };\n  exports.fromJSON = function(storeJSON) {\n    return createStore(storeJSON.attrs, storeJSON.triples, storeJSON.cardinalityInference, storeJSON.linkIndex);\n  };\n  exports.createStore = createStore;\n  exports.allMapValues = allMapValues;\n  exports.getTriples = function(store, [e, a, v]) {\n    var _a, _b;\n    let res = \"\";\n    void 0 !== e && (res += \"e\");\n    void 0 !== a && (res += \"a\");\n    void 0 !== v && (res += \"v\");\n    switch(res) {\n      case \"e\":\n        return store = store.eav.get(e), allMapValues(store, 2);\n      case \"ea\":\n        return store = null === (_a = store.eav.get(e)) || void 0 === _a ? void 0 : _a.get(a), allMapValues(store, 1);\n      case \"eav\":\n        var aMap = null === (_b = store.eav.get(e)) || void 0 === _b ? void 0 : _b.get(a);\n        return aMap ? triplesByValue(store, aMap, v) : [];\n      case \"ev\":\n        a = store.eav.get(e);\n        if (!a) {\n          return [];\n        }\n        var res$jscomp$0 = [];\n        for (aMap of a.values()) {\n          res$jscomp$0.push(...triplesByValue(store, aMap, v));\n        }\n        return res$jscomp$0;\n      case \"a\":\n        return store = store.aev.get(a), allMapValues(store, 2);\n      case \"av\":\n        a = store.aev.get(a);\n        if (!a) {\n          return [];\n        }\n        aMap = [];\n        for (res$jscomp$0 of a.values()) {\n          aMap.push(...triplesByValue(store, res$jscomp$0, v));\n        }\n        return aMap;\n      case \"v\":\n        a = [];\n        for (const eMap of store.eav.values()) {\n          for (const aMap of eMap.values()) {\n            a.push(...triplesByValue(store, aMap, v));\n          }\n        }\n      default:\n        return allMapValues(store.eav, 3);\n    }\n  };\n  exports.getAsObject = function(store, etype, e) {\n    var _a, blobAttrs = store.attrIndexes.blobAttrs.get(etype);\n    etype = {};\n    for (const [label, attr] of blobAttrs.entries()) {\n      blobAttrs = null === (_a = store.eav.get(e)) || void 0 === _a ? void 0 : _a.get(attr.id);\n      blobAttrs = allMapValues(blobAttrs, 1);\n      for (const triple of blobAttrs) {\n        etype[label] = triple[2];\n      }\n    }\n    return etype;\n  };\n  exports.getAttrByFwdIdentName = function(store, inputEtype, inputLabel) {\n    var _a;\n    return null === (_a = store.attrIndexes.forwardIdents.get(inputEtype)) || void 0 === _a ? void 0 : _a.get(inputLabel);\n  };\n  exports.getAttrByReverseIdentName = function(store, inputEtype, inputLabel) {\n    var _a;\n    return null === (_a = store.attrIndexes.revIdents.get(inputEtype)) || void 0 === _a ? void 0 : _a.get(inputLabel);\n  };\n  exports.getPrimaryKeyAttr = function(store, etype) {\n    var _a;\n    const fromPrimary = store.attrIndexes.primaryKeys.get(etype);\n    return fromPrimary ? fromPrimary : null === (_a = store.attrIndexes.forwardIdents.get(etype)) || void 0 === _a ? void 0 : _a.get(\"id\");\n  };\n  exports.transact = function(store, txSteps) {\n    return (0,mutative_1.create)(store, draft => {\n      txSteps.forEach(txStep => {\n        const [action, ...args] = txStep;\n        switch(action) {\n          case \"add-triple\":\n            var _a;\n            if (txStep = resolveLookupRefs(draft, args)) {\n              var [eid, aid, v] = txStep, attr = draft.attrs[aid];\n              if (attr) {\n                var existingTriple = getInMap(draft.eav, [eid, aid, v]);\n                existingTriple = null !== (_a = null === existingTriple || void 0 === existingTriple ? void 0 : existingTriple[3]) && void 0 !== _a ? _a : getCreatedAt(draft, attr, txStep);\n                _a = [eid, aid, v, existingTriple];\n                \"one\" === attr.cardinality ? (setInMap(draft.eav, [eid, aid], new Map([[v, _a]])), setInMap(draft.aev, [aid, eid], new Map([[v, _a]]))) : (setInMap(draft.eav, [eid, aid, v], _a), setInMap(draft.aev, [aid, eid, v], _a));\n                isRef(attr) && setInMap(draft.vae, [v, aid, eid], _a);\n              }\n            }\n            break;\n          case \"deep-merge-triple\":\n            if (_a = resolveLookupRefs(draft, args)) {\n              var [eid$jscomp$0, aid$jscomp$0, update] = _a;\n              if (_a = draft.attrs[aid$jscomp$0]) {\n                if (\"blob\" !== _a[\"value-type\"]) {\n                  throw Error(\"merge operation is not supported for links\");\n                }\n                if (txStep = getInMap(draft.eav, [eid$jscomp$0, aid$jscomp$0])) {\n                  if (txStep = null === (attr = txStep.values().next()) || void 0 === attr ? void 0 : attr.value) {\n                    attr = (0,object_1.immutableDeepMerge)(txStep[2], update), _a = [eid$jscomp$0, aid$jscomp$0, attr, getCreatedAt(draft, _a, txStep)], setInMap(draft.eav, [eid$jscomp$0, aid$jscomp$0], new Map([[attr, _a]]));\n                  }\n                }\n              }\n            }\n            break;\n          case \"retract-triple\":\n            if (_a = resolveLookupRefs(draft, args)) {\n              var [eid$jscomp$1, aid$jscomp$1, v$jscomp$0] = _a;\n              if (_a = draft.attrs[aid$jscomp$1]) {\n                deleteInMap(draft.eav, [eid$jscomp$1, aid$jscomp$1, v$jscomp$0]), deleteInMap(draft.aev, [aid$jscomp$1, eid$jscomp$1, v$jscomp$0]), isRef(_a) && deleteInMap(draft.vae, [v$jscomp$0, aid$jscomp$1, eid$jscomp$1]);\n              }\n            }\n            break;\n          case \"delete-entity\":\n            deleteEntity(draft, args);\n            break;\n          case \"add-attr\":\n            addAttr(draft, args);\n            break;\n          case \"delete-attr\":\n            deleteAttr(draft, args);\n            break;\n          case \"update-attr\":\n            updateAttr(draft, args);\n            break;\n          default:\n            throw Error(`unhandled transaction action: ${action}`);\n        }\n      });\n    });\n  };\n  const mutative_1 = require(\"module$node_modules$mutative$dist$index\"), object_1 = require(\"module$node_modules$$instantdb$core$dist$utils$object\");\n  let _seed = 0;\n};\n","~:source","shadow$provide[\"module$node_modules$$instantdb$core$dist$store\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toJSON = toJSON;\nexports.fromJSON = fromJSON;\nexports.createStore = createStore;\nexports.allMapValues = allMapValues;\nexports.getTriples = getTriples;\nexports.getAsObject = getAsObject;\nexports.getAttrByFwdIdentName = getAttrByFwdIdentName;\nexports.getAttrByReverseIdentName = getAttrByReverseIdentName;\nexports.getPrimaryKeyAttr = getPrimaryKeyAttr;\nexports.transact = transact;\nconst mutative_1 = require(\"mutative\");\nconst object_1 = require(\"./utils/object\");\nfunction hasEA(attr) {\n    return attr['cardinality'] === 'one';\n}\nfunction isRef(attr) {\n    return attr['value-type'] === 'ref';\n}\nfunction isBlob(attr) {\n    return attr['value-type'] === 'blob';\n}\nfunction getAttr(attrs, attrId) {\n    return attrs[attrId];\n}\nfunction getInMap(obj, path) {\n    return path.reduce((acc, key) => acc && acc.get(key), obj);\n}\nfunction deleteInMap(m, path) {\n    if (path.length === 0)\n        throw new Error('path must have at least one element');\n    if (path.length === 1) {\n        m.delete(path[0]);\n        return;\n    }\n    const [head, ...tail] = path;\n    if (!m.has(head))\n        return;\n    deleteInMap(m.get(head), tail);\n}\nfunction setInMap(m, path, value) {\n    if (path.length === 0)\n        throw new Error('path must have at least one element');\n    if (path.length === 1) {\n        m.set(path[0], value);\n        return;\n    }\n    const [head, ...tail] = path;\n    let nextM = m.get(head);\n    if (!nextM) {\n        nextM = new Map();\n        m.set(head, nextM);\n    }\n    setInMap(nextM, tail, value);\n}\nfunction createTripleIndexes(attrs, triples) {\n    const eav = new Map();\n    const aev = new Map();\n    const vae = new Map();\n    for (const triple of triples) {\n        const [eid, aid, v, t] = triple;\n        const attr = getAttr(attrs, aid);\n        if (!attr) {\n            console.warn('no such attr', eid, attrs);\n            continue;\n        }\n        if (isRef(attr)) {\n            setInMap(vae, [v, aid, eid], triple);\n        }\n        setInMap(eav, [eid, aid, v], triple);\n        setInMap(aev, [aid, eid, v], triple);\n    }\n    return { eav, aev, vae };\n}\nfunction createAttrIndexes(attrs) {\n    const blobAttrs = new Map();\n    const primaryKeys = new Map();\n    const forwardIdents = new Map();\n    const revIdents = new Map();\n    for (const attr of Object.values(attrs)) {\n        const fwdIdent = attr['forward-identity'];\n        const [_, fwdEtype, fwdLabel] = fwdIdent;\n        const revIdent = attr['reverse-identity'];\n        setInMap(forwardIdents, [fwdEtype, fwdLabel], attr);\n        if (isBlob(attr)) {\n            setInMap(blobAttrs, [fwdEtype, fwdLabel], attr);\n        }\n        if (attr['primary?']) {\n            setInMap(primaryKeys, [fwdEtype], attr);\n        }\n        if (revIdent) {\n            const [_, revEtype, revLabel] = revIdent;\n            setInMap(revIdents, [revEtype, revLabel], attr);\n        }\n    }\n    return { blobAttrs, primaryKeys, forwardIdents, revIdents };\n}\nfunction toJSON(store) {\n    return {\n        __type: store.__type,\n        attrs: store.attrs,\n        triples: allMapValues(store.eav, 3),\n        cardinalityInference: store.cardinalityInference,\n        linkIndex: store.linkIndex,\n    };\n}\nfunction fromJSON(storeJSON) {\n    return createStore(storeJSON.attrs, storeJSON.triples, storeJSON.cardinalityInference, storeJSON.linkIndex);\n}\nfunction resetAttrIndexes(store) {\n    store.attrIndexes = createAttrIndexes(store.attrs);\n}\nfunction createStore(attrs, triples, enableCardinalityInference, linkIndex) {\n    const store = createTripleIndexes(attrs, triples);\n    store.attrs = attrs;\n    store.attrIndexes = createAttrIndexes(attrs);\n    store.cardinalityInference = enableCardinalityInference;\n    store.linkIndex = linkIndex;\n    store.__type = 'store';\n    return store;\n}\n// We may have local triples with lookup refs in them,\n// we need to convert those lookup refs to eids to insert them\n// into the store. If we can't find the lookup ref locally,\n// then we drop the triple and have to wait for the server response\n// to see the optimistic updates.\nfunction resolveLookupRefs(store, triple) {\n    var _a, _b;\n    let eid;\n    // Check if `e` is a lookup ref\n    if (Array.isArray(triple[0])) {\n        const [a, v] = triple[0];\n        const eMaps = store.aev.get(a);\n        if (!eMaps) {\n            // We don't have the attr, so don't try to add the\n            // triple to the store\n            return null;\n        }\n        // This would be a lot more efficient with a ave index\n        const triples = allMapValues(eMaps, 2);\n        eid = (_a = triples.find((x) => x[2] === v)) === null || _a === void 0 ? void 0 : _a[0];\n    }\n    else {\n        eid = triple[0];\n    }\n    if (!eid) {\n        // We don't know the eid that the ref refers to, so\n        // we can't add the triple to the store.\n        return null;\n    }\n    // Check if v is a lookup ref\n    const lookupV = triple[2];\n    if (Array.isArray(lookupV) &&\n        lookupV.length === 2 &&\n        store.aev.get(lookupV[0])) {\n        const [a, v] = lookupV;\n        const eMaps = store.aev.get(a);\n        if (!eMaps) {\n            // We don't have the attr, so don't try to add the\n            // triple to the store\n            return null;\n        }\n        const triples = allMapValues(eMaps, 2);\n        const value = (_b = triples.find((x) => x[2] === v)) === null || _b === void 0 ? void 0 : _b[0];\n        if (!value) {\n            return null;\n        }\n        const [_e, aid, _v, ...rest] = triple;\n        return [eid, aid, value, ...rest];\n    }\n    else {\n        const [_, ...rest] = triple;\n        return [eid, ...rest];\n    }\n}\nfunction retractTriple(store, rawTriple) {\n    const triple = resolveLookupRefs(store, rawTriple);\n    if (!triple) {\n        return;\n    }\n    const [eid, aid, v] = triple;\n    const attr = getAttr(store.attrs, aid);\n    if (!attr) {\n        return;\n    }\n    deleteInMap(store.eav, [eid, aid, v]);\n    deleteInMap(store.aev, [aid, eid, v]);\n    if (isRef(attr)) {\n        deleteInMap(store.vae, [v, aid, eid]);\n    }\n}\nlet _seed = 0;\nfunction getCreatedAt(store, attr, triple) {\n    const [eid, aid, v] = triple;\n    let createdAt;\n    const t = getInMap(store.ea, [eid, aid, v]);\n    if (t) {\n        createdAt = t[3];\n    }\n    /**\n     * (XXX)\n     * Two hacks here, for generating a `createdAt`\n     *\n     * 1. We multiply Date.now() by 10, to make sure that\n     *  `createdAt` is always greater than anything the server\n     *   could return\n     *\n     *   We do this because right now we know we _only_ insert\n     *   triples as optimistic updates.\n     *\n     * 2. We increment by `_seed`, to make sure there are no\n     *    two triples with the same `createdAt`. This is\n     *    done to make tests more predictable.\n     *\n     * We may need to rethink this. Because we * 10, we can't\n     * use this value as an _actual_ `createdAt` timestamp.\n     * Eventually we may want too though; For example, we could\n     * use `createdAt` for each triple, to infer a `createdAt` and\n     * `updatedAt` value for each object.\n     */\n    return createdAt || Date.now() * 10 + _seed++;\n}\nfunction addTriple(store, rawTriple) {\n    var _a;\n    const triple = resolveLookupRefs(store, rawTriple);\n    if (!triple) {\n        return;\n    }\n    const [eid, aid, v] = triple;\n    const attr = getAttr(store.attrs, aid);\n    if (!attr) {\n        // (XXX): Due to the way we're handling attrs, it's\n        // possible to enter a state where we receive a triple without an attr.\n        // See: https://github.com/jsventures/instant-local/pull/132 for details.\n        // For now, if we receive a command without an attr, we no-op.\n        return;\n    }\n    const existingTriple = getInMap(store.eav, [eid, aid, v]);\n    // Reuse the created_at for a triple if it's already in the store.\n    // Prevents updates from temporarily pushing an entity to the top\n    // while waiting for the server response.\n    const t = (_a = existingTriple === null || existingTriple === void 0 ? void 0 : existingTriple[3]) !== null && _a !== void 0 ? _a : getCreatedAt(store, attr, triple);\n    const enhancedTriple = [eid, aid, v, t];\n    if (hasEA(attr)) {\n        setInMap(store.eav, [eid, aid], new Map([[v, enhancedTriple]]));\n        setInMap(store.aev, [aid, eid], new Map([[v, enhancedTriple]]));\n    }\n    else {\n        setInMap(store.eav, [eid, aid, v], enhancedTriple);\n        setInMap(store.aev, [aid, eid, v], enhancedTriple);\n    }\n    if (isRef(attr)) {\n        setInMap(store.vae, [v, aid, eid], enhancedTriple);\n    }\n}\nfunction mergeTriple(store, rawTriple) {\n    var _a;\n    const triple = resolveLookupRefs(store, rawTriple);\n    if (!triple) {\n        return;\n    }\n    const [eid, aid, update] = triple;\n    const attr = getAttr(store.attrs, aid);\n    if (!attr)\n        return;\n    if (!isBlob(attr))\n        throw new Error('merge operation is not supported for links');\n    const eavValuesMap = getInMap(store.eav, [eid, aid]);\n    if (!eavValuesMap)\n        return;\n    const currentTriple = (_a = eavValuesMap.values().next()) === null || _a === void 0 ? void 0 : _a.value;\n    if (!currentTriple)\n        return;\n    const currentValue = currentTriple[2];\n    const updatedValue = (0, object_1.immutableDeepMerge)(currentValue, update);\n    const enhancedTriple = [\n        eid,\n        aid,\n        updatedValue,\n        getCreatedAt(store, attr, currentTriple),\n    ];\n    setInMap(store.eav, [eid, aid], new Map([[updatedValue, enhancedTriple]]));\n}\nfunction deleteEntity(store, args) {\n    var _a, _b;\n    const [lookup, etype] = args;\n    const triple = resolveLookupRefs(store, [lookup]);\n    if (!triple) {\n        return;\n    }\n    const [id] = triple;\n    // delete forward links and attributes + cardinality one links\n    const eMap = store.eav.get(id);\n    if (eMap) {\n        for (const a of eMap.keys()) {\n            const attr = store.attrs[a];\n            // delete cascade refs\n            if (attr && attr['on-delete-reverse'] === 'cascade') {\n                allMapValues(eMap.get(a), 1).forEach(([e, a, v]) => { var _a; return deleteEntity(store, [v, (_a = attr['reverse-identity']) === null || _a === void 0 ? void 0 : _a[1]]); });\n            }\n            if (\n            // Fall back to deleting everything if we've rehydrated tx-steps from\n            // the store that didn't set `etype` in deleteEntity\n            !etype ||\n                // If we don't know about the attr, let's just get rid of it\n                !attr ||\n                // Make sure it matches the etype\n                ((_a = attr['forward-identity']) === null || _a === void 0 ? void 0 : _a[1]) === etype) {\n                deleteInMap(store.aev, [a, id]);\n                deleteInMap(store.eav, [id, a]);\n            }\n        }\n        // Clear out the eav index for `id` if we deleted all of the attributes\n        if (eMap.size === 0) {\n            deleteInMap(store.eav, [id]);\n        }\n    }\n    // delete reverse links\n    const vaeTriples = store.vae.get(id) && allMapValues(store.vae.get(id), 2);\n    if (vaeTriples) {\n        vaeTriples.forEach((triple) => {\n            var _a, _b;\n            const [e, a, v] = triple;\n            const attr = store.attrs[a];\n            if (!etype || !attr || ((_a = attr['reverse-identity']) === null || _a === void 0 ? void 0 : _a[1]) === etype) {\n                deleteInMap(store.eav, [e, a, v]);\n                deleteInMap(store.aev, [a, e, v]);\n                deleteInMap(store.vae, [v, a, e]);\n            }\n            if (attr && attr['on-delete'] === 'cascade') {\n                deleteEntity(store, [e, (_b = attr['forward-identity']) === null || _b === void 0 ? void 0 : _b[1]]);\n            }\n        });\n    }\n    // Clear out vae index for `id` if we deleted all the reverse attributes\n    if (((_b = store.vae.get(id)) === null || _b === void 0 ? void 0 : _b.size) === 0) {\n        deleteInMap(store.vae, [id]);\n    }\n}\n// (XXX): Whenever we change/delete attrs,\n// We indiscriminately reset the index map.\n// There are lots of opportunities for optimization:\n// * We _only_ need to run this indexes change. We could detect that\n// * We could batch this reset at the end\n// * We could add an ave index for all triples, so removing the\n//   right triples is easy and fast.\nfunction resetIndexMap(store, newTriples) {\n    const newIndexMap = createTripleIndexes(store.attrs, newTriples);\n    Object.keys(newIndexMap).forEach((key) => {\n        store[key] = newIndexMap[key];\n    });\n}\nfunction addAttr(store, [attr]) {\n    store.attrs[attr.id] = attr;\n    resetAttrIndexes(store);\n}\nfunction getAllTriples(store) {\n    return allMapValues(store.eav, 3);\n}\nfunction deleteAttr(store, [id]) {\n    if (!store.attrs[id])\n        return;\n    const newTriples = getAllTriples(store).filter(([_, aid]) => aid !== id);\n    delete store.attrs[id];\n    resetAttrIndexes(store);\n    resetIndexMap(store, newTriples);\n}\nfunction updateAttr(store, [partialAttr]) {\n    const attr = store.attrs[partialAttr.id];\n    if (!attr)\n        return;\n    store.attrs[partialAttr.id] = Object.assign(Object.assign({}, attr), partialAttr);\n    resetAttrIndexes(store);\n    resetIndexMap(store, getAllTriples(store));\n}\nfunction applyTxStep(store, txStep) {\n    const [action, ...args] = txStep;\n    switch (action) {\n        case 'add-triple':\n            addTriple(store, args);\n            break;\n        case 'deep-merge-triple':\n            mergeTriple(store, args);\n            break;\n        case 'retract-triple':\n            retractTriple(store, args);\n            break;\n        case 'delete-entity':\n            deleteEntity(store, args);\n            break;\n        case 'add-attr':\n            addAttr(store, args);\n            break;\n        case 'delete-attr':\n            deleteAttr(store, args);\n            break;\n        case 'update-attr':\n            updateAttr(store, args);\n            break;\n        default:\n            throw new Error(`unhandled transaction action: ${action}`);\n    }\n}\nfunction allMapValues(m, level, res = []) {\n    if (!m) {\n        return res;\n    }\n    if (level === 0) {\n        return res;\n    }\n    if (level === 1) {\n        for (const v of m.values()) {\n            res.push(v);\n        }\n        return res;\n    }\n    for (const v of m.values()) {\n        allMapValues(v, level - 1, res);\n    }\n    return res;\n}\nfunction triplesByValue(store, m, v) {\n    var _a, _b;\n    const res = [];\n    if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$not')) {\n        for (const candidate of m.keys()) {\n            if (v.$not !== candidate) {\n                res.push(m.get(candidate));\n            }\n        }\n        return res;\n    }\n    if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$isNull')) {\n        const { attrId, isNull, reverse } = v.$isNull;\n        if (reverse) {\n            for (const candidate of m.keys()) {\n                const vMap = store.vae.get(candidate);\n                const isValNull = !vMap || ((_a = vMap.get(attrId)) === null || _a === void 0 ? void 0 : _a.get(null)) || !vMap.get(attrId);\n                if (isNull ? isValNull : !isValNull) {\n                    res.push(m.get(candidate));\n                }\n            }\n        }\n        else {\n            const aMap = store.aev.get(attrId);\n            for (const candidate of m.keys()) {\n                const isValNull = !aMap || ((_b = aMap.get(candidate)) === null || _b === void 0 ? void 0 : _b.get(null)) || !aMap.get(candidate);\n                if (isNull ? isValNull : !isValNull) {\n                    res.push(m.get(candidate));\n                }\n            }\n        }\n        return res;\n    }\n    if (v === null || v === void 0 ? void 0 : v.$comparator) {\n        // TODO: A sorted index would be nice here\n        return allMapValues(m, 1).filter(v.$op);\n    }\n    const values = v.in || v.$in || [v];\n    for (const value of values) {\n        const triple = m.get(value);\n        if (triple) {\n            res.push(triple);\n        }\n    }\n    return res;\n}\n// A poor man's pattern matching\n// Returns either eav, ea, ev, av, v, or ''\nfunction whichIdx(e, a, v) {\n    let res = '';\n    if (e !== undefined) {\n        res += 'e';\n    }\n    if (a !== undefined) {\n        res += 'a';\n    }\n    if (v !== undefined) {\n        res += 'v';\n    }\n    return res;\n}\nfunction getTriples(store, [e, a, v]) {\n    var _a, _b;\n    const idx = whichIdx(e, a, v);\n    switch (idx) {\n        case 'e': {\n            const eMap = store.eav.get(e);\n            return allMapValues(eMap, 2);\n        }\n        case 'ea': {\n            const aMap = (_a = store.eav.get(e)) === null || _a === void 0 ? void 0 : _a.get(a);\n            return allMapValues(aMap, 1);\n        }\n        case 'eav': {\n            const aMap = (_b = store.eav.get(e)) === null || _b === void 0 ? void 0 : _b.get(a);\n            if (!aMap) {\n                return [];\n            }\n            return triplesByValue(store, aMap, v);\n        }\n        case 'ev': {\n            const eMap = store.eav.get(e);\n            if (!eMap) {\n                return [];\n            }\n            const res = [];\n            for (const aMap of eMap.values()) {\n                res.push(...triplesByValue(store, aMap, v));\n            }\n            return res;\n        }\n        case 'a': {\n            const aMap = store.aev.get(a);\n            return allMapValues(aMap, 2);\n        }\n        case 'av': {\n            const aMap = store.aev.get(a);\n            if (!aMap) {\n                return [];\n            }\n            const res = [];\n            for (const eMap of aMap.values()) {\n                res.push(...triplesByValue(store, eMap, v));\n            }\n            return res;\n        }\n        case 'v': {\n            const res = [];\n            for (const eMap of store.eav.values()) {\n                for (const aMap of eMap.values()) {\n                    res.push(...triplesByValue(store, aMap, v));\n                }\n            }\n        }\n        default: {\n            return allMapValues(store.eav, 3);\n        }\n    }\n}\nfunction getAsObject(store, etype, e) {\n    var _a;\n    const blobAttrs = store.attrIndexes.blobAttrs.get(etype);\n    const obj = {};\n    for (const [label, attr] of blobAttrs.entries()) {\n        const aMap = (_a = store.eav.get(e)) === null || _a === void 0 ? void 0 : _a.get(attr.id);\n        const triples = allMapValues(aMap, 1);\n        for (const triple of triples) {\n            obj[label] = triple[2];\n        }\n    }\n    return obj;\n}\nfunction getAttrByFwdIdentName(store, inputEtype, inputLabel) {\n    var _a;\n    return (_a = store.attrIndexes.forwardIdents.get(inputEtype)) === null || _a === void 0 ? void 0 : _a.get(inputLabel);\n}\nfunction getAttrByReverseIdentName(store, inputEtype, inputLabel) {\n    var _a;\n    return (_a = store.attrIndexes.revIdents.get(inputEtype)) === null || _a === void 0 ? void 0 : _a.get(inputLabel);\n}\nfunction getPrimaryKeyAttr(store, etype) {\n    var _a;\n    const fromPrimary = store.attrIndexes.primaryKeys.get(etype);\n    if (fromPrimary) {\n        return fromPrimary;\n    }\n    return (_a = store.attrIndexes.forwardIdents.get(etype)) === null || _a === void 0 ? void 0 : _a.get('id');\n}\nfunction transact(store, txSteps) {\n    return (0, mutative_1.create)(store, (draft) => {\n        txSteps.forEach((txStep) => {\n            applyTxStep(draft, txStep);\n        });\n    });\n}\n//# sourceMappingURL=store.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mutative$dist$index","~$shadow.js","~$module$node_modules$$instantdb$core$dist$utils$object"]],"~:properties",["^5",["revIdents","getAsObject","attrs","triples","eav","blobAttrs","fromJSON","attrIndexes","getAttrByReverseIdentName","__type","forwardIdents","linkIndex","__esModule","allMapValues","value","createStore","getPrimaryKeyAttr","cardinalityInference","getAttrByFwdIdentName","transact","primaryKeys","aev","vae","getTriples","toJSON"]],"~:compiled-at",1756239699945,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$instantdb$core$dist$store.js\",\n\"lineCount\":343,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@instantdb/core/dist/store.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$instantdb$core$dist$store\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.toJSON = toJSON;\\nexports.fromJSON = fromJSON;\\nexports.createStore = createStore;\\nexports.allMapValues = allMapValues;\\nexports.getTriples = getTriples;\\nexports.getAsObject = getAsObject;\\nexports.getAttrByFwdIdentName = getAttrByFwdIdentName;\\nexports.getAttrByReverseIdentName = getAttrByReverseIdentName;\\nexports.getPrimaryKeyAttr = getPrimaryKeyAttr;\\nexports.transact = transact;\\nconst mutative_1 = require(\\\"mutative\\\");\\nconst object_1 = require(\\\"./utils/object\\\");\\nfunction hasEA(attr) {\\n    return attr['cardinality'] === 'one';\\n}\\nfunction isRef(attr) {\\n    return attr['value-type'] === 'ref';\\n}\\nfunction isBlob(attr) {\\n    return attr['value-type'] === 'blob';\\n}\\nfunction getAttr(attrs, attrId) {\\n    return attrs[attrId];\\n}\\nfunction getInMap(obj, path) {\\n    return path.reduce((acc, key) => acc && acc.get(key), obj);\\n}\\nfunction deleteInMap(m, path) {\\n    if (path.length === 0)\\n        throw new Error('path must have at least one element');\\n    if (path.length === 1) {\\n        m.delete(path[0]);\\n        return;\\n    }\\n    const [head, ...tail] = path;\\n    if (!m.has(head))\\n        return;\\n    deleteInMap(m.get(head), tail);\\n}\\nfunction setInMap(m, path, value) {\\n    if (path.length === 0)\\n        throw new Error('path must have at least one element');\\n    if (path.length === 1) {\\n        m.set(path[0], value);\\n        return;\\n    }\\n    const [head, ...tail] = path;\\n    let nextM = m.get(head);\\n    if (!nextM) {\\n        nextM = new Map();\\n        m.set(head, nextM);\\n    }\\n    setInMap(nextM, tail, value);\\n}\\nfunction createTripleIndexes(attrs, triples) {\\n    const eav = new Map();\\n    const aev = new Map();\\n    const vae = new Map();\\n    for (const triple of triples) {\\n        const [eid, aid, v, t] = triple;\\n        const attr = getAttr(attrs, aid);\\n        if (!attr) {\\n            console.warn('no such attr', eid, attrs);\\n            continue;\\n        }\\n        if (isRef(attr)) {\\n            setInMap(vae, [v, aid, eid], triple);\\n        }\\n        setInMap(eav, [eid, aid, v], triple);\\n        setInMap(aev, [aid, eid, v], triple);\\n    }\\n    return { eav, aev, vae };\\n}\\nfunction createAttrIndexes(attrs) {\\n    const blobAttrs = new Map();\\n    const primaryKeys = new Map();\\n    const forwardIdents = new Map();\\n    const revIdents = new Map();\\n    for (const attr of Object.values(attrs)) {\\n        const fwdIdent = attr['forward-identity'];\\n        const [_, fwdEtype, fwdLabel] = fwdIdent;\\n        const revIdent = attr['reverse-identity'];\\n        setInMap(forwardIdents, [fwdEtype, fwdLabel], attr);\\n        if (isBlob(attr)) {\\n            setInMap(blobAttrs, [fwdEtype, fwdLabel], attr);\\n        }\\n        if (attr['primary?']) {\\n            setInMap(primaryKeys, [fwdEtype], attr);\\n        }\\n        if (revIdent) {\\n            const [_, revEtype, revLabel] = revIdent;\\n            setInMap(revIdents, [revEtype, revLabel], attr);\\n        }\\n    }\\n    return { blobAttrs, primaryKeys, forwardIdents, revIdents };\\n}\\nfunction toJSON(store) {\\n    return {\\n        __type: store.__type,\\n        attrs: store.attrs,\\n        triples: allMapValues(store.eav, 3),\\n        cardinalityInference: store.cardinalityInference,\\n        linkIndex: store.linkIndex,\\n    };\\n}\\nfunction fromJSON(storeJSON) {\\n    return createStore(storeJSON.attrs, storeJSON.triples, storeJSON.cardinalityInference, storeJSON.linkIndex);\\n}\\nfunction resetAttrIndexes(store) {\\n    store.attrIndexes = createAttrIndexes(store.attrs);\\n}\\nfunction createStore(attrs, triples, enableCardinalityInference, linkIndex) {\\n    const store = createTripleIndexes(attrs, triples);\\n    store.attrs = attrs;\\n    store.attrIndexes = createAttrIndexes(attrs);\\n    store.cardinalityInference = enableCardinalityInference;\\n    store.linkIndex = linkIndex;\\n    store.__type = 'store';\\n    return store;\\n}\\n// We may have local triples with lookup refs in them,\\n// we need to convert those lookup refs to eids to insert them\\n// into the store. If we can't find the lookup ref locally,\\n// then we drop the triple and have to wait for the server response\\n// to see the optimistic updates.\\nfunction resolveLookupRefs(store, triple) {\\n    var _a, _b;\\n    let eid;\\n    // Check if `e` is a lookup ref\\n    if (Array.isArray(triple[0])) {\\n        const [a, v] = triple[0];\\n        const eMaps = store.aev.get(a);\\n        if (!eMaps) {\\n            // We don't have the attr, so don't try to add the\\n            // triple to the store\\n            return null;\\n        }\\n        // This would be a lot more efficient with a ave index\\n        const triples = allMapValues(eMaps, 2);\\n        eid = (_a = triples.find((x) => x[2] === v)) === null || _a === void 0 ? void 0 : _a[0];\\n    }\\n    else {\\n        eid = triple[0];\\n    }\\n    if (!eid) {\\n        // We don't know the eid that the ref refers to, so\\n        // we can't add the triple to the store.\\n        return null;\\n    }\\n    // Check if v is a lookup ref\\n    const lookupV = triple[2];\\n    if (Array.isArray(lookupV) &&\\n        lookupV.length === 2 &&\\n        store.aev.get(lookupV[0])) {\\n        const [a, v] = lookupV;\\n        const eMaps = store.aev.get(a);\\n        if (!eMaps) {\\n            // We don't have the attr, so don't try to add the\\n            // triple to the store\\n            return null;\\n        }\\n        const triples = allMapValues(eMaps, 2);\\n        const value = (_b = triples.find((x) => x[2] === v)) === null || _b === void 0 ? void 0 : _b[0];\\n        if (!value) {\\n            return null;\\n        }\\n        const [_e, aid, _v, ...rest] = triple;\\n        return [eid, aid, value, ...rest];\\n    }\\n    else {\\n        const [_, ...rest] = triple;\\n        return [eid, ...rest];\\n    }\\n}\\nfunction retractTriple(store, rawTriple) {\\n    const triple = resolveLookupRefs(store, rawTriple);\\n    if (!triple) {\\n        return;\\n    }\\n    const [eid, aid, v] = triple;\\n    const attr = getAttr(store.attrs, aid);\\n    if (!attr) {\\n        return;\\n    }\\n    deleteInMap(store.eav, [eid, aid, v]);\\n    deleteInMap(store.aev, [aid, eid, v]);\\n    if (isRef(attr)) {\\n        deleteInMap(store.vae, [v, aid, eid]);\\n    }\\n}\\nlet _seed = 0;\\nfunction getCreatedAt(store, attr, triple) {\\n    const [eid, aid, v] = triple;\\n    let createdAt;\\n    const t = getInMap(store.ea, [eid, aid, v]);\\n    if (t) {\\n        createdAt = t[3];\\n    }\\n    /**\\n     * (XXX)\\n     * Two hacks here, for generating a `createdAt`\\n     *\\n     * 1. We multiply Date.now() by 10, to make sure that\\n     *  `createdAt` is always greater than anything the server\\n     *   could return\\n     *\\n     *   We do this because right now we know we _only_ insert\\n     *   triples as optimistic updates.\\n     *\\n     * 2. We increment by `_seed`, to make sure there are no\\n     *    two triples with the same `createdAt`. This is\\n     *    done to make tests more predictable.\\n     *\\n     * We may need to rethink this. Because we * 10, we can't\\n     * use this value as an _actual_ `createdAt` timestamp.\\n     * Eventually we may want too though; For example, we could\\n     * use `createdAt` for each triple, to infer a `createdAt` and\\n     * `updatedAt` value for each object.\\n     */\\n    return createdAt || Date.now() * 10 + _seed++;\\n}\\nfunction addTriple(store, rawTriple) {\\n    var _a;\\n    const triple = resolveLookupRefs(store, rawTriple);\\n    if (!triple) {\\n        return;\\n    }\\n    const [eid, aid, v] = triple;\\n    const attr = getAttr(store.attrs, aid);\\n    if (!attr) {\\n        // (XXX): Due to the way we're handling attrs, it's\\n        // possible to enter a state where we receive a triple without an attr.\\n        // See: https://github.com/jsventures/instant-local/pull/132 for details.\\n        // For now, if we receive a command without an attr, we no-op.\\n        return;\\n    }\\n    const existingTriple = getInMap(store.eav, [eid, aid, v]);\\n    // Reuse the created_at for a triple if it's already in the store.\\n    // Prevents updates from temporarily pushing an entity to the top\\n    // while waiting for the server response.\\n    const t = (_a = existingTriple === null || existingTriple === void 0 ? void 0 : existingTriple[3]) !== null && _a !== void 0 ? _a : getCreatedAt(store, attr, triple);\\n    const enhancedTriple = [eid, aid, v, t];\\n    if (hasEA(attr)) {\\n        setInMap(store.eav, [eid, aid], new Map([[v, enhancedTriple]]));\\n        setInMap(store.aev, [aid, eid], new Map([[v, enhancedTriple]]));\\n    }\\n    else {\\n        setInMap(store.eav, [eid, aid, v], enhancedTriple);\\n        setInMap(store.aev, [aid, eid, v], enhancedTriple);\\n    }\\n    if (isRef(attr)) {\\n        setInMap(store.vae, [v, aid, eid], enhancedTriple);\\n    }\\n}\\nfunction mergeTriple(store, rawTriple) {\\n    var _a;\\n    const triple = resolveLookupRefs(store, rawTriple);\\n    if (!triple) {\\n        return;\\n    }\\n    const [eid, aid, update] = triple;\\n    const attr = getAttr(store.attrs, aid);\\n    if (!attr)\\n        return;\\n    if (!isBlob(attr))\\n        throw new Error('merge operation is not supported for links');\\n    const eavValuesMap = getInMap(store.eav, [eid, aid]);\\n    if (!eavValuesMap)\\n        return;\\n    const currentTriple = (_a = eavValuesMap.values().next()) === null || _a === void 0 ? void 0 : _a.value;\\n    if (!currentTriple)\\n        return;\\n    const currentValue = currentTriple[2];\\n    const updatedValue = (0, object_1.immutableDeepMerge)(currentValue, update);\\n    const enhancedTriple = [\\n        eid,\\n        aid,\\n        updatedValue,\\n        getCreatedAt(store, attr, currentTriple),\\n    ];\\n    setInMap(store.eav, [eid, aid], new Map([[updatedValue, enhancedTriple]]));\\n}\\nfunction deleteEntity(store, args) {\\n    var _a, _b;\\n    const [lookup, etype] = args;\\n    const triple = resolveLookupRefs(store, [lookup]);\\n    if (!triple) {\\n        return;\\n    }\\n    const [id] = triple;\\n    // delete forward links and attributes + cardinality one links\\n    const eMap = store.eav.get(id);\\n    if (eMap) {\\n        for (const a of eMap.keys()) {\\n            const attr = store.attrs[a];\\n            // delete cascade refs\\n            if (attr && attr['on-delete-reverse'] === 'cascade') {\\n                allMapValues(eMap.get(a), 1).forEach(([e, a, v]) => { var _a; return deleteEntity(store, [v, (_a = attr['reverse-identity']) === null || _a === void 0 ? void 0 : _a[1]]); });\\n            }\\n            if (\\n            // Fall back to deleting everything if we've rehydrated tx-steps from\\n            // the store that didn't set `etype` in deleteEntity\\n            !etype ||\\n                // If we don't know about the attr, let's just get rid of it\\n                !attr ||\\n                // Make sure it matches the etype\\n                ((_a = attr['forward-identity']) === null || _a === void 0 ? void 0 : _a[1]) === etype) {\\n                deleteInMap(store.aev, [a, id]);\\n                deleteInMap(store.eav, [id, a]);\\n            }\\n        }\\n        // Clear out the eav index for `id` if we deleted all of the attributes\\n        if (eMap.size === 0) {\\n            deleteInMap(store.eav, [id]);\\n        }\\n    }\\n    // delete reverse links\\n    const vaeTriples = store.vae.get(id) && allMapValues(store.vae.get(id), 2);\\n    if (vaeTriples) {\\n        vaeTriples.forEach((triple) => {\\n            var _a, _b;\\n            const [e, a, v] = triple;\\n            const attr = store.attrs[a];\\n            if (!etype || !attr || ((_a = attr['reverse-identity']) === null || _a === void 0 ? void 0 : _a[1]) === etype) {\\n                deleteInMap(store.eav, [e, a, v]);\\n                deleteInMap(store.aev, [a, e, v]);\\n                deleteInMap(store.vae, [v, a, e]);\\n            }\\n            if (attr && attr['on-delete'] === 'cascade') {\\n                deleteEntity(store, [e, (_b = attr['forward-identity']) === null || _b === void 0 ? void 0 : _b[1]]);\\n            }\\n        });\\n    }\\n    // Clear out vae index for `id` if we deleted all the reverse attributes\\n    if (((_b = store.vae.get(id)) === null || _b === void 0 ? void 0 : _b.size) === 0) {\\n        deleteInMap(store.vae, [id]);\\n    }\\n}\\n// (XXX): Whenever we change/delete attrs,\\n// We indiscriminately reset the index map.\\n// There are lots of opportunities for optimization:\\n// * We _only_ need to run this indexes change. We could detect that\\n// * We could batch this reset at the end\\n// * We could add an ave index for all triples, so removing the\\n//   right triples is easy and fast.\\nfunction resetIndexMap(store, newTriples) {\\n    const newIndexMap = createTripleIndexes(store.attrs, newTriples);\\n    Object.keys(newIndexMap).forEach((key) => {\\n        store[key] = newIndexMap[key];\\n    });\\n}\\nfunction addAttr(store, [attr]) {\\n    store.attrs[attr.id] = attr;\\n    resetAttrIndexes(store);\\n}\\nfunction getAllTriples(store) {\\n    return allMapValues(store.eav, 3);\\n}\\nfunction deleteAttr(store, [id]) {\\n    if (!store.attrs[id])\\n        return;\\n    const newTriples = getAllTriples(store).filter(([_, aid]) => aid !== id);\\n    delete store.attrs[id];\\n    resetAttrIndexes(store);\\n    resetIndexMap(store, newTriples);\\n}\\nfunction updateAttr(store, [partialAttr]) {\\n    const attr = store.attrs[partialAttr.id];\\n    if (!attr)\\n        return;\\n    store.attrs[partialAttr.id] = Object.assign(Object.assign({}, attr), partialAttr);\\n    resetAttrIndexes(store);\\n    resetIndexMap(store, getAllTriples(store));\\n}\\nfunction applyTxStep(store, txStep) {\\n    const [action, ...args] = txStep;\\n    switch (action) {\\n        case 'add-triple':\\n            addTriple(store, args);\\n            break;\\n        case 'deep-merge-triple':\\n            mergeTriple(store, args);\\n            break;\\n        case 'retract-triple':\\n            retractTriple(store, args);\\n            break;\\n        case 'delete-entity':\\n            deleteEntity(store, args);\\n            break;\\n        case 'add-attr':\\n            addAttr(store, args);\\n            break;\\n        case 'delete-attr':\\n            deleteAttr(store, args);\\n            break;\\n        case 'update-attr':\\n            updateAttr(store, args);\\n            break;\\n        default:\\n            throw new Error(`unhandled transaction action: ${action}`);\\n    }\\n}\\nfunction allMapValues(m, level, res = []) {\\n    if (!m) {\\n        return res;\\n    }\\n    if (level === 0) {\\n        return res;\\n    }\\n    if (level === 1) {\\n        for (const v of m.values()) {\\n            res.push(v);\\n        }\\n        return res;\\n    }\\n    for (const v of m.values()) {\\n        allMapValues(v, level - 1, res);\\n    }\\n    return res;\\n}\\nfunction triplesByValue(store, m, v) {\\n    var _a, _b;\\n    const res = [];\\n    if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$not')) {\\n        for (const candidate of m.keys()) {\\n            if (v.$not !== candidate) {\\n                res.push(m.get(candidate));\\n            }\\n        }\\n        return res;\\n    }\\n    if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$isNull')) {\\n        const { attrId, isNull, reverse } = v.$isNull;\\n        if (reverse) {\\n            for (const candidate of m.keys()) {\\n                const vMap = store.vae.get(candidate);\\n                const isValNull = !vMap || ((_a = vMap.get(attrId)) === null || _a === void 0 ? void 0 : _a.get(null)) || !vMap.get(attrId);\\n                if (isNull ? isValNull : !isValNull) {\\n                    res.push(m.get(candidate));\\n                }\\n            }\\n        }\\n        else {\\n            const aMap = store.aev.get(attrId);\\n            for (const candidate of m.keys()) {\\n                const isValNull = !aMap || ((_b = aMap.get(candidate)) === null || _b === void 0 ? void 0 : _b.get(null)) || !aMap.get(candidate);\\n                if (isNull ? isValNull : !isValNull) {\\n                    res.push(m.get(candidate));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    if (v === null || v === void 0 ? void 0 : v.$comparator) {\\n        // TODO: A sorted index would be nice here\\n        return allMapValues(m, 1).filter(v.$op);\\n    }\\n    const values = v.in || v.$in || [v];\\n    for (const value of values) {\\n        const triple = m.get(value);\\n        if (triple) {\\n            res.push(triple);\\n        }\\n    }\\n    return res;\\n}\\n// A poor man's pattern matching\\n// Returns either eav, ea, ev, av, v, or ''\\nfunction whichIdx(e, a, v) {\\n    let res = '';\\n    if (e !== undefined) {\\n        res += 'e';\\n    }\\n    if (a !== undefined) {\\n        res += 'a';\\n    }\\n    if (v !== undefined) {\\n        res += 'v';\\n    }\\n    return res;\\n}\\nfunction getTriples(store, [e, a, v]) {\\n    var _a, _b;\\n    const idx = whichIdx(e, a, v);\\n    switch (idx) {\\n        case 'e': {\\n            const eMap = store.eav.get(e);\\n            return allMapValues(eMap, 2);\\n        }\\n        case 'ea': {\\n            const aMap = (_a = store.eav.get(e)) === null || _a === void 0 ? void 0 : _a.get(a);\\n            return allMapValues(aMap, 1);\\n        }\\n        case 'eav': {\\n            const aMap = (_b = store.eav.get(e)) === null || _b === void 0 ? void 0 : _b.get(a);\\n            if (!aMap) {\\n                return [];\\n            }\\n            return triplesByValue(store, aMap, v);\\n        }\\n        case 'ev': {\\n            const eMap = store.eav.get(e);\\n            if (!eMap) {\\n                return [];\\n            }\\n            const res = [];\\n            for (const aMap of eMap.values()) {\\n                res.push(...triplesByValue(store, aMap, v));\\n            }\\n            return res;\\n        }\\n        case 'a': {\\n            const aMap = store.aev.get(a);\\n            return allMapValues(aMap, 2);\\n        }\\n        case 'av': {\\n            const aMap = store.aev.get(a);\\n            if (!aMap) {\\n                return [];\\n            }\\n            const res = [];\\n            for (const eMap of aMap.values()) {\\n                res.push(...triplesByValue(store, eMap, v));\\n            }\\n            return res;\\n        }\\n        case 'v': {\\n            const res = [];\\n            for (const eMap of store.eav.values()) {\\n                for (const aMap of eMap.values()) {\\n                    res.push(...triplesByValue(store, aMap, v));\\n                }\\n            }\\n        }\\n        default: {\\n            return allMapValues(store.eav, 3);\\n        }\\n    }\\n}\\nfunction getAsObject(store, etype, e) {\\n    var _a;\\n    const blobAttrs = store.attrIndexes.blobAttrs.get(etype);\\n    const obj = {};\\n    for (const [label, attr] of blobAttrs.entries()) {\\n        const aMap = (_a = store.eav.get(e)) === null || _a === void 0 ? void 0 : _a.get(attr.id);\\n        const triples = allMapValues(aMap, 1);\\n        for (const triple of triples) {\\n            obj[label] = triple[2];\\n        }\\n    }\\n    return obj;\\n}\\nfunction getAttrByFwdIdentName(store, inputEtype, inputLabel) {\\n    var _a;\\n    return (_a = store.attrIndexes.forwardIdents.get(inputEtype)) === null || _a === void 0 ? void 0 : _a.get(inputLabel);\\n}\\nfunction getAttrByReverseIdentName(store, inputEtype, inputLabel) {\\n    var _a;\\n    return (_a = store.attrIndexes.revIdents.get(inputEtype)) === null || _a === void 0 ? void 0 : _a.get(inputLabel);\\n}\\nfunction getPrimaryKeyAttr(store, etype) {\\n    var _a;\\n    const fromPrimary = store.attrIndexes.primaryKeys.get(etype);\\n    if (fromPrimary) {\\n        return fromPrimary;\\n    }\\n    return (_a = store.attrIndexes.forwardIdents.get(etype)) === null || _a === void 0 ? void 0 : _a.get('id');\\n}\\nfunction transact(store, txSteps) {\\n    return (0, mutative_1.create)(store, (draft) => {\\n        txSteps.forEach((txStep) => {\\n            applyTxStep(draft, txStep);\\n        });\\n    });\\n}\\n//# sourceMappingURL=store.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"isRef\",\"attr\",\"getInMap\",\"obj\",\"path\",\"reduce\",\"acc\",\"key\",\"get\",\"deleteInMap\",\"m\",\"length\",\"Error\",\"delete\",\"head\",\"tail\",\"has\",\"setInMap\",\"value\",\"set\",\"nextM\",\"Map\",\"createTripleIndexes\",\"attrs\",\"triples\",\"eav\",\"aev\",\"vae\",\"triple\",\"eid\",\"aid\",\"v\",\"console\",\"warn\",\"createAttrIndexes\",\"blobAttrs\",\"primaryKeys\",\"forwardIdents\",\"revIdents\",\"Object\",\"values\",\"fwdEtype\",\"fwdLabel\",\"fwdIdent\",\"revIdent\",\"revEtype\",\"revLabel\",\"createStore\",\"enableCardinalityInference\",\"linkIndex\",\"store\",\"attrIndexes\",\"cardinalityInference\",\"__type\",\"resolveLookupRefs\",\"_a\",\"_b\",\"Array\",\"isArray\",\"a\",\"eMaps\",\"allMapValues\",\"find\",\"x\",\"lookupV\",\"rest\",\"getCreatedAt\",\"createdAt\",\"t\",\"ea\",\"Date\",\"now\",\"_seed\",\"deleteEntity\",\"args\",\"lookup\",\"etype\",\"id\",\"eMap\",\"keys\",\"forEach\",\"size\",\"vaeTriples\",\"e\",\"resetIndexMap\",\"newTriples\",\"newIndexMap\",\"addAttr\",\"deleteAttr\",\"filter\",\"updateAttr\",\"partialAttr\",\"assign\",\"level\",\"res\",\"push\",\"triplesByValue\",\"hasOwnProperty\",\"candidate\",\"$not\",\"attrId\",\"isNull\",\"reverse\",\"$isNull\",\"vMap\",\"isValNull\",\"aMap\",\"$comparator\",\"$op\",\"in\",\"$in\",\"defineProperty\",\"toJSON\",\"fromJSON\",\"storeJSON\",\"getTriples\",\"undefined\",\"getAsObject\",\"label\",\"entries\",\"getAttrByFwdIdentName\",\"inputEtype\",\"inputLabel\",\"getAttrByReverseIdentName\",\"getPrimaryKeyAttr\",\"fromPrimary\",\"transact\",\"txSteps\",\"mutative_1\",\"create\",\"draft\",\"txStep\",\"action\",\"existingTriple\",\"enhancedTriple\",\"update\",\"eavValuesMap\",\"currentTriple\",\"next\",\"updatedValue\",\"object_1\",\"immutableDeepMerge\",\"currentValue\"]\n}\n"]