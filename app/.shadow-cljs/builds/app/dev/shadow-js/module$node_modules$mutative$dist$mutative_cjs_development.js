["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mutative/dist/mutative.cjs.development.js"],"~:js","shadow$provide.module$node_modules$mutative$dist$mutative_cjs_development = function(global, require, module, exports) {\n  function has(target, key) {\n    return target instanceof Map ? target.has(key) : Object.prototype.hasOwnProperty.call(target, key);\n  }\n  function getDescriptor(target, key) {\n    if (key in target) {\n      for (target = Reflect.getPrototypeOf(target); target;) {\n        const descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n        if (descriptor) {\n          return descriptor;\n        }\n        target = Reflect.getPrototypeOf(target);\n      }\n    }\n  }\n  function latest(proxyDraft) {\n    var _a;\n    return null !== (_a = proxyDraft.copy) && void 0 !== _a ? _a : proxyDraft.original;\n  }\n  function isDraft(target) {\n    return !!getProxyDraft(target);\n  }\n  function getProxyDraft(value) {\n    return \"object\" !== typeof value ? null : null === value || void 0 === value ? void 0 : value[PROXY_DRAFT];\n  }\n  function getValue(value) {\n    var _a;\n    const proxyDraft = getProxyDraft(value);\n    return proxyDraft ? null !== (_a = proxyDraft.copy) && void 0 !== _a ? _a : proxyDraft.original : value;\n  }\n  function isDraftable(value, options) {\n    if (!value || \"object\" !== typeof value) {\n      return !1;\n    }\n    let markResult;\n    return Object.getPrototypeOf(value) === Object.prototype || Array.isArray(value) || value instanceof Map || value instanceof Set || !(null === options || void 0 === options || !options.mark) && ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable || \"function\" === typeof markResult);\n  }\n  function getPath(target, path = []) {\n    if (Object.hasOwnProperty.call(target, \"key\")) {\n      const parentCopy = target.parent.copy;\n      var proxyDraft = getProxyDraft(get(parentCopy, target.key));\n      if (null !== proxyDraft && (null === proxyDraft || void 0 === proxyDraft ? void 0 : proxyDraft.original) !== target.original) {\n        return null;\n      }\n      const key = (proxyDraft = 3 === target.parent.type) ? Array.from(target.parent.setMap.keys()).indexOf(target.key) : target.key;\n      if (!(proxyDraft && parentCopy.size > key || has(parentCopy, key))) {\n        return null;\n      }\n      path.push(key);\n    }\n    if (target.parent) {\n      return getPath(target.parent, path);\n    }\n    path.reverse();\n    try {\n      var base = target.copy;\n      for (target = 0; target < path.length - 1; target += 1) {\n        const key = path[target];\n        base = get(3 === getType(base) ? Array.from(base) : base, key);\n        if (\"object\" !== typeof base) {\n          throw Error(`Cannot resolve patch at '${path.join(\"/\")}'.`);\n        }\n      }\n    } catch (e) {\n      return null;\n    }\n    return path;\n  }\n  function getType(target) {\n    return Array.isArray(target) ? 1 : target instanceof Map ? 2 : target instanceof Set ? 3 : 0;\n  }\n  function get(target, key) {\n    return 2 === getType(target) ? target.get(key) : target[key];\n  }\n  function set(target, key, value) {\n    2 === getType(target) ? target.set(key, value) : target[key] = value;\n  }\n  function peek(target, key) {\n    const state = getProxyDraft(target);\n    return (state ? latest(state) : target)[key];\n  }\n  function isEqual(x, y) {\n    return x === y ? 0 !== x || 1 / x === 1 / y : x !== x && y !== y;\n  }\n  function revokeProxy(proxyDraft) {\n    if (proxyDraft) {\n      for (; 0 < proxyDraft.finalities.revoke.length;) {\n        proxyDraft.finalities.revoke.pop()();\n      }\n    }\n  }\n  function escapePath(path, pathAsArray) {\n    return pathAsArray ? path : [\"\"].concat(path).map(_item => {\n      _item = `${_item}`;\n      return -1 === _item.indexOf(\"/\") && -1 === _item.indexOf(\"~\") ? _item : _item.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n    }).join(\"/\");\n  }\n  function unescapePath(path) {\n    return Array.isArray(path) ? path : path.split(\"/\").map(_item => _item.replace(/~1/g, \"/\").replace(/~0/g, \"~\")).slice(1);\n  }\n  function strictCopy(target) {\n    const copy = Object.create(Object.getPrototypeOf(target));\n    Reflect.ownKeys(target).forEach(key => {\n      let desc = Reflect.getOwnPropertyDescriptor(target, key);\n      if (desc.enumerable && desc.configurable && desc.writable) {\n        copy[key] = target[key];\n      } else {\n        desc.writable || (desc.writable = !0, desc.configurable = !0);\n        if (desc.get || desc.set) {\n          desc = {configurable:!0, writable:!0, enumerable:desc.enumerable, value:target[key]};\n        }\n        Reflect.defineProperty(copy, key, desc);\n      }\n    });\n    return copy;\n  }\n  function shallowCopy(original, options) {\n    let markResult;\n    if (Array.isArray(original)) {\n      return Array.prototype.concat.call(original);\n    }\n    if (original instanceof Set) {\n      return Object.getPrototypeOf(original) !== Set.prototype ? new (Object.getPrototypeOf(original).constructor)(original.values()) : Set.prototype.difference ? Set.prototype.difference.call(original, new Set()) : new Set(original.values());\n    }\n    if (original instanceof Map) {\n      return Object.getPrototypeOf(original) !== Map.prototype ? new (Object.getPrototypeOf(original).constructor)(original) : new Map(original);\n    }\n    if ((null === options || void 0 === options ? 0 : options.mark) && (markResult = options.mark(original, dataTypes), void 0 !== markResult) && markResult !== dataTypes.mutable) {\n      if (markResult === dataTypes.immutable) {\n        return strictCopy(original);\n      }\n      if (\"function\" === typeof markResult) {\n        if (options.enablePatches || options.enableAutoFreeze) {\n          throw Error(\"You can't use mark and patches or auto freeze together.\");\n        }\n        return markResult();\n      }\n      throw Error(`Unsupported mark result: ${markResult}`);\n    }\n    if (\"object\" === typeof original && Object.getPrototypeOf(original) === Object.prototype) {\n      const copy = {};\n      Object.keys(original).forEach(key => {\n        copy[key] = original[key];\n      });\n      Object.getOwnPropertySymbols(original).forEach(key => {\n        propIsEnum.call(original, key) && (copy[key] = original[key]);\n      });\n      return copy;\n    }\n    throw Error(\"Please check mark() to ensure that it is a stable marker draftable function.\");\n  }\n  function ensureShallowCopy(target) {\n    target.copy || (target.copy = shallowCopy(target.original, target.options));\n  }\n  function deepClone(target) {\n    if (!isDraftable(target)) {\n      return getValue(target);\n    }\n    if (Array.isArray(target)) {\n      return target.map(deepClone);\n    }\n    if (target instanceof Map) {\n      var iterable = Array.from(target.entries()).map(([k, v]) => [k, deepClone(v)]);\n      return Object.getPrototypeOf(target) !== Map.prototype ? new (Object.getPrototypeOf(target).constructor)(iterable) : new Map(iterable);\n    }\n    if (target instanceof Set) {\n      return iterable = Array.from(target).map(deepClone), Object.getPrototypeOf(target) !== Set.prototype ? new (Object.getPrototypeOf(target).constructor)(iterable) : new Set(iterable);\n    }\n    iterable = Object.create(Object.getPrototypeOf(target));\n    for (const key in target) {\n      iterable[key] = deepClone(target[key]);\n    }\n    return iterable;\n  }\n  function cloneIfNeeded(target) {\n    return isDraft(target) ? deepClone(target) : target;\n  }\n  function markChanged(proxyDraft) {\n    var _a;\n    proxyDraft.assignedMap = null !== (_a = proxyDraft.assignedMap) && void 0 !== _a ? _a : new Map();\n    proxyDraft.operated || (proxyDraft.operated = !0, proxyDraft.parent && markChanged(proxyDraft.parent));\n  }\n  function throwFrozenError() {\n    throw Error(\"Cannot modify frozen object\");\n  }\n  function deepFreeze(target, subKey, updatedValues, stack, keys) {\n    updatedValues = null !== updatedValues && void 0 !== updatedValues ? updatedValues : new WeakMap();\n    stack = null !== stack && void 0 !== stack ? stack : [];\n    keys = null !== keys && void 0 !== keys ? keys : [];\n    const value = updatedValues.has(target) ? updatedValues.get(target) : target;\n    if (0 < stack.length) {\n      const index = stack.indexOf(value);\n      if (value && \"object\" === typeof value && -1 !== index) {\n        if (stack[0] === value) {\n          throw Error(\"Forbids circular reference\");\n        }\n        throw Error(`Forbids circular reference: ~/${keys.slice(0, index).map((key, index) => {\n          if (\"symbol\" === typeof key) {\n            return `[${key.toString()}]`;\n          }\n          index = stack[index];\n          return \"object\" === typeof key && (index instanceof Map || index instanceof Set) ? Array.from(index.keys()).indexOf(key) : key;\n        }).join(\"/\")}`);\n      }\n      stack.push(value);\n      keys.push(subKey);\n    } else {\n      stack.push(value);\n    }\n    if (!Object.isFrozen(target) && !isDraft(target)) {\n      switch(getType(target)) {\n        case 2:\n          for (const [key, value] of target) {\n            deepFreeze(key, key, updatedValues, stack, keys), deepFreeze(value, key, updatedValues, stack, keys);\n          }\n          target.set = target.clear = target.delete = throwFrozenError;\n          break;\n        case 3:\n          for (const value of target) {\n            deepFreeze(value, value, updatedValues, stack, keys);\n          }\n          target.add = target.clear = target.delete = throwFrozenError;\n          break;\n        case 1:\n          Object.freeze(target);\n          subKey = 0;\n          for (const value of target) {\n            deepFreeze(value, subKey, updatedValues, stack, keys), subKey += 1;\n          }\n          break;\n        default:\n          Object.freeze(target), Object.keys(target).forEach(name => {\n            deepFreeze(target[name], name, updatedValues, stack, keys);\n          });\n      }\n    }\n    stack.pop();\n    keys.pop();\n  }\n  function forEach(target, iter) {\n    var type = getType(target);\n    if (0 === type) {\n      Reflect.ownKeys(target).forEach(key => {\n        iter(key, target[key], target);\n      });\n    } else if (1 === type) {\n      type = 0;\n      for (const entry of target) {\n        iter(type, entry, target), type += 1;\n      }\n    } else {\n      target.forEach((entry, index) => iter(index, entry, target));\n    }\n  }\n  function handleValue(target, handledSet, options) {\n    if (!isDraft(target) && isDraftable(target, options) && !handledSet.has(target) && !Object.isFrozen(target)) {\n      var isSet = target instanceof Set, setMap = isSet ? new Map() : void 0;\n      handledSet.add(target);\n      forEach(target, (key, value) => {\n        var _a;\n        if (isDraft(value)) {\n          value = getProxyDraft(value);\n          ensureShallowCopy(value);\n          const updatedValue = (null === (_a = value.assignedMap) || void 0 === _a ? 0 : _a.size) || value.operated ? value.copy : value.original;\n          set(isSet ? setMap : target, key, updatedValue);\n        } else {\n          handleValue(value, handledSet, options);\n        }\n      });\n      if (setMap) {\n        const values = Array.from(target);\n        target.clear();\n        values.forEach(value => {\n          target.add(setMap.has(value) ? setMap.get(value) : value);\n        });\n      }\n    }\n  }\n  function finalizeSetValue(target) {\n    3 === target.type && target.copy && (target.copy.clear(), target.setMap.forEach(value => {\n      target.copy.add(getValue(value));\n    }));\n  }\n  function finalizePatches(target, generatePatches, patches, inversePatches) {\n    if (target.operated && target.assignedMap && 0 < target.assignedMap.size && !target.finalized) {\n      if (patches && inversePatches) {\n        const basePath = getPath(target);\n        basePath && generatePatches(target, basePath, patches, inversePatches);\n      }\n      target.finalized = !0;\n    }\n  }\n  function markFinalization(target, key, value, generatePatches) {\n    const proxyDraft = getProxyDraft(value);\n    proxyDraft && (proxyDraft.callbacks || (proxyDraft.callbacks = []), proxyDraft.callbacks.push((patches, inversePatches) => {\n      var _a;\n      const copy = 3 === target.type ? target.setMap : target.copy;\n      if (isEqual(get(copy, key), value)) {\n        let updatedValue = proxyDraft.original;\n        proxyDraft.copy && (updatedValue = proxyDraft.copy);\n        finalizeSetValue(target);\n        finalizePatches(target, generatePatches, patches, inversePatches);\n        target.options.enableAutoFreeze && (target.options.updatedValues = null !== (_a = target.options.updatedValues) && void 0 !== _a ? _a : new WeakMap(), target.options.updatedValues.set(updatedValue, proxyDraft.original));\n        set(copy, key, updatedValue);\n      }\n    }), target.options.enableAutoFreeze && proxyDraft.finalities !== target.finalities && (target.options.enableAutoFreeze = !1));\n    isDraftable(value, target.options) && target.finalities.draft.push(() => {\n      if (isEqual(get(3 === target.type ? target.setMap : target.copy, key), value)) {\n        const copy = 3 === target.type ? target.setMap : target.copy;\n        1 < target.finalities.revoke.length && target.assignedMap.get(key) && copy && handleValue(get(copy, key), target.finalities.handledSet, target.options);\n      }\n    });\n  }\n  function generatePatchesFromAssigned({original, copy, assignedMap}, basePath, patches, inversePatches, pathAsArray) {\n    assignedMap.forEach((assignedValue, key) => {\n      const originalValue = get(original, key), value = cloneIfNeeded(get(copy, key));\n      assignedValue = assignedValue ? has(original, key) ? Operation.Replace : Operation.Add : Operation.Remove;\n      isEqual(originalValue, value) && assignedValue === Operation.Replace || (key = basePath.concat(key), key = escapePath(key, pathAsArray), patches.push(assignedValue === Operation.Remove ? {op:assignedValue, path:key} : {op:assignedValue, path:key, value}), inversePatches.push(assignedValue === Operation.Add ? {op:Operation.Remove, path:key} : assignedValue === Operation.Remove ? {op:Operation.Add, path:key, value:originalValue} : {op:Operation.Replace, path:key, value:originalValue}));\n    });\n  }\n  function generateSetPatches({original, copy}, basePath, patches, inversePatches, pathAsArray) {\n    let index = 0;\n    original.forEach(value => {\n      if (!copy.has(value)) {\n        var _path = basePath.concat([index]);\n        _path = escapePath(_path, pathAsArray);\n        patches.push({op:Operation.Remove, path:_path, value});\n        inversePatches.unshift({op:Operation.Add, path:_path, value});\n      }\n      index += 1;\n    });\n    index = 0;\n    copy.forEach(value => {\n      if (!original.has(value)) {\n        var _path = basePath.concat([index]);\n        _path = escapePath(_path, pathAsArray);\n        patches.push({op:Operation.Add, path:_path, value});\n        inversePatches.unshift({op:Operation.Remove, path:_path, value});\n      }\n      index += 1;\n    });\n  }\n  function generatePatches(proxyState, basePath, patches, inversePatches) {\n    var {pathAsArray = !0} = proxyState.options.enablePatches;\n    switch(proxyState.type) {\n      case 0:\n      case 2:\n        return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);\n      case 1:\n        let {original, assignedMap, options} = proxyState;\n        proxyState = proxyState.copy;\n        proxyState.length < original.length && ([original, proxyState] = [proxyState, original], [patches, inversePatches] = [inversePatches, patches]);\n        for (var index = 0; index < original.length; index += 1) {\n          if (assignedMap.get(index.toString()) && proxyState[index] !== original[index]) {\n            var _path = basePath.concat([index]);\n            _path = escapePath(_path, pathAsArray);\n            patches.push({op:Operation.Replace, path:_path, value:cloneIfNeeded(proxyState[index])});\n            inversePatches.push({op:Operation.Replace, path:_path, value:cloneIfNeeded(original[index])});\n          }\n        }\n        for (index = original.length; index < proxyState.length; index += 1) {\n          _path = basePath.concat([index]), _path = escapePath(_path, pathAsArray), patches.push({op:Operation.Add, path:_path, value:cloneIfNeeded(proxyState[index])});\n        }\n        if (original.length < proxyState.length) {\n          if ({arrayLengthAssignment:patches = !0} = options.enablePatches, patches) {\n            basePath = basePath.concat([\"length\"]), pathAsArray = escapePath(basePath, pathAsArray), inversePatches.push({op:Operation.Replace, path:pathAsArray, value:original.length});\n          } else {\n            for (patches = proxyState.length; original.length < patches; --patches) {\n              proxyState = basePath.concat([patches - 1]), proxyState = escapePath(proxyState, pathAsArray), inversePatches.push({op:Operation.Remove, path:proxyState});\n            }\n          }\n        }\n        break;\n      case 3:\n        return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);\n    }\n  }\n  function createDraft(createDraftOptions) {\n    const {original, parentDraft, key, finalities, options} = createDraftOptions, type = getType(original), proxyDraft = {type, finalized:!1, parent:parentDraft, original, copy:null, proxy:null, finalities, options, setMap:3 === type ? new Map(original.entries()) : void 0};\n    if (key || \"key\" in createDraftOptions) {\n      proxyDraft.key = key;\n    }\n    const {proxy, revoke} = Proxy.revocable(1 === type ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);\n    finalities.revoke.push(revoke);\n    draftsCache.add(proxy);\n    proxyDraft.proxy = proxy;\n    if (parentDraft) {\n      parentDraft.finalities.draft.push((patches, inversePatches) => {\n        var _a, _b;\n        const oldProxyDraft = getProxyDraft(proxy);\n        let copy = 3 === parentDraft.type ? parentDraft.setMap : parentDraft.copy;\n        const draft = get(copy, key), proxyDraft = getProxyDraft(draft);\n        if (proxyDraft) {\n          let updatedValue = proxyDraft.original;\n          proxyDraft.operated && (updatedValue = getValue(draft));\n          finalizeSetValue(proxyDraft);\n          finalizePatches(proxyDraft, generatePatches, patches, inversePatches);\n          parentDraft.options.enableAutoFreeze && (parentDraft.options.updatedValues = null !== (_a = parentDraft.options.updatedValues) && void 0 !== _a ? _a : new WeakMap(), parentDraft.options.updatedValues.set(updatedValue, proxyDraft.original));\n          set(copy, key, updatedValue);\n        }\n        null === (_b = oldProxyDraft.callbacks) || void 0 === _b || _b.forEach(callback => {\n          callback(patches, inversePatches);\n        });\n      });\n    } else {\n      const target = getProxyDraft(proxy);\n      target.finalities.draft.push((patches, inversePatches) => {\n        finalizeSetValue(target);\n        finalizePatches(target, generatePatches, patches, inversePatches);\n      });\n    }\n    return proxy;\n  }\n  function draftify(baseState, options) {\n    var _a;\n    const finalities = {draft:[], revoke:[], handledSet:new WeakSet()};\n    let patches$jscomp$0, inversePatches$jscomp$0;\n    options.enablePatches && (patches$jscomp$0 = [], inversePatches$jscomp$0 = []);\n    const draft = (null === (_a = options.mark) || void 0 === _a ? void 0 : _a.call(options, baseState, dataTypes)) !== dataTypes.mutable && isDraftable(baseState, options) ? createDraft({original:baseState, parentDraft:null, finalities, options}) : baseState;\n    return [draft, (returnedValue = []) => {\n      var patches = patches$jscomp$0, inversePatches = inversePatches$jscomp$0, enableAutoFreeze = options.enableAutoFreeze, _a;\n      const proxyDraft = getProxyDraft(draft), original = null !== (_a = null === proxyDraft || void 0 === proxyDraft ? void 0 : proxyDraft.original) && void 0 !== _a ? _a : draft;\n      _a = !!returnedValue.length;\n      if (null === proxyDraft || void 0 === proxyDraft ? 0 : proxyDraft.operated) {\n        for (; 0 < proxyDraft.finalities.draft.length;) {\n          proxyDraft.finalities.draft.pop()(patches, inversePatches);\n        }\n      }\n      const state = _a ? returnedValue[0] : proxyDraft ? proxyDraft.operated ? proxyDraft.copy : proxyDraft.original : draft;\n      proxyDraft && revokeProxy(proxyDraft);\n      enableAutoFreeze && deepFreeze(state, state, null === proxyDraft || void 0 === proxyDraft ? void 0 : proxyDraft.options.updatedValues);\n      const [finalizedState, finalizedPatches, finalizedInversePatches] = [state, patches && _a ? [{op:Operation.Replace, path:[], value:returnedValue[0]}] : patches, inversePatches && _a ? [{op:Operation.Replace, path:[], value:original}] : inversePatches];\n      return options.enablePatches ? [finalizedState, finalizedPatches, finalizedInversePatches] : finalizedState;\n    }];\n  }\n  function handleReturnValue(options) {\n    const {rootDraft, value, useRawReturn = !1, isRoot = !0} = options;\n    forEach(value, (key, item, source) => {\n      const proxyDraft = getProxyDraft(item);\n      if (proxyDraft && rootDraft && proxyDraft.finalities === rootDraft.finalities) {\n        options.isContainDraft = !0;\n        const currentValue = proxyDraft.original;\n        source instanceof Set ? (item = Array.from(source), source.clear(), item.forEach(_item => source.add(key === _item ? currentValue : _item))) : set(source, key, currentValue);\n      } else {\n        \"object\" === typeof item && null !== item && (options.value = item, options.isRoot = !1, handleReturnValue(options));\n      }\n    });\n    isRoot && (options.isContainDraft || console.warn(\"The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.\"), useRawReturn && console.warn(\"The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.\"));\n  }\n  function getCurrent(target) {\n    function ensureShallowCopy() {\n      currentValue = 2 === type ? Object.getPrototypeOf(target) !== Map.prototype ? new (Object.getPrototypeOf(target).constructor)(target) : new Map(target) : 3 === type ? Array.from(proxyDraft.setMap.values()) : shallowCopy(target, null === proxyDraft || void 0 === proxyDraft ? void 0 : proxyDraft.options);\n    }\n    var _a;\n    const proxyDraft = getProxyDraft(target);\n    if (!isDraftable(target, null === proxyDraft || void 0 === proxyDraft ? void 0 : proxyDraft.options)) {\n      return target;\n    }\n    const type = getType(target);\n    if (proxyDraft && !proxyDraft.operated) {\n      return proxyDraft.original;\n    }\n    let currentValue;\n    if (proxyDraft) {\n      proxyDraft.finalized = !0;\n      try {\n        ensureShallowCopy();\n      } finally {\n        proxyDraft.finalized = !1;\n      }\n    } else {\n      currentValue = target;\n    }\n    forEach(currentValue, (key, value) => {\n      if (!proxyDraft || !isEqual(get(proxyDraft.original, key), value)) {\n        var newValue = getCurrent(value);\n        newValue !== value && (currentValue === target && ensureShallowCopy(), set(currentValue, key, newValue));\n      }\n    });\n    if (3 === type) {\n      const value = null !== (_a = null === proxyDraft || void 0 === proxyDraft ? void 0 : proxyDraft.original) && void 0 !== _a ? _a : currentValue;\n      return Object.getPrototypeOf(value) !== Set.prototype ? new (Object.getPrototypeOf(value).constructor)(currentValue) : new Set(currentValue);\n    }\n    return currentValue;\n  }\n  function current(target) {\n    if (!isDraft(target)) {\n      throw Error(`current() is only used for Draft, parameter: ${target}`);\n    }\n    return getCurrent(target);\n  }\n  const Operation = {Remove:\"remove\", Replace:\"replace\", Add:\"add\"}, PROXY_DRAFT = Symbol.for(\"__MUTATIVE_PROXY_DRAFT__\"), RAW_RETURN_SYMBOL = Symbol(\"__MUTATIVE_RAW_RETURN_SYMBOL__\"), iteratorSymbol = Symbol.iterator, dataTypes = {mutable:\"mutable\", immutable:\"immutable\"}, internal = {}, propIsEnum = Object.prototype.propertyIsEnumerable;\n  let readable = !1;\n  const checkReadable = (value, options, ignoreCheckDraftable = !1) => {\n    if (\"object\" === typeof value && null !== value && (!isDraftable(value, options) || ignoreCheckDraftable) && !readable) {\n      throw Error(\"Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.\");\n    }\n  }, mapHandler = {get size() {\n    return latest(getProxyDraft(this)).size;\n  }, has(key) {\n    return latest(getProxyDraft(this)).has(key);\n  }, set(key, value) {\n    const target = getProxyDraft(this), source = latest(target);\n    source.has(key) && isEqual(source.get(key), value) || (ensureShallowCopy(target), markChanged(target), target.assignedMap.set(key, !0), target.copy.set(key, value), markFinalization(target, key, value, generatePatches));\n    return this;\n  }, delete(key) {\n    if (!this.has(key)) {\n      return !1;\n    }\n    const target = getProxyDraft(this);\n    ensureShallowCopy(target);\n    markChanged(target);\n    target.original.has(key) ? target.assignedMap.set(key, !1) : target.assignedMap.delete(key);\n    target.copy.delete(key);\n    return !0;\n  }, clear() {\n    const target = getProxyDraft(this);\n    if (this.size) {\n      ensureShallowCopy(target);\n      markChanged(target);\n      target.assignedMap = new Map();\n      for (const [key] of target.original) {\n        target.assignedMap.set(key, !1);\n      }\n      target.copy.clear();\n    }\n  }, forEach(callback, thisArg) {\n    const target = getProxyDraft(this);\n    latest(target).forEach((_value, _key) => {\n      callback.call(thisArg, this.get(_key), _key, this);\n    });\n  }, get(key) {\n    var _a, _b;\n    const target = getProxyDraft(this), value = latest(target).get(key), mutable = (null === (_b = (_a = target.options).mark) || void 0 === _b ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\n    target.options.strict && checkReadable(value, target.options, mutable);\n    if (mutable || target.finalized || !isDraftable(value, target.options) || value !== target.original.get(key)) {\n      return value;\n    }\n    _a = internal.createDraft({original:value, parentDraft:target, key, finalities:target.finalities, options:target.options});\n    ensureShallowCopy(target);\n    target.copy.set(key, _a);\n    return _a;\n  }, keys() {\n    return latest(getProxyDraft(this)).keys();\n  }, values() {\n    const iterator = this.keys();\n    return {[iteratorSymbol]:() => this.values(), next:() => {\n      const result = iterator.next();\n      return result.done ? result : {done:!1, value:this.get(result.value)};\n    }};\n  }, entries() {\n    const iterator = this.keys();\n    return {[iteratorSymbol]:() => this.entries(), next:() => {\n      const result = iterator.next();\n      if (result.done) {\n        return result;\n      }\n      const value = this.get(result.value);\n      return {done:!1, value:[result.value, value]};\n    }};\n  }, [iteratorSymbol]() {\n    return this.entries();\n  }}, mapHandlerKeys = Reflect.ownKeys(mapHandler), getNextIterator = (target, iterator, {isValuesIterator}) => () => {\n    var _a, _b, result = iterator.next();\n    if (result.done) {\n      return result;\n    }\n    result = result.value;\n    let value = target.setMap.get(result);\n    const currentDraft = getProxyDraft(value), mutable = (null === (_b = (_a = target.options).mark) || void 0 === _b ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\n    target.options.strict && checkReadable(result, target.options, mutable);\n    mutable || currentDraft || !isDraftable(result, target.options) || target.finalized || !target.original.has(result) ? currentDraft && (value = currentDraft.proxy) : (_a = internal.createDraft({original:result, parentDraft:target, key:result, finalities:target.finalities, options:target.options}), target.setMap.set(result, _a), value = _a);\n    return {done:!1, value:isValuesIterator ? value : [value, value]};\n  }, setHandler = {get size() {\n    return getProxyDraft(this).setMap.size;\n  }, has(value) {\n    const target = getProxyDraft(this);\n    if (target.setMap.has(value)) {\n      return !0;\n    }\n    ensureShallowCopy(target);\n    return (value = getProxyDraft(value)) && target.setMap.has(value.original) ? !0 : !1;\n  }, add(value) {\n    const target = getProxyDraft(this);\n    this.has(value) || (ensureShallowCopy(target), markChanged(target), target.assignedMap.set(value, !0), target.setMap.set(value, value), markFinalization(target, value, value, generatePatches));\n    return this;\n  }, delete(value) {\n    if (!this.has(value)) {\n      return !1;\n    }\n    const target = getProxyDraft(this);\n    ensureShallowCopy(target);\n    markChanged(target);\n    const valueProxyDraft = getProxyDraft(value);\n    if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {\n      return target.assignedMap.set(valueProxyDraft.original, !1), target.setMap.delete(valueProxyDraft.original);\n    }\n    !valueProxyDraft && target.setMap.has(value) ? target.assignedMap.set(value, !1) : target.assignedMap.delete(value);\n    return target.setMap.delete(value);\n  }, clear() {\n    if (this.size) {\n      var target = getProxyDraft(this);\n      ensureShallowCopy(target);\n      markChanged(target);\n      for (const value of target.original) {\n        target.assignedMap.set(value, !1);\n      }\n      target.setMap.clear();\n    }\n  }, values() {\n    const target = getProxyDraft(this);\n    ensureShallowCopy(target);\n    const iterator = target.setMap.keys();\n    return {[Symbol.iterator]:() => this.values(), next:getNextIterator(target, iterator, {isValuesIterator:!0})};\n  }, entries() {\n    const target = getProxyDraft(this);\n    ensureShallowCopy(target);\n    const iterator = target.setMap.keys();\n    return {[Symbol.iterator]:() => this.entries(), next:getNextIterator(target, iterator, {isValuesIterator:!1})};\n  }, keys() {\n    return this.values();\n  }, [iteratorSymbol]() {\n    return this.values();\n  }, forEach(callback, thisArg) {\n    const iterator = this.values();\n    let result = iterator.next();\n    for (; !result.done;) {\n      callback.call(thisArg, result.value, result.value, this), result = iterator.next();\n    }\n  }};\n  Set.prototype.difference && Object.assign(setHandler, {intersection(other) {\n    return Set.prototype.intersection.call(new Set(this.values()), other);\n  }, union(other) {\n    return Set.prototype.union.call(new Set(this.values()), other);\n  }, difference(other) {\n    return Set.prototype.difference.call(new Set(this.values()), other);\n  }, symmetricDifference(other) {\n    return Set.prototype.symmetricDifference.call(new Set(this.values()), other);\n  }, isSubsetOf(other) {\n    return Set.prototype.isSubsetOf.call(new Set(this.values()), other);\n  }, isSupersetOf(other) {\n    return Set.prototype.isSupersetOf.call(new Set(this.values()), other);\n  }, isDisjointFrom(other) {\n    return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);\n  }});\n  const setHandlerKeys = Reflect.ownKeys(setHandler), draftsCache = new WeakSet(), proxyHandler = {get(target, key, receiver) {\n    var _a, _b;\n    const copy = null === (_a = target.copy) || void 0 === _a ? void 0 : _a[key];\n    if (copy && draftsCache.has(copy)) {\n      return copy;\n    }\n    if (key === PROXY_DRAFT) {\n      return target;\n    }\n    let markResult;\n    if (target.options.mark && (receiver = \"size\" === key && (target.original instanceof Map || target.original instanceof Set) ? Reflect.get(target.original, key) : Reflect.get(target.original, key, receiver), markResult = target.options.mark(receiver, dataTypes), markResult === dataTypes.mutable)) {\n      return target.options.strict && checkReadable(receiver, target.options, !0), receiver;\n    }\n    receiver = latest(target);\n    if (receiver instanceof Map && mapHandlerKeys.includes(key)) {\n      if (\"size\" === key) {\n        return Object.getOwnPropertyDescriptor(mapHandler, \"size\").get.call(target.proxy);\n      }\n      if (_a = mapHandler[key]) {\n        return _a.bind(target.proxy);\n      }\n    }\n    if (receiver instanceof Set && setHandlerKeys.includes(key)) {\n      if (\"size\" === key) {\n        return Object.getOwnPropertyDescriptor(setHandler, \"size\").get.call(target.proxy);\n      }\n      if (_a = setHandler[key]) {\n        return _a.bind(target.proxy);\n      }\n    }\n    if (!has(receiver, key)) {\n      return (key = getDescriptor(receiver, key)) ? \"value\" in key ? key.value : null === (_b = key.get) || void 0 === _b ? void 0 : _b.call(target.proxy) : void 0;\n    }\n    _b = receiver[key];\n    target.options.strict && checkReadable(_b, target.options);\n    return target.finalized || !isDraftable(_b, target.options) ? _b : _b === peek(target.original, key) ? (ensureShallowCopy(target), target.copy[key] = createDraft({original:target.original[key], parentDraft:target, key:1 === target.type ? Number(key) : key, finalities:target.finalities, options:target.options}), \"function\" === typeof markResult ? (target = getProxyDraft(target.copy[key]), ensureShallowCopy(target), markChanged(target), target.copy) : target.copy[key]) : _b;\n  }, set(target, key, value) {\n    var _a;\n    if (3 === target.type || 2 === target.type) {\n      throw Error(\"Map/Set draft does not support any property assignment.\");\n    }\n    var _key;\n    if (1 === target.type && \"length\" !== key && (!(Number.isInteger(_key = Number(key)) && 0 <= _key) || 0 !== key && 0 !== _key && String(_key) !== String(key))) {\n      throw Error(\"Only supports setting array indices and the 'length' property.\");\n    }\n    _key = getDescriptor(latest(target), key);\n    if (null === _key || void 0 === _key ? 0 : _key.set) {\n      return _key.set.call(target.proxy, value), !0;\n    }\n    _key = peek(latest(target), key);\n    const currentProxyDraft = getProxyDraft(_key);\n    if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {\n      return target.copy[key] = value, target.assignedMap = null !== (_a = target.assignedMap) && void 0 !== _a ? _a : new Map(), target.assignedMap.set(key, !1), !0;\n    }\n    if (isEqual(value, _key) && (void 0 !== value || has(target.original, key))) {\n      return !0;\n    }\n    ensureShallowCopy(target);\n    markChanged(target);\n    has(target.original, key) && isEqual(value, target.original[key]) ? target.assignedMap.delete(key) : target.assignedMap.set(key, !0);\n    target.copy[key] = value;\n    markFinalization(target, key, value, generatePatches);\n    return !0;\n  }, has(target, key) {\n    return key in latest(target);\n  }, ownKeys(target) {\n    return Reflect.ownKeys(latest(target));\n  }, getOwnPropertyDescriptor(target, key) {\n    const source = latest(target), descriptor = Reflect.getOwnPropertyDescriptor(source, key);\n    return descriptor ? {writable:!0, configurable:1 !== target.type || \"length\" !== key, enumerable:descriptor.enumerable, value:source[key]} : descriptor;\n  }, getPrototypeOf(target) {\n    return Reflect.getPrototypeOf(target.original);\n  }, setPrototypeOf() {\n    throw Error(\"Cannot call 'setPrototypeOf()' on drafts\");\n  }, defineProperty() {\n    throw Error(\"Cannot call 'defineProperty()' on drafts\");\n  }, deleteProperty(target, key) {\n    var _a;\n    if (1 === target.type) {\n      return proxyHandler.set.call(this, target, key, void 0, target.proxy);\n    }\n    void 0 !== peek(target.original, key) || key in target.original ? (ensureShallowCopy(target), markChanged(target), target.assignedMap.set(key, !1)) : (target.assignedMap = null !== (_a = target.assignedMap) && void 0 !== _a ? _a : new Map(), target.assignedMap.delete(key));\n    target.copy && delete target.copy[key];\n    return !0;\n  }};\n  internal.createDraft = createDraft;\n  global = arg => {\n    if (void 0 !== arg && \"[object Object]\" !== Object.prototype.toString.call(arg)) {\n      throw Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);\n    }\n    return function create(arg0, arg1, arg2) {\n      var _a, _b, _c;\n      if (\"function\" === typeof arg0 && \"function\" !== typeof arg1) {\n        return function(base, ...args) {\n          return create(base, draft => arg0.call(this, draft, ...args), arg1);\n        };\n      }\n      let options = arg2;\n      \"function\" !== typeof arg1 && (options = arg1);\n      if (void 0 !== options && \"[object Object]\" !== Object.prototype.toString.call(options)) {\n        throw Error(`Invalid options: ${options}, 'options' should be an object.`);\n      }\n      options = Object.assign(Object.assign({}, arg), options);\n      arg2 = isDraft(arg0) ? current(arg0) : arg0;\n      const mark = Array.isArray(options.mark) ? (value, types) => {\n        for (const mark of options.mark) {\n          if (\"function\" !== typeof mark) {\n            throw Error(`Invalid mark: ${mark}, 'mark' should be a function.`);\n          }\n          const result = mark(value, types);\n          if (result) {\n            return result;\n          }\n        }\n      } : options.mark, enablePatches = null !== (_a = options.enablePatches) && void 0 !== _a ? _a : !1;\n      _a = null !== (_b = options.strict) && void 0 !== _b ? _b : !1;\n      const _options = {enableAutoFreeze:null !== (_c = options.enableAutoFreeze) && void 0 !== _c ? _c : !1, mark, strict:_a, enablePatches};\n      if (!isDraftable(arg2, _options) && \"object\" === typeof arg2 && null !== arg2) {\n        throw Error(\"Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.\");\n      }\n      const [draft, finalize] = draftify(arg2, _options);\n      if (\"function\" !== typeof arg1) {\n        if (!isDraftable(arg2, _options)) {\n          throw Error(\"Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.\");\n        }\n        return [draft, finalize];\n      }\n      let result;\n      try {\n        result = arg1(draft);\n      } catch (error) {\n        throw revokeProxy(getProxyDraft(draft)), error;\n      }\n      _b = value => {\n        var proxyDraft = getProxyDraft(draft);\n        if (!isDraft(value)) {\n          if (void 0 !== value && !isEqual(value, draft) && (null === proxyDraft || void 0 === proxyDraft ? 0 : proxyDraft.operated)) {\n            throw Error(\"Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.\");\n          }\n          var rawReturnValue = null === value || void 0 === value ? void 0 : value[RAW_RETURN_SYMBOL];\n          if (rawReturnValue) {\n            return rawReturnValue = rawReturnValue[0], _options.strict && \"object\" === typeof value && null !== value && handleReturnValue({rootDraft:proxyDraft, value, useRawReturn:!0}), finalize([rawReturnValue]);\n          }\n          if (void 0 !== value) {\n            return \"object\" === typeof value && null !== value && handleReturnValue({rootDraft:proxyDraft, value}), finalize([value]);\n          }\n        }\n        if (value === draft || void 0 === value) {\n          return finalize([]);\n        }\n        proxyDraft = getProxyDraft(value);\n        if (_options === proxyDraft.options) {\n          if (proxyDraft.operated) {\n            throw Error(\"Cannot return a modified child draft.\");\n          }\n          return finalize([current(value)]);\n        }\n        return finalize([value]);\n      };\n      return result instanceof Promise ? result.then(_b, error => {\n        revokeProxy(getProxyDraft(draft));\n        throw error;\n      }) : _b(result);\n    };\n  };\n  const create = global(), constructorString = Object.prototype.constructor.toString();\n  exports.apply = function(state, patches, applyOptions) {\n    var i;\n    for (i = patches.length - 1; 0 <= i; --i) {\n      const {value, op, path} = patches[i];\n      if (!path.length && op === Operation.Replace || \"\" === path && op === Operation.Add) {\n        state = value;\n        break;\n      }\n    }\n    -1 < i && (patches = patches.slice(i + 1));\n    i = draft => {\n      patches.forEach(patch => {\n        const {path:_path, op} = patch;\n        var path = unescapePath(_path);\n        let base = draft;\n        for (var index = 0; index < path.length - 1; index += 1) {\n          var parentType = getType(base);\n          let key = path[index];\n          \"string\" !== typeof key && \"number\" !== typeof key && (key = String(key));\n          if (!(0 !== parentType && 1 !== parentType || \"__proto__\" !== key && \"constructor\" !== key) || \"function\" === typeof base && \"prototype\" === key) {\n            throw Error(\"Patching reserved attributes like __proto__ and constructor is not allowed.\");\n          }\n          base = get(3 === parentType ? Array.from(base) : base, key);\n          if (\"object\" !== typeof base) {\n            throw Error(`Cannot apply patch at '${path.join(\"/\")}'.`);\n          }\n        }\n        index = getType(base);\n        parentType = deepClone(patch.value);\n        path = path[path.length - 1];\n        switch(op) {\n          case Operation.Replace:\n            switch(index) {\n              case 2:\n                return base.set(path, parentType);\n              case 3:\n                throw Error(\"Cannot apply replace patch to set.\");\n              default:\n                return base[path] = parentType;\n            }case Operation.Add:\n            switch(index) {\n              case 1:\n                return \"-\" === path ? base.push(parentType) : base.splice(path, 0, parentType);\n              case 2:\n                return base.set(path, parentType);\n              case 3:\n                return base.add(parentType);\n              default:\n                return base[path] = parentType;\n            }case Operation.Remove:\n            switch(index) {\n              case 1:\n                return base.splice(path, 1);\n              case 2:\n                return base.delete(path);\n              case 3:\n                return base.delete(patch.value);\n              default:\n                return delete base[path];\n            }default:\n            throw Error(`Unsupported patch operation: ${op}.`);\n        }\n      });\n    };\n    if (isDraft(state)) {\n      if (void 0 !== applyOptions) {\n        throw Error(\"Cannot apply patches with options to a draft.\");\n      }\n      i(state);\n      return state;\n    }\n    return create(state, i, Object.assign(Object.assign({}, applyOptions), {enablePatches:!1}));\n  };\n  exports.castDraft = function(value) {\n    return value;\n  };\n  exports.castImmutable = function(value) {\n    return value;\n  };\n  exports.castMutable = function(draft) {\n    return draft;\n  };\n  exports.create = create;\n  exports.current = current;\n  exports.isDraft = isDraft;\n  exports.isDraftable = isDraftable;\n  exports.makeCreator = global;\n  exports.markSimpleObject = value => {\n    value && \"object\" === typeof value ? (value = Object.getPrototypeOf(value), null === value ? value = !0 : (value = Object.hasOwnProperty.call(value, \"constructor\") && value.constructor, value = value === Object ? !0 : \"function\" === typeof value && Function.toString.call(value) === constructorString)) : value = !1;\n    if (value) {\n      return dataTypes.immutable;\n    }\n  };\n  exports.original = function(target) {\n    const proxyDraft = getProxyDraft(target);\n    if (!proxyDraft) {\n      throw Error(`original() is only used for a draft, parameter: ${target}`);\n    }\n    return proxyDraft.original;\n  };\n  exports.rawReturn = function(value) {\n    if (0 === arguments.length) {\n      throw Error(\"rawReturn() must be called with a value.\");\n    }\n    if (1 < arguments.length) {\n      throw Error(\"rawReturn() must be called with one argument.\");\n    }\n    void 0 === value || \"object\" === typeof value && null !== value || console.warn(\"rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().\");\n    return {[RAW_RETURN_SYMBOL]:[value]};\n  };\n  exports.unsafe = function(callback) {\n    readable = !0;\n    let result;\n    try {\n      result = callback();\n    } finally {\n      readable = !1;\n    }\n    return result;\n  };\n};\n","~:source","shadow$provide[\"module$node_modules$mutative$dist$mutative_cjs_development\"] = function(global,require,module,exports) {\n'use strict';\n\nconst Operation = {\n    Remove: 'remove',\n    Replace: 'replace',\n    Add: 'add',\n};\n\n// Don't use `Symbol()` just for 3rd party access the draft\nconst PROXY_DRAFT = Symbol.for('__MUTATIVE_PROXY_DRAFT__');\nconst RAW_RETURN_SYMBOL = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__');\nconst iteratorSymbol = Symbol.iterator;\nconst dataTypes = {\n    mutable: 'mutable',\n    immutable: 'immutable',\n};\n\nconst internal = {};\n\nfunction has(target, key) {\n    return target instanceof Map\n        ? target.has(key)\n        : Object.prototype.hasOwnProperty.call(target, key);\n}\nfunction getDescriptor(target, key) {\n    if (key in target) {\n        let prototype = Reflect.getPrototypeOf(target);\n        while (prototype) {\n            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);\n            if (descriptor)\n                return descriptor;\n            prototype = Reflect.getPrototypeOf(prototype);\n        }\n    }\n    return;\n}\nfunction isBaseSetInstance(obj) {\n    return Object.getPrototypeOf(obj) === Set.prototype;\n}\nfunction isBaseMapInstance(obj) {\n    return Object.getPrototypeOf(obj) === Map.prototype;\n}\n\nfunction latest(proxyDraft) {\n    var _a;\n    return (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original;\n}\n/**\n * Check if the value is a draft\n */\nfunction isDraft(target) {\n    return !!getProxyDraft(target);\n}\nfunction getProxyDraft(value) {\n    if (typeof value !== 'object')\n        return null;\n    return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];\n}\nfunction getValue(value) {\n    var _a;\n    const proxyDraft = getProxyDraft(value);\n    return proxyDraft ? (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original : value;\n}\n/**\n * Check if a value is draftable\n */\nfunction isDraftable(value, options) {\n    if (!value || typeof value !== 'object')\n        return false;\n    let markResult;\n    return (Object.getPrototypeOf(value) === Object.prototype ||\n        Array.isArray(value) ||\n        value instanceof Map ||\n        value instanceof Set ||\n        (!!(options === null || options === void 0 ? void 0 : options.mark) &&\n            ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable ||\n                typeof markResult === 'function')));\n}\nfunction getPath(target, path = []) {\n    if (Object.hasOwnProperty.call(target, 'key')) {\n        // check if the parent is a draft and the original value is not equal to the current value\n        const parentCopy = target.parent.copy;\n        const proxyDraft = getProxyDraft(get(parentCopy, target.key));\n        if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {\n            return null;\n        }\n        const isSet = target.parent.type === 3 /* DraftType.Set */;\n        const key = isSet\n            ? Array.from(target.parent.setMap.keys()).indexOf(target.key)\n            : target.key;\n        // check if the key is still in the next state parent\n        if (!((isSet && parentCopy.size > key) || has(parentCopy, key)))\n            return null;\n        path.push(key);\n    }\n    if (target.parent) {\n        return getPath(target.parent, path);\n    }\n    // `target` is root draft.\n    path.reverse();\n    try {\n        // check if the path is valid\n        resolvePath(target.copy, path);\n    }\n    catch (e) {\n        return null;\n    }\n    return path;\n}\nfunction getType(target) {\n    if (Array.isArray(target))\n        return 1 /* DraftType.Array */;\n    if (target instanceof Map)\n        return 2 /* DraftType.Map */;\n    if (target instanceof Set)\n        return 3 /* DraftType.Set */;\n    return 0 /* DraftType.Object */;\n}\nfunction get(target, key) {\n    return getType(target) === 2 /* DraftType.Map */ ? target.get(key) : target[key];\n}\nfunction set(target, key, value) {\n    const type = getType(target);\n    if (type === 2 /* DraftType.Map */) {\n        target.set(key, value);\n    }\n    else {\n        target[key] = value;\n    }\n}\nfunction peek(target, key) {\n    const state = getProxyDraft(target);\n    const source = state ? latest(state) : target;\n    return source[key];\n}\nfunction isEqual(x, y) {\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    }\n    else {\n        return x !== x && y !== y;\n    }\n}\nfunction revokeProxy(proxyDraft) {\n    if (!proxyDraft)\n        return;\n    while (proxyDraft.finalities.revoke.length > 0) {\n        const revoke = proxyDraft.finalities.revoke.pop();\n        revoke();\n    }\n}\n// handle JSON Pointer path with spec https://www.rfc-editor.org/rfc/rfc6901\nfunction escapePath(path, pathAsArray) {\n    return pathAsArray\n        ? path\n        : ['']\n            .concat(path)\n            .map((_item) => {\n            const item = `${_item}`;\n            if (item.indexOf('/') === -1 && item.indexOf('~') === -1)\n                return item;\n            return item.replace(/~/g, '~0').replace(/\\//g, '~1');\n        })\n            .join('/');\n}\nfunction unescapePath(path) {\n    if (Array.isArray(path))\n        return path;\n    return path\n        .split('/')\n        .map((_item) => _item.replace(/~1/g, '/').replace(/~0/g, '~'))\n        .slice(1);\n}\nfunction resolvePath(base, path) {\n    for (let index = 0; index < path.length - 1; index += 1) {\n        const key = path[index];\n        // use `index` in Set draft\n        base = get(getType(base) === 3 /* DraftType.Set */ ? Array.from(base) : base, key);\n        if (typeof base !== 'object') {\n            throw new Error(`Cannot resolve patch at '${path.join('/')}'.`);\n        }\n    }\n    return base;\n}\n\nfunction strictCopy(target) {\n    const copy = Object.create(Object.getPrototypeOf(target));\n    Reflect.ownKeys(target).forEach((key) => {\n        let desc = Reflect.getOwnPropertyDescriptor(target, key);\n        if (desc.enumerable && desc.configurable && desc.writable) {\n            copy[key] = target[key];\n            return;\n        }\n        // for freeze\n        if (!desc.writable) {\n            desc.writable = true;\n            desc.configurable = true;\n        }\n        if (desc.get || desc.set)\n            desc = {\n                configurable: true,\n                writable: true,\n                enumerable: desc.enumerable,\n                value: target[key],\n            };\n        Reflect.defineProperty(copy, key, desc);\n    });\n    return copy;\n}\nconst propIsEnum = Object.prototype.propertyIsEnumerable;\nfunction shallowCopy(original, options) {\n    let markResult;\n    if (Array.isArray(original)) {\n        return Array.prototype.concat.call(original);\n    }\n    else if (original instanceof Set) {\n        if (!isBaseSetInstance(original)) {\n            const SubClass = Object.getPrototypeOf(original).constructor;\n            return new SubClass(original.values());\n        }\n        return Set.prototype.difference\n            ? Set.prototype.difference.call(original, new Set())\n            : new Set(original.values());\n    }\n    else if (original instanceof Map) {\n        if (!isBaseMapInstance(original)) {\n            const SubClass = Object.getPrototypeOf(original).constructor;\n            return new SubClass(original);\n        }\n        return new Map(original);\n    }\n    else if ((options === null || options === void 0 ? void 0 : options.mark) &&\n        ((markResult = options.mark(original, dataTypes)),\n            markResult !== undefined) &&\n        markResult !== dataTypes.mutable) {\n        if (markResult === dataTypes.immutable) {\n            return strictCopy(original);\n        }\n        else if (typeof markResult === 'function') {\n            if ((options.enablePatches || options.enableAutoFreeze)) {\n                throw new Error(`You can't use mark and patches or auto freeze together.`);\n            }\n            return markResult();\n        }\n        throw new Error(`Unsupported mark result: ${markResult}`);\n    }\n    else if (typeof original === 'object' &&\n        Object.getPrototypeOf(original) === Object.prototype) {\n        // For best performance with shallow copies,\n        // don't use `Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));` by default.\n        const copy = {};\n        Object.keys(original).forEach((key) => {\n            copy[key] = original[key];\n        });\n        Object.getOwnPropertySymbols(original).forEach((key) => {\n            if (propIsEnum.call(original, key)) {\n                copy[key] = original[key];\n            }\n        });\n        return copy;\n    }\n    else {\n        throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);\n    }\n}\nfunction ensureShallowCopy(target) {\n    if (target.copy)\n        return;\n    target.copy = shallowCopy(target.original, target.options);\n}\nfunction deepClone(target) {\n    if (!isDraftable(target))\n        return getValue(target);\n    if (Array.isArray(target))\n        return target.map(deepClone);\n    if (target instanceof Map) {\n        const iterable = Array.from(target.entries()).map(([k, v]) => [\n            k,\n            deepClone(v),\n        ]);\n        if (!isBaseMapInstance(target)) {\n            const SubClass = Object.getPrototypeOf(target).constructor;\n            return new SubClass(iterable);\n        }\n        return new Map(iterable);\n    }\n    if (target instanceof Set) {\n        const iterable = Array.from(target).map(deepClone);\n        if (!isBaseSetInstance(target)) {\n            const SubClass = Object.getPrototypeOf(target).constructor;\n            return new SubClass(iterable);\n        }\n        return new Set(iterable);\n    }\n    const copy = Object.create(Object.getPrototypeOf(target));\n    for (const key in target)\n        copy[key] = deepClone(target[key]);\n    return copy;\n}\nfunction cloneIfNeeded(target) {\n    return isDraft(target) ? deepClone(target) : target;\n}\n\nfunction markChanged(proxyDraft) {\n    var _a;\n    proxyDraft.assignedMap = (_a = proxyDraft.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n    if (!proxyDraft.operated) {\n        proxyDraft.operated = true;\n        if (proxyDraft.parent) {\n            markChanged(proxyDraft.parent);\n        }\n    }\n}\n\nfunction throwFrozenError() {\n    throw new Error('Cannot modify frozen object');\n}\nfunction deepFreeze(target, subKey, updatedValues, stack, keys) {\n    {\n        updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : new WeakMap();\n        stack = stack !== null && stack !== void 0 ? stack : [];\n        keys = keys !== null && keys !== void 0 ? keys : [];\n        const value = updatedValues.has(target)\n            ? updatedValues.get(target)\n            : target;\n        if (stack.length > 0) {\n            const index = stack.indexOf(value);\n            if (value && typeof value === 'object' && index !== -1) {\n                if (stack[0] === value) {\n                    throw new Error(`Forbids circular reference`);\n                }\n                throw new Error(`Forbids circular reference: ~/${keys\n                    .slice(0, index)\n                    .map((key, index) => {\n                    if (typeof key === 'symbol')\n                        return `[${key.toString()}]`;\n                    const parent = stack[index];\n                    if (typeof key === 'object' &&\n                        (parent instanceof Map || parent instanceof Set))\n                        return Array.from(parent.keys()).indexOf(key);\n                    return key;\n                })\n                    .join('/')}`);\n            }\n            stack.push(value);\n            keys.push(subKey);\n        }\n        else {\n            stack.push(value);\n        }\n    }\n    if (Object.isFrozen(target) || isDraft(target)) {\n        {\n            stack.pop();\n            keys.pop();\n        }\n        return;\n    }\n    const type = getType(target);\n    switch (type) {\n        case 2 /* DraftType.Map */:\n            for (const [key, value] of target) {\n                deepFreeze(key, key, updatedValues, stack, keys);\n                deepFreeze(value, key, updatedValues, stack, keys);\n            }\n            target.set = target.clear = target.delete = throwFrozenError;\n            break;\n        case 3 /* DraftType.Set */:\n            for (const value of target) {\n                deepFreeze(value, value, updatedValues, stack, keys);\n            }\n            target.add = target.clear = target.delete = throwFrozenError;\n            break;\n        case 1 /* DraftType.Array */:\n            Object.freeze(target);\n            let index = 0;\n            for (const value of target) {\n                deepFreeze(value, index, updatedValues, stack, keys);\n                index += 1;\n            }\n            break;\n        default:\n            Object.freeze(target);\n            // ignore non-enumerable or symbol properties\n            Object.keys(target).forEach((name) => {\n                const value = target[name];\n                deepFreeze(value, name, updatedValues, stack, keys);\n            });\n    }\n    {\n        stack.pop();\n        keys.pop();\n    }\n}\n\nfunction forEach(target, iter) {\n    const type = getType(target);\n    if (type === 0 /* DraftType.Object */) {\n        Reflect.ownKeys(target).forEach((key) => {\n            iter(key, target[key], target);\n        });\n    }\n    else if (type === 1 /* DraftType.Array */) {\n        let index = 0;\n        for (const entry of target) {\n            iter(index, entry, target);\n            index += 1;\n        }\n    }\n    else {\n        target.forEach((entry, index) => iter(index, entry, target));\n    }\n}\n\nfunction handleValue(target, handledSet, options) {\n    if (isDraft(target) ||\n        !isDraftable(target, options) ||\n        handledSet.has(target) ||\n        Object.isFrozen(target))\n        return;\n    const isSet = target instanceof Set;\n    const setMap = isSet ? new Map() : undefined;\n    handledSet.add(target);\n    forEach(target, (key, value) => {\n        var _a;\n        if (isDraft(value)) {\n            const proxyDraft = getProxyDraft(value);\n            ensureShallowCopy(proxyDraft);\n            // A draft where a child node has been changed, or assigned a value\n            const updatedValue = ((_a = proxyDraft.assignedMap) === null || _a === void 0 ? void 0 : _a.size) || proxyDraft.operated\n                ? proxyDraft.copy\n                : proxyDraft.original;\n            // final update value\n            set(isSet ? setMap : target, key, updatedValue);\n        }\n        else {\n            handleValue(value, handledSet, options);\n        }\n    });\n    if (setMap) {\n        const set = target;\n        const values = Array.from(set);\n        set.clear();\n        values.forEach((value) => {\n            set.add(setMap.has(value) ? setMap.get(value) : value);\n        });\n    }\n}\nfunction finalizeAssigned(proxyDraft, key) {\n    // handle the draftable assigned values and the value is not a draft\n    const copy = proxyDraft.type === 3 /* DraftType.Set */ ? proxyDraft.setMap : proxyDraft.copy;\n    if (proxyDraft.finalities.revoke.length > 1 &&\n        proxyDraft.assignedMap.get(key) &&\n        copy) {\n        handleValue(get(copy, key), proxyDraft.finalities.handledSet, proxyDraft.options);\n    }\n}\nfunction finalizeSetValue(target) {\n    if (target.type === 3 /* DraftType.Set */ && target.copy) {\n        target.copy.clear();\n        target.setMap.forEach((value) => {\n            target.copy.add(getValue(value));\n        });\n    }\n}\nfunction finalizePatches(target, generatePatches, patches, inversePatches) {\n    const shouldFinalize = target.operated &&\n        target.assignedMap &&\n        target.assignedMap.size > 0 &&\n        !target.finalized;\n    if (shouldFinalize) {\n        if (patches && inversePatches) {\n            const basePath = getPath(target);\n            if (basePath) {\n                generatePatches(target, basePath, patches, inversePatches);\n            }\n        }\n        target.finalized = true;\n    }\n}\nfunction markFinalization(target, key, value, generatePatches) {\n    const proxyDraft = getProxyDraft(value);\n    if (proxyDraft) {\n        // !case: assign the draft value\n        if (!proxyDraft.callbacks) {\n            proxyDraft.callbacks = [];\n        }\n        proxyDraft.callbacks.push((patches, inversePatches) => {\n            var _a;\n            const copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            if (isEqual(get(copy, key), value)) {\n                let updatedValue = proxyDraft.original;\n                if (proxyDraft.copy) {\n                    updatedValue = proxyDraft.copy;\n                }\n                finalizeSetValue(target);\n                finalizePatches(target, generatePatches, patches, inversePatches);\n                if (target.options.enableAutoFreeze) {\n                    target.options.updatedValues =\n                        (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();\n                    target.options.updatedValues.set(updatedValue, proxyDraft.original);\n                }\n                // final update value\n                set(copy, key, updatedValue);\n            }\n        });\n        if (target.options.enableAutoFreeze) {\n            // !case: assign the draft value in cross draft tree\n            if (proxyDraft.finalities !== target.finalities) {\n                target.options.enableAutoFreeze = false;\n            }\n        }\n    }\n    if (isDraftable(value, target.options)) {\n        // !case: assign the non-draft value\n        target.finalities.draft.push(() => {\n            const copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            if (isEqual(get(copy, key), value)) {\n                finalizeAssigned(target, key);\n            }\n        });\n    }\n}\n\nfunction generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray) {\n    let { original, assignedMap, options } = proxyState;\n    let copy = proxyState.copy;\n    if (copy.length < original.length) {\n        [original, copy] = [copy, original];\n        [patches, inversePatches] = [inversePatches, patches];\n    }\n    for (let index = 0; index < original.length; index += 1) {\n        if (assignedMap.get(index.toString()) && copy[index] !== original[index]) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Replace,\n                path,\n                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n                value: cloneIfNeeded(copy[index]),\n            });\n            inversePatches.push({\n                op: Operation.Replace,\n                path,\n                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n                value: cloneIfNeeded(original[index]),\n            });\n        }\n    }\n    for (let index = original.length; index < copy.length; index += 1) {\n        const _path = basePath.concat([index]);\n        const path = escapePath(_path, pathAsArray);\n        patches.push({\n            op: Operation.Add,\n            path,\n            // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n            value: cloneIfNeeded(copy[index]),\n        });\n    }\n    if (original.length < copy.length) {\n        // https://www.rfc-editor.org/rfc/rfc6902#appendix-A.4\n        // For performance, here we only generate an operation that replaces the length of the array,\n        // which is inconsistent with JSON Patch specification\n        const { arrayLengthAssignment = true } = options.enablePatches;\n        if (arrayLengthAssignment) {\n            const _path = basePath.concat(['length']);\n            const path = escapePath(_path, pathAsArray);\n            inversePatches.push({\n                op: Operation.Replace,\n                path,\n                value: original.length,\n            });\n        }\n        else {\n            for (let index = copy.length; original.length < index; index -= 1) {\n                const _path = basePath.concat([index - 1]);\n                const path = escapePath(_path, pathAsArray);\n                inversePatches.push({\n                    op: Operation.Remove,\n                    path,\n                });\n            }\n        }\n    }\n}\nfunction generatePatchesFromAssigned({ original, copy, assignedMap }, basePath, patches, inversePatches, pathAsArray) {\n    assignedMap.forEach((assignedValue, key) => {\n        const originalValue = get(original, key);\n        const value = cloneIfNeeded(get(copy, key));\n        const op = !assignedValue\n            ? Operation.Remove\n            : has(original, key)\n                ? Operation.Replace\n                : Operation.Add;\n        if (isEqual(originalValue, value) && op === Operation.Replace)\n            return;\n        const _path = basePath.concat(key);\n        const path = escapePath(_path, pathAsArray);\n        patches.push(op === Operation.Remove ? { op, path } : { op, path, value });\n        inversePatches.push(op === Operation.Add\n            ? { op: Operation.Remove, path }\n            : op === Operation.Remove\n                ? { op: Operation.Add, path, value: originalValue }\n                : { op: Operation.Replace, path, value: originalValue });\n    });\n}\nfunction generateSetPatches({ original, copy }, basePath, patches, inversePatches, pathAsArray) {\n    let index = 0;\n    original.forEach((value) => {\n        if (!copy.has(value)) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Remove,\n                path,\n                value,\n            });\n            inversePatches.unshift({\n                op: Operation.Add,\n                path,\n                value,\n            });\n        }\n        index += 1;\n    });\n    index = 0;\n    copy.forEach((value) => {\n        if (!original.has(value)) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Add,\n                path,\n                value,\n            });\n            inversePatches.unshift({\n                op: Operation.Remove,\n                path,\n                value,\n            });\n        }\n        index += 1;\n    });\n}\nfunction generatePatches(proxyState, basePath, patches, inversePatches) {\n    const { pathAsArray = true } = proxyState.options.enablePatches;\n    switch (proxyState.type) {\n        case 0 /* DraftType.Object */:\n        case 2 /* DraftType.Map */:\n            return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);\n        case 1 /* DraftType.Array */:\n            return generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray);\n        case 3 /* DraftType.Set */:\n            return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);\n    }\n}\n\nlet readable = false;\nconst checkReadable = (value, options, ignoreCheckDraftable = false) => {\n    if (typeof value === 'object' &&\n        value !== null &&\n        (!isDraftable(value, options) || ignoreCheckDraftable) &&\n        !readable) {\n        throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);\n    }\n};\n/**\n * `unsafe(callback)` to access mutable data directly in strict mode.\n *\n * ## Example\n *\n * ```ts\n * import { create, unsafe } from '../index';\n *\n * class Foobar {\n *   bar = 1;\n * }\n *\n * const baseState = { foobar: new Foobar() };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *    unsafe(() => {\n *      draft.foobar.bar = 2;\n *    });\n *   },\n *   {\n *     strict: true,\n *   }\n * );\n *\n * expect(state).toBe(baseState);\n * expect(state.foobar).toBe(baseState.foobar);\n * expect(state.foobar.bar).toBe(2);\n * ```\n */\nfunction unsafe(callback) {\n    readable = true;\n    let result;\n    try {\n        result = callback();\n    }\n    finally {\n        readable = false;\n    }\n    return result;\n}\n\nconst mapHandler = {\n    get size() {\n        const current = latest(getProxyDraft(this));\n        return current.size;\n    },\n    has(key) {\n        return latest(getProxyDraft(this)).has(key);\n    },\n    set(key, value) {\n        const target = getProxyDraft(this);\n        const source = latest(target);\n        if (!source.has(key) || !isEqual(source.get(key), value)) {\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(key, true);\n            target.copy.set(key, value);\n            markFinalization(target, key, value, generatePatches);\n        }\n        return this;\n    },\n    delete(key) {\n        if (!this.has(key)) {\n            return false;\n        }\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        if (target.original.has(key)) {\n            target.assignedMap.set(key, false);\n        }\n        else {\n            target.assignedMap.delete(key);\n        }\n        target.copy.delete(key);\n        return true;\n    },\n    clear() {\n        const target = getProxyDraft(this);\n        if (!this.size)\n            return;\n        ensureShallowCopy(target);\n        markChanged(target);\n        target.assignedMap = new Map();\n        for (const [key] of target.original) {\n            target.assignedMap.set(key, false);\n        }\n        target.copy.clear();\n    },\n    forEach(callback, thisArg) {\n        const target = getProxyDraft(this);\n        latest(target).forEach((_value, _key) => {\n            callback.call(thisArg, this.get(_key), _key, this);\n        });\n    },\n    get(key) {\n        var _a, _b;\n        const target = getProxyDraft(this);\n        const value = latest(target).get(key);\n        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\n        if (target.options.strict) {\n            checkReadable(value, target.options, mutable);\n        }\n        if (mutable) {\n            return value;\n        }\n        if (target.finalized || !isDraftable(value, target.options)) {\n            return value;\n        }\n        // drafted or reassigned\n        if (value !== target.original.get(key)) {\n            return value;\n        }\n        const draft = internal.createDraft({\n            original: value,\n            parentDraft: target,\n            key,\n            finalities: target.finalities,\n            options: target.options,\n        });\n        ensureShallowCopy(target);\n        target.copy.set(key, draft);\n        return draft;\n    },\n    keys() {\n        return latest(getProxyDraft(this)).keys();\n    },\n    values() {\n        const iterator = this.keys();\n        return {\n            [iteratorSymbol]: () => this.values(),\n            next: () => {\n                const result = iterator.next();\n                if (result.done)\n                    return result;\n                const value = this.get(result.value);\n                return {\n                    done: false,\n                    value,\n                };\n            },\n        };\n    },\n    entries() {\n        const iterator = this.keys();\n        return {\n            [iteratorSymbol]: () => this.entries(),\n            next: () => {\n                const result = iterator.next();\n                if (result.done)\n                    return result;\n                const value = this.get(result.value);\n                return {\n                    done: false,\n                    value: [result.value, value],\n                };\n            },\n        };\n    },\n    [iteratorSymbol]() {\n        return this.entries();\n    },\n};\nconst mapHandlerKeys = Reflect.ownKeys(mapHandler);\n\nconst getNextIterator = (target, iterator, { isValuesIterator }) => () => {\n    var _a, _b;\n    const result = iterator.next();\n    if (result.done)\n        return result;\n    const key = result.value;\n    let value = target.setMap.get(key);\n    const currentDraft = getProxyDraft(value);\n    const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\n    if (target.options.strict) {\n        checkReadable(key, target.options, mutable);\n    }\n    if (!mutable &&\n        !currentDraft &&\n        isDraftable(key, target.options) &&\n        !target.finalized &&\n        target.original.has(key)) {\n        // draft a draftable original set item\n        const proxy = internal.createDraft({\n            original: key,\n            parentDraft: target,\n            key,\n            finalities: target.finalities,\n            options: target.options,\n        });\n        target.setMap.set(key, proxy);\n        value = proxy;\n    }\n    else if (currentDraft) {\n        // drafted\n        value = currentDraft.proxy;\n    }\n    return {\n        done: false,\n        value: isValuesIterator ? value : [value, value],\n    };\n};\nconst setHandler = {\n    get size() {\n        const target = getProxyDraft(this);\n        return target.setMap.size;\n    },\n    has(value) {\n        const target = getProxyDraft(this);\n        // reassigned or non-draftable values\n        if (target.setMap.has(value))\n            return true;\n        ensureShallowCopy(target);\n        const valueProxyDraft = getProxyDraft(value);\n        // drafted\n        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original))\n            return true;\n        return false;\n    },\n    add(value) {\n        const target = getProxyDraft(this);\n        if (!this.has(value)) {\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(value, true);\n            target.setMap.set(value, value);\n            markFinalization(target, value, value, generatePatches);\n        }\n        return this;\n    },\n    delete(value) {\n        if (!this.has(value)) {\n            return false;\n        }\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        const valueProxyDraft = getProxyDraft(value);\n        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {\n            // delete drafted\n            target.assignedMap.set(valueProxyDraft.original, false);\n            return target.setMap.delete(valueProxyDraft.original);\n        }\n        if (!valueProxyDraft && target.setMap.has(value)) {\n            // non-draftable values\n            target.assignedMap.set(value, false);\n        }\n        else {\n            // reassigned\n            target.assignedMap.delete(value);\n        }\n        // delete reassigned or non-draftable values\n        return target.setMap.delete(value);\n    },\n    clear() {\n        if (!this.size)\n            return;\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        for (const value of target.original) {\n            target.assignedMap.set(value, false);\n        }\n        target.setMap.clear();\n    },\n    values() {\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        const iterator = target.setMap.keys();\n        return {\n            [Symbol.iterator]: () => this.values(),\n            next: getNextIterator(target, iterator, { isValuesIterator: true }),\n        };\n    },\n    entries() {\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        const iterator = target.setMap.keys();\n        return {\n            [Symbol.iterator]: () => this.entries(),\n            next: getNextIterator(target, iterator, {\n                isValuesIterator: false,\n            }),\n        };\n    },\n    keys() {\n        return this.values();\n    },\n    [iteratorSymbol]() {\n        return this.values();\n    },\n    forEach(callback, thisArg) {\n        const iterator = this.values();\n        let result = iterator.next();\n        while (!result.done) {\n            callback.call(thisArg, result.value, result.value, this);\n            result = iterator.next();\n        }\n    },\n};\nif (Set.prototype.difference) {\n    // for compatibility with new Set methods\n    // https://github.com/tc39/proposal-set-methods\n    // And `https://github.com/tc39/proposal-set-methods/blob/main/details.md#symbolspecies` has some details about the `@@species` symbol.\n    // So we can't use SubSet instance constructor to get the constructor of the SubSet instance.\n    Object.assign(setHandler, {\n        intersection(other) {\n            return Set.prototype.intersection.call(new Set(this.values()), other);\n        },\n        union(other) {\n            return Set.prototype.union.call(new Set(this.values()), other);\n        },\n        difference(other) {\n            return Set.prototype.difference.call(new Set(this.values()), other);\n        },\n        symmetricDifference(other) {\n            return Set.prototype.symmetricDifference.call(new Set(this.values()), other);\n        },\n        isSubsetOf(other) {\n            return Set.prototype.isSubsetOf.call(new Set(this.values()), other);\n        },\n        isSupersetOf(other) {\n            return Set.prototype.isSupersetOf.call(new Set(this.values()), other);\n        },\n        isDisjointFrom(other) {\n            return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);\n        },\n    });\n}\nconst setHandlerKeys = Reflect.ownKeys(setHandler);\n\nconst draftsCache = new WeakSet();\nconst proxyHandler = {\n    get(target, key, receiver) {\n        var _a, _b;\n        const copy = (_a = target.copy) === null || _a === void 0 ? void 0 : _a[key];\n        // Improve draft reading performance by caching the draft copy.\n        if (copy && draftsCache.has(copy)) {\n            return copy;\n        }\n        if (key === PROXY_DRAFT)\n            return target;\n        let markResult;\n        if (target.options.mark) {\n            // handle `Uncaught TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>`\n            // or `Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>`\n            const value = key === 'size' &&\n                (target.original instanceof Map || target.original instanceof Set)\n                ? Reflect.get(target.original, key)\n                : Reflect.get(target.original, key, receiver);\n            markResult = target.options.mark(value, dataTypes);\n            if (markResult === dataTypes.mutable) {\n                if (target.options.strict) {\n                    checkReadable(value, target.options, true);\n                }\n                return value;\n            }\n        }\n        const source = latest(target);\n        if (source instanceof Map && mapHandlerKeys.includes(key)) {\n            if (key === 'size') {\n                return Object.getOwnPropertyDescriptor(mapHandler, 'size').get.call(target.proxy);\n            }\n            const handle = mapHandler[key];\n            if (handle) {\n                return handle.bind(target.proxy);\n            }\n        }\n        if (source instanceof Set && setHandlerKeys.includes(key)) {\n            if (key === 'size') {\n                return Object.getOwnPropertyDescriptor(setHandler, 'size').get.call(target.proxy);\n            }\n            const handle = setHandler[key];\n            if (handle) {\n                return handle.bind(target.proxy);\n            }\n        }\n        if (!has(source, key)) {\n            const desc = getDescriptor(source, key);\n            return desc\n                ? `value` in desc\n                    ? desc.value\n                    : // !case: support for getter\n                        (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy)\n                : undefined;\n        }\n        const value = source[key];\n        if (target.options.strict) {\n            checkReadable(value, target.options);\n        }\n        if (target.finalized || !isDraftable(value, target.options)) {\n            return value;\n        }\n        // Ensure that the assigned values are not drafted\n        if (value === peek(target.original, key)) {\n            ensureShallowCopy(target);\n            target.copy[key] = createDraft({\n                original: target.original[key],\n                parentDraft: target,\n                key: target.type === 1 /* DraftType.Array */ ? Number(key) : key,\n                finalities: target.finalities,\n                options: target.options,\n            });\n            // !case: support for custom shallow copy function\n            if (typeof markResult === 'function') {\n                const subProxyDraft = getProxyDraft(target.copy[key]);\n                ensureShallowCopy(subProxyDraft);\n                // Trigger a custom shallow copy to update to a new copy\n                markChanged(subProxyDraft);\n                return subProxyDraft.copy;\n            }\n            return target.copy[key];\n        }\n        return value;\n    },\n    set(target, key, value) {\n        var _a;\n        if (target.type === 3 /* DraftType.Set */ || target.type === 2 /* DraftType.Map */) {\n            throw new Error(`Map/Set draft does not support any property assignment.`);\n        }\n        let _key;\n        if (target.type === 1 /* DraftType.Array */ &&\n            key !== 'length' &&\n            !(Number.isInteger((_key = Number(key))) &&\n                _key >= 0 &&\n                (key === 0 || _key === 0 || String(_key) === String(key)))) {\n            throw new Error(`Only supports setting array indices and the 'length' property.`);\n        }\n        const desc = getDescriptor(latest(target), key);\n        if (desc === null || desc === void 0 ? void 0 : desc.set) {\n            // !case: cover the case of setter\n            desc.set.call(target.proxy, value);\n            return true;\n        }\n        const current = peek(latest(target), key);\n        const currentProxyDraft = getProxyDraft(current);\n        if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {\n            // !case: ignore the case of assigning the original draftable value to a draft\n            target.copy[key] = value;\n            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n            target.assignedMap.set(key, false);\n            return true;\n        }\n        // !case: handle new props with value 'undefined'\n        if (isEqual(value, current) &&\n            (value !== undefined || has(target.original, key)))\n            return true;\n        ensureShallowCopy(target);\n        markChanged(target);\n        if (has(target.original, key) && isEqual(value, target.original[key])) {\n            // !case: handle the case of assigning the original non-draftable value to a draft\n            target.assignedMap.delete(key);\n        }\n        else {\n            target.assignedMap.set(key, true);\n        }\n        target.copy[key] = value;\n        markFinalization(target, key, value, generatePatches);\n        return true;\n    },\n    has(target, key) {\n        return key in latest(target);\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(latest(target));\n    },\n    getOwnPropertyDescriptor(target, key) {\n        const source = latest(target);\n        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);\n        if (!descriptor)\n            return descriptor;\n        return {\n            writable: true,\n            configurable: target.type !== 1 /* DraftType.Array */ || key !== 'length',\n            enumerable: descriptor.enumerable,\n            value: source[key],\n        };\n    },\n    getPrototypeOf(target) {\n        return Reflect.getPrototypeOf(target.original);\n    },\n    setPrototypeOf() {\n        throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);\n    },\n    defineProperty() {\n        throw new Error(`Cannot call 'defineProperty()' on drafts`);\n    },\n    deleteProperty(target, key) {\n        var _a;\n        if (target.type === 1 /* DraftType.Array */) {\n            return proxyHandler.set.call(this, target, key, undefined, target.proxy);\n        }\n        if (peek(target.original, key) !== undefined || key in target.original) {\n            // !case: delete an existing key\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(key, false);\n        }\n        else {\n            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n            // The original non-existent key has been deleted\n            target.assignedMap.delete(key);\n        }\n        if (target.copy)\n            delete target.copy[key];\n        return true;\n    },\n};\nfunction createDraft(createDraftOptions) {\n    const { original, parentDraft, key, finalities, options } = createDraftOptions;\n    const type = getType(original);\n    const proxyDraft = {\n        type,\n        finalized: false,\n        parent: parentDraft,\n        original,\n        copy: null,\n        proxy: null,\n        finalities,\n        options,\n        // Mapping of draft Set items to their corresponding draft values.\n        setMap: type === 3 /* DraftType.Set */\n            ? new Map(original.entries())\n            : undefined,\n    };\n    // !case: undefined as a draft map key\n    if (key || 'key' in createDraftOptions) {\n        proxyDraft.key = key;\n    }\n    const { proxy, revoke } = Proxy.revocable(type === 1 /* DraftType.Array */ ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);\n    finalities.revoke.push(revoke);\n    draftsCache.add(proxy);\n    proxyDraft.proxy = proxy;\n    if (parentDraft) {\n        const target = parentDraft;\n        target.finalities.draft.push((patches, inversePatches) => {\n            var _a, _b;\n            const oldProxyDraft = getProxyDraft(proxy);\n            // if target is a Set draft, `setMap` is the real Set copies proxy mapping.\n            let copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            const draft = get(copy, key);\n            const proxyDraft = getProxyDraft(draft);\n            if (proxyDraft) {\n                // assign the updated value to the copy object\n                let updatedValue = proxyDraft.original;\n                if (proxyDraft.operated) {\n                    updatedValue = getValue(draft);\n                }\n                finalizeSetValue(proxyDraft);\n                finalizePatches(proxyDraft, generatePatches, patches, inversePatches);\n                if (target.options.enableAutoFreeze) {\n                    target.options.updatedValues =\n                        (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();\n                    target.options.updatedValues.set(updatedValue, proxyDraft.original);\n                }\n                // final update value\n                set(copy, key, updatedValue);\n            }\n            // !case: handle the deleted key\n            (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback) => {\n                callback(patches, inversePatches);\n            });\n        });\n    }\n    else {\n        // !case: handle the root draft\n        const target = getProxyDraft(proxy);\n        target.finalities.draft.push((patches, inversePatches) => {\n            finalizeSetValue(target);\n            finalizePatches(target, generatePatches, patches, inversePatches);\n        });\n    }\n    return proxy;\n}\ninternal.createDraft = createDraft;\nfunction finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {\n    var _a;\n    const proxyDraft = getProxyDraft(result);\n    const original = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : result;\n    const hasReturnedValue = !!returnedValue.length;\n    if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {\n        while (proxyDraft.finalities.draft.length > 0) {\n            const finalize = proxyDraft.finalities.draft.pop();\n            finalize(patches, inversePatches);\n        }\n    }\n    const state = hasReturnedValue\n        ? returnedValue[0]\n        : proxyDraft\n            ? proxyDraft.operated\n                ? proxyDraft.copy\n                : proxyDraft.original\n            : result;\n    if (proxyDraft)\n        revokeProxy(proxyDraft);\n    if (enableAutoFreeze) {\n        deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);\n    }\n    return [\n        state,\n        patches && hasReturnedValue\n            ? [{ op: Operation.Replace, path: [], value: returnedValue[0] }]\n            : patches,\n        inversePatches && hasReturnedValue\n            ? [{ op: Operation.Replace, path: [], value: original }]\n            : inversePatches,\n    ];\n}\n\nfunction draftify(baseState, options) {\n    var _a;\n    const finalities = {\n        draft: [],\n        revoke: [],\n        handledSet: new WeakSet(),\n    };\n    let patches;\n    let inversePatches;\n    if (options.enablePatches) {\n        patches = [];\n        inversePatches = [];\n    }\n    const isMutable = ((_a = options.mark) === null || _a === void 0 ? void 0 : _a.call(options, baseState, dataTypes)) === dataTypes.mutable ||\n        !isDraftable(baseState, options);\n    const draft = isMutable\n        ? baseState\n        : createDraft({\n            original: baseState,\n            parentDraft: null,\n            finalities,\n            options,\n        });\n    return [\n        draft,\n        (returnedValue = []) => {\n            const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);\n            return (options.enablePatches\n                ? [finalizedState, finalizedPatches, finalizedInversePatches]\n                : finalizedState);\n        },\n    ];\n}\n\nfunction handleReturnValue(options) {\n    const { rootDraft, value, useRawReturn = false, isRoot = true } = options;\n    forEach(value, (key, item, source) => {\n        const proxyDraft = getProxyDraft(item);\n        // just handle the draft which is created by the same rootDraft\n        if (proxyDraft &&\n            rootDraft &&\n            proxyDraft.finalities === rootDraft.finalities) {\n            options.isContainDraft = true;\n            const currentValue = proxyDraft.original;\n            // final update value, but just handle return value\n            if (source instanceof Set) {\n                const arr = Array.from(source);\n                source.clear();\n                arr.forEach((_item) => source.add(key === _item ? currentValue : _item));\n            }\n            else {\n                set(source, key, currentValue);\n            }\n        }\n        else if (typeof item === 'object' && item !== null) {\n            options.value = item;\n            options.isRoot = false;\n            handleReturnValue(options);\n        }\n    });\n    if (isRoot) {\n        if (!options.isContainDraft)\n            console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);\n        if (useRawReturn) {\n            console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);\n        }\n    }\n}\nfunction getCurrent(target) {\n    var _a;\n    const proxyDraft = getProxyDraft(target);\n    if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options))\n        return target;\n    const type = getType(target);\n    if (proxyDraft && !proxyDraft.operated)\n        return proxyDraft.original;\n    let currentValue;\n    function ensureShallowCopy() {\n        currentValue =\n            type === 2 /* DraftType.Map */\n                ? !isBaseMapInstance(target)\n                    ? new (Object.getPrototypeOf(target).constructor)(target)\n                    : new Map(target)\n                : type === 3 /* DraftType.Set */\n                    ? Array.from(proxyDraft.setMap.values())\n                    : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);\n    }\n    if (proxyDraft) {\n        // It's a proxy draft, let's create a shallow copy eagerly\n        proxyDraft.finalized = true;\n        try {\n            ensureShallowCopy();\n        }\n        finally {\n            proxyDraft.finalized = false;\n        }\n    }\n    else {\n        // It's not a proxy draft, let's use the target directly and let's see\n        // lazily if we need to create a shallow copy\n        currentValue = target;\n    }\n    forEach(currentValue, (key, value) => {\n        if (proxyDraft && isEqual(get(proxyDraft.original, key), value))\n            return;\n        const newValue = getCurrent(value);\n        if (newValue !== value) {\n            if (currentValue === target)\n                ensureShallowCopy();\n            set(currentValue, key, newValue);\n        }\n    });\n    if (type === 3 /* DraftType.Set */) {\n        const value = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : currentValue;\n        return !isBaseSetInstance(value)\n            ? new (Object.getPrototypeOf(value).constructor)(currentValue)\n            : new Set(currentValue);\n    }\n    return currentValue;\n}\nfunction current(target) {\n    if (!isDraft(target)) {\n        throw new Error(`current() is only used for Draft, parameter: ${target}`);\n    }\n    return getCurrent(target);\n}\n\n/**\n * `makeCreator(options)` to make a creator function.\n *\n * ## Example\n *\n * ```ts\n * import { makeCreator } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const create = makeCreator({ enableAutoFreeze: true });\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * expect(Object.isFrozen(state)).toBeTruthy();\n * ```\n */\nconst makeCreator = (arg) => {\n    if (arg !== undefined &&\n        Object.prototype.toString.call(arg) !== '[object Object]') {\n        throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);\n    }\n    return function create(arg0, arg1, arg2) {\n        var _a, _b, _c;\n        if (typeof arg0 === 'function' && typeof arg1 !== 'function') {\n            return function (base, ...args) {\n                return create(base, (draft) => arg0.call(this, draft, ...args), arg1);\n            };\n        }\n        const base = arg0;\n        const mutate = arg1;\n        let options = arg2;\n        if (typeof arg1 !== 'function') {\n            options = arg1;\n        }\n        if (options !== undefined &&\n            Object.prototype.toString.call(options) !== '[object Object]') {\n            throw new Error(`Invalid options: ${options}, 'options' should be an object.`);\n        }\n        options = Object.assign(Object.assign({}, arg), options);\n        const state = isDraft(base) ? current(base) : base;\n        const mark = Array.isArray(options.mark)\n            ? ((value, types) => {\n                for (const mark of options.mark) {\n                    if (typeof mark !== 'function') {\n                        throw new Error(`Invalid mark: ${mark}, 'mark' should be a function.`);\n                    }\n                    const result = mark(value, types);\n                    if (result) {\n                        return result;\n                    }\n                }\n                return;\n            })\n            : options.mark;\n        const enablePatches = (_a = options.enablePatches) !== null && _a !== void 0 ? _a : false;\n        const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;\n        const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;\n        const _options = {\n            enableAutoFreeze,\n            mark,\n            strict,\n            enablePatches,\n        };\n        if (!isDraftable(state, _options) &&\n            typeof state === 'object' &&\n            state !== null) {\n            throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);\n        }\n        const [draft, finalize] = draftify(state, _options);\n        if (typeof arg1 !== 'function') {\n            if (!isDraftable(state, _options)) {\n                throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);\n            }\n            return [draft, finalize];\n        }\n        let result;\n        try {\n            result = mutate(draft);\n        }\n        catch (error) {\n            revokeProxy(getProxyDraft(draft));\n            throw error;\n        }\n        const returnValue = (value) => {\n            const proxyDraft = getProxyDraft(draft);\n            if (!isDraft(value)) {\n                if (value !== undefined &&\n                    !isEqual(value, draft) &&\n                    (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {\n                    throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);\n                }\n                const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];\n                if (rawReturnValue) {\n                    const _value = rawReturnValue[0];\n                    if (_options.strict && typeof value === 'object' && value !== null) {\n                        handleReturnValue({\n                            rootDraft: proxyDraft,\n                            value,\n                            useRawReturn: true,\n                        });\n                    }\n                    return finalize([_value]);\n                }\n                if (value !== undefined) {\n                    if (typeof value === 'object' && value !== null) {\n                        handleReturnValue({ rootDraft: proxyDraft, value });\n                    }\n                    return finalize([value]);\n                }\n            }\n            if (value === draft || value === undefined) {\n                return finalize([]);\n            }\n            const returnedProxyDraft = getProxyDraft(value);\n            if (_options === returnedProxyDraft.options) {\n                if (returnedProxyDraft.operated) {\n                    throw new Error(`Cannot return a modified child draft.`);\n                }\n                return finalize([current(value)]);\n            }\n            return finalize([value]);\n        };\n        if (result instanceof Promise) {\n            return result.then(returnValue, (error) => {\n                revokeProxy(getProxyDraft(draft));\n                throw error;\n            });\n        }\n        return returnValue(result);\n    };\n};\n\n/**\n * `create(baseState, callback, options)` to create the next state\n *\n * ## Example\n *\n * ```ts\n * import { create } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * ```\n */\nconst create = makeCreator();\n\n/**\n * `apply(state, patches)` to apply patches to state\n *\n * ## Example\n *\n * ```ts\n * import { create, apply } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const [state, patches] = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n *   { enablePatches: true }\n * );\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(patches).toEqual([{ op: 'replace', path: ['foo', 'bar'], value: 'str2' }]);\n * expect(state).toEqual(apply(baseState, patches));\n * ```\n */\nfunction apply(state, patches, applyOptions) {\n    let i;\n    for (i = patches.length - 1; i >= 0; i -= 1) {\n        const { value, op, path } = patches[i];\n        if ((!path.length && op === Operation.Replace) ||\n            (path === '' && op === Operation.Add)) {\n            state = value;\n            break;\n        }\n    }\n    if (i > -1) {\n        patches = patches.slice(i + 1);\n    }\n    const mutate = (draft) => {\n        patches.forEach((patch) => {\n            const { path: _path, op } = patch;\n            const path = unescapePath(_path);\n            let base = draft;\n            for (let index = 0; index < path.length - 1; index += 1) {\n                const parentType = getType(base);\n                let key = path[index];\n                if (typeof key !== 'string' && typeof key !== 'number') {\n                    key = String(key);\n                }\n                if (((parentType === 0 /* DraftType.Object */ ||\n                    parentType === 1 /* DraftType.Array */) &&\n                    (key === '__proto__' || key === 'constructor')) ||\n                    (typeof base === 'function' && key === 'prototype')) {\n                    throw new Error(`Patching reserved attributes like __proto__ and constructor is not allowed.`);\n                }\n                // use `index` in Set draft\n                base = get(parentType === 3 /* DraftType.Set */ ? Array.from(base) : base, key);\n                if (typeof base !== 'object') {\n                    throw new Error(`Cannot apply patch at '${path.join('/')}'.`);\n                }\n            }\n            const type = getType(base);\n            // ensure the original patch is not modified.\n            const value = deepClone(patch.value);\n            const key = path[path.length - 1];\n            switch (op) {\n                case Operation.Replace:\n                    switch (type) {\n                        case 2 /* DraftType.Map */:\n                            return base.set(key, value);\n                        case 3 /* DraftType.Set */:\n                            throw new Error(`Cannot apply replace patch to set.`);\n                        default:\n                            return (base[key] = value);\n                    }\n                case Operation.Add:\n                    switch (type) {\n                        case 1 /* DraftType.Array */:\n                            // If the \"-\" character is used to\n                            // index the end of the array (see [RFC6901](https://datatracker.ietf.org/doc/html/rfc6902)),\n                            // this has the effect of appending the value to the array.\n                            return key === '-'\n                                ? base.push(value)\n                                : base.splice(key, 0, value);\n                        case 2 /* DraftType.Map */:\n                            return base.set(key, value);\n                        case 3 /* DraftType.Set */:\n                            return base.add(value);\n                        default:\n                            return (base[key] = value);\n                    }\n                case Operation.Remove:\n                    switch (type) {\n                        case 1 /* DraftType.Array */:\n                            return base.splice(key, 1);\n                        case 2 /* DraftType.Map */:\n                            return base.delete(key);\n                        case 3 /* DraftType.Set */:\n                            return base.delete(patch.value);\n                        default:\n                            return delete base[key];\n                    }\n                default:\n                    throw new Error(`Unsupported patch operation: ${op}.`);\n            }\n        });\n    };\n    if (isDraft(state)) {\n        if (applyOptions !== undefined) {\n            throw new Error(`Cannot apply patches with options to a draft.`);\n        }\n        mutate(state);\n        return state;\n    }\n    return create(state, mutate, Object.assign(Object.assign({}, applyOptions), { enablePatches: false }));\n}\n\n/**\n * `original(draft)` to get original state in the draft mutation function.\n *\n * ## Example\n *\n * ```ts\n * import { create, original } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *     expect(original(draft.foo)).toEqual({ bar: 'str' });\n *   }\n * );\n * ```\n */\nfunction original(target) {\n    const proxyDraft = getProxyDraft(target);\n    if (!proxyDraft) {\n        throw new Error(`original() is only used for a draft, parameter: ${target}`);\n    }\n    return proxyDraft.original;\n}\n\n/**\n * Use rawReturn() to wrap the return value to skip the draft check and thus improve performance.\n *\n * ## Example\n *\n * ```ts\n * import { create, rawReturn } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     return rawReturn(baseState);\n *   },\n * );\n * expect(state).toBe(baseState);\n * ```\n */\nfunction rawReturn(value) {\n    if (arguments.length === 0) {\n        throw new Error('rawReturn() must be called with a value.');\n    }\n    if (arguments.length > 1) {\n        throw new Error('rawReturn() must be called with one argument.');\n    }\n    if (value !== undefined &&\n        (typeof value !== 'object' || value === null)) {\n        console.warn('rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().');\n    }\n    return {\n        [RAW_RETURN_SYMBOL]: [value],\n    };\n}\n\nconst constructorString = Object.prototype.constructor.toString();\n/**\n * Check if the value is a simple object(No prototype chain object or iframe same-origin object),\n * support case: https://github.com/unadlib/mutative/issues/17\n */\nconst isSimpleObject = (value) => {\n    if (!value || typeof value !== 'object')\n        return false;\n    const prototype = Object.getPrototypeOf(value);\n    if (prototype === null) {\n        return true;\n    }\n    const constructor = Object.hasOwnProperty.call(prototype, 'constructor') &&\n        prototype.constructor;\n    if (constructor === Object)\n        return true;\n    return (typeof constructor === 'function' &&\n        Function.toString.call(constructor) === constructorString);\n};\nconst markSimpleObject = (value) => {\n    if (isSimpleObject(value)) {\n        return dataTypes.immutable;\n    }\n    return;\n};\n\n/**\n * Cast a value to an Draft type value.\n */\nfunction castDraft(value) {\n    return value;\n}\n/**\n * Cast a value to an Immutable type value.\n */\nfunction castImmutable(value) {\n    return value;\n}\n/**\n * Cast a value to an Mutable type value.\n */\nfunction castMutable(draft) {\n    return draft;\n}\n\nexports.apply = apply;\nexports.castDraft = castDraft;\nexports.castImmutable = castImmutable;\nexports.castMutable = castMutable;\nexports.create = create;\nexports.current = current;\nexports.isDraft = isDraft;\nexports.isDraftable = isDraftable;\nexports.makeCreator = makeCreator;\nexports.markSimpleObject = markSimpleObject;\nexports.original = original;\nexports.rawReturn = rawReturn;\nexports.unsafe = unsafe;\n//# sourceMappingURL=mutative.cjs.development.js.map\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["assignedMap","enableAutoFreeze","finalized","next","copy","callbacks","delete","original","isDraft","immutable","key","parent","path","enablePatches","handledSet","unsafe","apply","draft","configurable","value","Add","enumerable","Remove","isDraftable","castDraft","writable","current","isValuesIterator","mutable","Replace","operated","updatedValues","type","makeCreator","rootDraft","parentDraft","finalities","castImmutable","rawReturn","isContainDraft","markSimpleObject","create","add","set","strict","size","op","clear","setMap","proxy","useRawReturn","mark","options","done","isRoot","revoke","castMutable","createDraft"]],"~:compiled-at",1756239699939,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mutative$dist$mutative_cjs_development.js\",\n\"lineCount\":933,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mutative/dist/mutative.cjs.development.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mutative$dist$mutative_cjs_development\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nconst Operation = {\\n    Remove: 'remove',\\n    Replace: 'replace',\\n    Add: 'add',\\n};\\n\\n// Don't use `Symbol()` just for 3rd party access the draft\\nconst PROXY_DRAFT = Symbol.for('__MUTATIVE_PROXY_DRAFT__');\\nconst RAW_RETURN_SYMBOL = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__');\\nconst iteratorSymbol = Symbol.iterator;\\nconst dataTypes = {\\n    mutable: 'mutable',\\n    immutable: 'immutable',\\n};\\n\\nconst internal = {};\\n\\nfunction has(target, key) {\\n    return target instanceof Map\\n        ? target.has(key)\\n        : Object.prototype.hasOwnProperty.call(target, key);\\n}\\nfunction getDescriptor(target, key) {\\n    if (key in target) {\\n        let prototype = Reflect.getPrototypeOf(target);\\n        while (prototype) {\\n            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);\\n            if (descriptor)\\n                return descriptor;\\n            prototype = Reflect.getPrototypeOf(prototype);\\n        }\\n    }\\n    return;\\n}\\nfunction isBaseSetInstance(obj) {\\n    return Object.getPrototypeOf(obj) === Set.prototype;\\n}\\nfunction isBaseMapInstance(obj) {\\n    return Object.getPrototypeOf(obj) === Map.prototype;\\n}\\n\\nfunction latest(proxyDraft) {\\n    var _a;\\n    return (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original;\\n}\\n/**\\n * Check if the value is a draft\\n */\\nfunction isDraft(target) {\\n    return !!getProxyDraft(target);\\n}\\nfunction getProxyDraft(value) {\\n    if (typeof value !== 'object')\\n        return null;\\n    return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];\\n}\\nfunction getValue(value) {\\n    var _a;\\n    const proxyDraft = getProxyDraft(value);\\n    return proxyDraft ? (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original : value;\\n}\\n/**\\n * Check if a value is draftable\\n */\\nfunction isDraftable(value, options) {\\n    if (!value || typeof value !== 'object')\\n        return false;\\n    let markResult;\\n    return (Object.getPrototypeOf(value) === Object.prototype ||\\n        Array.isArray(value) ||\\n        value instanceof Map ||\\n        value instanceof Set ||\\n        (!!(options === null || options === void 0 ? void 0 : options.mark) &&\\n            ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable ||\\n                typeof markResult === 'function')));\\n}\\nfunction getPath(target, path = []) {\\n    if (Object.hasOwnProperty.call(target, 'key')) {\\n        // check if the parent is a draft and the original value is not equal to the current value\\n        const parentCopy = target.parent.copy;\\n        const proxyDraft = getProxyDraft(get(parentCopy, target.key));\\n        if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {\\n            return null;\\n        }\\n        const isSet = target.parent.type === 3 /* DraftType.Set */;\\n        const key = isSet\\n            ? Array.from(target.parent.setMap.keys()).indexOf(target.key)\\n            : target.key;\\n        // check if the key is still in the next state parent\\n        if (!((isSet && parentCopy.size > key) || has(parentCopy, key)))\\n            return null;\\n        path.push(key);\\n    }\\n    if (target.parent) {\\n        return getPath(target.parent, path);\\n    }\\n    // `target` is root draft.\\n    path.reverse();\\n    try {\\n        // check if the path is valid\\n        resolvePath(target.copy, path);\\n    }\\n    catch (e) {\\n        return null;\\n    }\\n    return path;\\n}\\nfunction getType(target) {\\n    if (Array.isArray(target))\\n        return 1 /* DraftType.Array */;\\n    if (target instanceof Map)\\n        return 2 /* DraftType.Map */;\\n    if (target instanceof Set)\\n        return 3 /* DraftType.Set */;\\n    return 0 /* DraftType.Object */;\\n}\\nfunction get(target, key) {\\n    return getType(target) === 2 /* DraftType.Map */ ? target.get(key) : target[key];\\n}\\nfunction set(target, key, value) {\\n    const type = getType(target);\\n    if (type === 2 /* DraftType.Map */) {\\n        target.set(key, value);\\n    }\\n    else {\\n        target[key] = value;\\n    }\\n}\\nfunction peek(target, key) {\\n    const state = getProxyDraft(target);\\n    const source = state ? latest(state) : target;\\n    return source[key];\\n}\\nfunction isEqual(x, y) {\\n    if (x === y) {\\n        return x !== 0 || 1 / x === 1 / y;\\n    }\\n    else {\\n        return x !== x && y !== y;\\n    }\\n}\\nfunction revokeProxy(proxyDraft) {\\n    if (!proxyDraft)\\n        return;\\n    while (proxyDraft.finalities.revoke.length > 0) {\\n        const revoke = proxyDraft.finalities.revoke.pop();\\n        revoke();\\n    }\\n}\\n// handle JSON Pointer path with spec https://www.rfc-editor.org/rfc/rfc6901\\nfunction escapePath(path, pathAsArray) {\\n    return pathAsArray\\n        ? path\\n        : ['']\\n            .concat(path)\\n            .map((_item) => {\\n            const item = `${_item}`;\\n            if (item.indexOf('/') === -1 && item.indexOf('~') === -1)\\n                return item;\\n            return item.replace(/~/g, '~0').replace(/\\\\//g, '~1');\\n        })\\n            .join('/');\\n}\\nfunction unescapePath(path) {\\n    if (Array.isArray(path))\\n        return path;\\n    return path\\n        .split('/')\\n        .map((_item) => _item.replace(/~1/g, '/').replace(/~0/g, '~'))\\n        .slice(1);\\n}\\nfunction resolvePath(base, path) {\\n    for (let index = 0; index < path.length - 1; index += 1) {\\n        const key = path[index];\\n        // use `index` in Set draft\\n        base = get(getType(base) === 3 /* DraftType.Set */ ? Array.from(base) : base, key);\\n        if (typeof base !== 'object') {\\n            throw new Error(`Cannot resolve patch at '${path.join('/')}'.`);\\n        }\\n    }\\n    return base;\\n}\\n\\nfunction strictCopy(target) {\\n    const copy = Object.create(Object.getPrototypeOf(target));\\n    Reflect.ownKeys(target).forEach((key) => {\\n        let desc = Reflect.getOwnPropertyDescriptor(target, key);\\n        if (desc.enumerable && desc.configurable && desc.writable) {\\n            copy[key] = target[key];\\n            return;\\n        }\\n        // for freeze\\n        if (!desc.writable) {\\n            desc.writable = true;\\n            desc.configurable = true;\\n        }\\n        if (desc.get || desc.set)\\n            desc = {\\n                configurable: true,\\n                writable: true,\\n                enumerable: desc.enumerable,\\n                value: target[key],\\n            };\\n        Reflect.defineProperty(copy, key, desc);\\n    });\\n    return copy;\\n}\\nconst propIsEnum = Object.prototype.propertyIsEnumerable;\\nfunction shallowCopy(original, options) {\\n    let markResult;\\n    if (Array.isArray(original)) {\\n        return Array.prototype.concat.call(original);\\n    }\\n    else if (original instanceof Set) {\\n        if (!isBaseSetInstance(original)) {\\n            const SubClass = Object.getPrototypeOf(original).constructor;\\n            return new SubClass(original.values());\\n        }\\n        return Set.prototype.difference\\n            ? Set.prototype.difference.call(original, new Set())\\n            : new Set(original.values());\\n    }\\n    else if (original instanceof Map) {\\n        if (!isBaseMapInstance(original)) {\\n            const SubClass = Object.getPrototypeOf(original).constructor;\\n            return new SubClass(original);\\n        }\\n        return new Map(original);\\n    }\\n    else if ((options === null || options === void 0 ? void 0 : options.mark) &&\\n        ((markResult = options.mark(original, dataTypes)),\\n            markResult !== undefined) &&\\n        markResult !== dataTypes.mutable) {\\n        if (markResult === dataTypes.immutable) {\\n            return strictCopy(original);\\n        }\\n        else if (typeof markResult === 'function') {\\n            if ((options.enablePatches || options.enableAutoFreeze)) {\\n                throw new Error(`You can't use mark and patches or auto freeze together.`);\\n            }\\n            return markResult();\\n        }\\n        throw new Error(`Unsupported mark result: ${markResult}`);\\n    }\\n    else if (typeof original === 'object' &&\\n        Object.getPrototypeOf(original) === Object.prototype) {\\n        // For best performance with shallow copies,\\n        // don't use `Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));` by default.\\n        const copy = {};\\n        Object.keys(original).forEach((key) => {\\n            copy[key] = original[key];\\n        });\\n        Object.getOwnPropertySymbols(original).forEach((key) => {\\n            if (propIsEnum.call(original, key)) {\\n                copy[key] = original[key];\\n            }\\n        });\\n        return copy;\\n    }\\n    else {\\n        throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);\\n    }\\n}\\nfunction ensureShallowCopy(target) {\\n    if (target.copy)\\n        return;\\n    target.copy = shallowCopy(target.original, target.options);\\n}\\nfunction deepClone(target) {\\n    if (!isDraftable(target))\\n        return getValue(target);\\n    if (Array.isArray(target))\\n        return target.map(deepClone);\\n    if (target instanceof Map) {\\n        const iterable = Array.from(target.entries()).map(([k, v]) => [\\n            k,\\n            deepClone(v),\\n        ]);\\n        if (!isBaseMapInstance(target)) {\\n            const SubClass = Object.getPrototypeOf(target).constructor;\\n            return new SubClass(iterable);\\n        }\\n        return new Map(iterable);\\n    }\\n    if (target instanceof Set) {\\n        const iterable = Array.from(target).map(deepClone);\\n        if (!isBaseSetInstance(target)) {\\n            const SubClass = Object.getPrototypeOf(target).constructor;\\n            return new SubClass(iterable);\\n        }\\n        return new Set(iterable);\\n    }\\n    const copy = Object.create(Object.getPrototypeOf(target));\\n    for (const key in target)\\n        copy[key] = deepClone(target[key]);\\n    return copy;\\n}\\nfunction cloneIfNeeded(target) {\\n    return isDraft(target) ? deepClone(target) : target;\\n}\\n\\nfunction markChanged(proxyDraft) {\\n    var _a;\\n    proxyDraft.assignedMap = (_a = proxyDraft.assignedMap) !== null && _a !== void 0 ? _a : new Map();\\n    if (!proxyDraft.operated) {\\n        proxyDraft.operated = true;\\n        if (proxyDraft.parent) {\\n            markChanged(proxyDraft.parent);\\n        }\\n    }\\n}\\n\\nfunction throwFrozenError() {\\n    throw new Error('Cannot modify frozen object');\\n}\\nfunction deepFreeze(target, subKey, updatedValues, stack, keys) {\\n    {\\n        updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : new WeakMap();\\n        stack = stack !== null && stack !== void 0 ? stack : [];\\n        keys = keys !== null && keys !== void 0 ? keys : [];\\n        const value = updatedValues.has(target)\\n            ? updatedValues.get(target)\\n            : target;\\n        if (stack.length > 0) {\\n            const index = stack.indexOf(value);\\n            if (value && typeof value === 'object' && index !== -1) {\\n                if (stack[0] === value) {\\n                    throw new Error(`Forbids circular reference`);\\n                }\\n                throw new Error(`Forbids circular reference: ~/${keys\\n                    .slice(0, index)\\n                    .map((key, index) => {\\n                    if (typeof key === 'symbol')\\n                        return `[${key.toString()}]`;\\n                    const parent = stack[index];\\n                    if (typeof key === 'object' &&\\n                        (parent instanceof Map || parent instanceof Set))\\n                        return Array.from(parent.keys()).indexOf(key);\\n                    return key;\\n                })\\n                    .join('/')}`);\\n            }\\n            stack.push(value);\\n            keys.push(subKey);\\n        }\\n        else {\\n            stack.push(value);\\n        }\\n    }\\n    if (Object.isFrozen(target) || isDraft(target)) {\\n        {\\n            stack.pop();\\n            keys.pop();\\n        }\\n        return;\\n    }\\n    const type = getType(target);\\n    switch (type) {\\n        case 2 /* DraftType.Map */:\\n            for (const [key, value] of target) {\\n                deepFreeze(key, key, updatedValues, stack, keys);\\n                deepFreeze(value, key, updatedValues, stack, keys);\\n            }\\n            target.set = target.clear = target.delete = throwFrozenError;\\n            break;\\n        case 3 /* DraftType.Set */:\\n            for (const value of target) {\\n                deepFreeze(value, value, updatedValues, stack, keys);\\n            }\\n            target.add = target.clear = target.delete = throwFrozenError;\\n            break;\\n        case 1 /* DraftType.Array */:\\n            Object.freeze(target);\\n            let index = 0;\\n            for (const value of target) {\\n                deepFreeze(value, index, updatedValues, stack, keys);\\n                index += 1;\\n            }\\n            break;\\n        default:\\n            Object.freeze(target);\\n            // ignore non-enumerable or symbol properties\\n            Object.keys(target).forEach((name) => {\\n                const value = target[name];\\n                deepFreeze(value, name, updatedValues, stack, keys);\\n            });\\n    }\\n    {\\n        stack.pop();\\n        keys.pop();\\n    }\\n}\\n\\nfunction forEach(target, iter) {\\n    const type = getType(target);\\n    if (type === 0 /* DraftType.Object */) {\\n        Reflect.ownKeys(target).forEach((key) => {\\n            iter(key, target[key], target);\\n        });\\n    }\\n    else if (type === 1 /* DraftType.Array */) {\\n        let index = 0;\\n        for (const entry of target) {\\n            iter(index, entry, target);\\n            index += 1;\\n        }\\n    }\\n    else {\\n        target.forEach((entry, index) => iter(index, entry, target));\\n    }\\n}\\n\\nfunction handleValue(target, handledSet, options) {\\n    if (isDraft(target) ||\\n        !isDraftable(target, options) ||\\n        handledSet.has(target) ||\\n        Object.isFrozen(target))\\n        return;\\n    const isSet = target instanceof Set;\\n    const setMap = isSet ? new Map() : undefined;\\n    handledSet.add(target);\\n    forEach(target, (key, value) => {\\n        var _a;\\n        if (isDraft(value)) {\\n            const proxyDraft = getProxyDraft(value);\\n            ensureShallowCopy(proxyDraft);\\n            // A draft where a child node has been changed, or assigned a value\\n            const updatedValue = ((_a = proxyDraft.assignedMap) === null || _a === void 0 ? void 0 : _a.size) || proxyDraft.operated\\n                ? proxyDraft.copy\\n                : proxyDraft.original;\\n            // final update value\\n            set(isSet ? setMap : target, key, updatedValue);\\n        }\\n        else {\\n            handleValue(value, handledSet, options);\\n        }\\n    });\\n    if (setMap) {\\n        const set = target;\\n        const values = Array.from(set);\\n        set.clear();\\n        values.forEach((value) => {\\n            set.add(setMap.has(value) ? setMap.get(value) : value);\\n        });\\n    }\\n}\\nfunction finalizeAssigned(proxyDraft, key) {\\n    // handle the draftable assigned values\\uff0c and the value is not a draft\\n    const copy = proxyDraft.type === 3 /* DraftType.Set */ ? proxyDraft.setMap : proxyDraft.copy;\\n    if (proxyDraft.finalities.revoke.length > 1 &&\\n        proxyDraft.assignedMap.get(key) &&\\n        copy) {\\n        handleValue(get(copy, key), proxyDraft.finalities.handledSet, proxyDraft.options);\\n    }\\n}\\nfunction finalizeSetValue(target) {\\n    if (target.type === 3 /* DraftType.Set */ && target.copy) {\\n        target.copy.clear();\\n        target.setMap.forEach((value) => {\\n            target.copy.add(getValue(value));\\n        });\\n    }\\n}\\nfunction finalizePatches(target, generatePatches, patches, inversePatches) {\\n    const shouldFinalize = target.operated &&\\n        target.assignedMap &&\\n        target.assignedMap.size > 0 &&\\n        !target.finalized;\\n    if (shouldFinalize) {\\n        if (patches && inversePatches) {\\n            const basePath = getPath(target);\\n            if (basePath) {\\n                generatePatches(target, basePath, patches, inversePatches);\\n            }\\n        }\\n        target.finalized = true;\\n    }\\n}\\nfunction markFinalization(target, key, value, generatePatches) {\\n    const proxyDraft = getProxyDraft(value);\\n    if (proxyDraft) {\\n        // !case: assign the draft value\\n        if (!proxyDraft.callbacks) {\\n            proxyDraft.callbacks = [];\\n        }\\n        proxyDraft.callbacks.push((patches, inversePatches) => {\\n            var _a;\\n            const copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\\n            if (isEqual(get(copy, key), value)) {\\n                let updatedValue = proxyDraft.original;\\n                if (proxyDraft.copy) {\\n                    updatedValue = proxyDraft.copy;\\n                }\\n                finalizeSetValue(target);\\n                finalizePatches(target, generatePatches, patches, inversePatches);\\n                if (target.options.enableAutoFreeze) {\\n                    target.options.updatedValues =\\n                        (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();\\n                    target.options.updatedValues.set(updatedValue, proxyDraft.original);\\n                }\\n                // final update value\\n                set(copy, key, updatedValue);\\n            }\\n        });\\n        if (target.options.enableAutoFreeze) {\\n            // !case: assign the draft value in cross draft tree\\n            if (proxyDraft.finalities !== target.finalities) {\\n                target.options.enableAutoFreeze = false;\\n            }\\n        }\\n    }\\n    if (isDraftable(value, target.options)) {\\n        // !case: assign the non-draft value\\n        target.finalities.draft.push(() => {\\n            const copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\\n            if (isEqual(get(copy, key), value)) {\\n                finalizeAssigned(target, key);\\n            }\\n        });\\n    }\\n}\\n\\nfunction generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray) {\\n    let { original, assignedMap, options } = proxyState;\\n    let copy = proxyState.copy;\\n    if (copy.length < original.length) {\\n        [original, copy] = [copy, original];\\n        [patches, inversePatches] = [inversePatches, patches];\\n    }\\n    for (let index = 0; index < original.length; index += 1) {\\n        if (assignedMap.get(index.toString()) && copy[index] !== original[index]) {\\n            const _path = basePath.concat([index]);\\n            const path = escapePath(_path, pathAsArray);\\n            patches.push({\\n                op: Operation.Replace,\\n                path,\\n                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\\n                value: cloneIfNeeded(copy[index]),\\n            });\\n            inversePatches.push({\\n                op: Operation.Replace,\\n                path,\\n                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\\n                value: cloneIfNeeded(original[index]),\\n            });\\n        }\\n    }\\n    for (let index = original.length; index < copy.length; index += 1) {\\n        const _path = basePath.concat([index]);\\n        const path = escapePath(_path, pathAsArray);\\n        patches.push({\\n            op: Operation.Add,\\n            path,\\n            // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\\n            value: cloneIfNeeded(copy[index]),\\n        });\\n    }\\n    if (original.length < copy.length) {\\n        // https://www.rfc-editor.org/rfc/rfc6902#appendix-A.4\\n        // For performance, here we only generate an operation that replaces the length of the array,\\n        // which is inconsistent with JSON Patch specification\\n        const { arrayLengthAssignment = true } = options.enablePatches;\\n        if (arrayLengthAssignment) {\\n            const _path = basePath.concat(['length']);\\n            const path = escapePath(_path, pathAsArray);\\n            inversePatches.push({\\n                op: Operation.Replace,\\n                path,\\n                value: original.length,\\n            });\\n        }\\n        else {\\n            for (let index = copy.length; original.length < index; index -= 1) {\\n                const _path = basePath.concat([index - 1]);\\n                const path = escapePath(_path, pathAsArray);\\n                inversePatches.push({\\n                    op: Operation.Remove,\\n                    path,\\n                });\\n            }\\n        }\\n    }\\n}\\nfunction generatePatchesFromAssigned({ original, copy, assignedMap }, basePath, patches, inversePatches, pathAsArray) {\\n    assignedMap.forEach((assignedValue, key) => {\\n        const originalValue = get(original, key);\\n        const value = cloneIfNeeded(get(copy, key));\\n        const op = !assignedValue\\n            ? Operation.Remove\\n            : has(original, key)\\n                ? Operation.Replace\\n                : Operation.Add;\\n        if (isEqual(originalValue, value) && op === Operation.Replace)\\n            return;\\n        const _path = basePath.concat(key);\\n        const path = escapePath(_path, pathAsArray);\\n        patches.push(op === Operation.Remove ? { op, path } : { op, path, value });\\n        inversePatches.push(op === Operation.Add\\n            ? { op: Operation.Remove, path }\\n            : op === Operation.Remove\\n                ? { op: Operation.Add, path, value: originalValue }\\n                : { op: Operation.Replace, path, value: originalValue });\\n    });\\n}\\nfunction generateSetPatches({ original, copy }, basePath, patches, inversePatches, pathAsArray) {\\n    let index = 0;\\n    original.forEach((value) => {\\n        if (!copy.has(value)) {\\n            const _path = basePath.concat([index]);\\n            const path = escapePath(_path, pathAsArray);\\n            patches.push({\\n                op: Operation.Remove,\\n                path,\\n                value,\\n            });\\n            inversePatches.unshift({\\n                op: Operation.Add,\\n                path,\\n                value,\\n            });\\n        }\\n        index += 1;\\n    });\\n    index = 0;\\n    copy.forEach((value) => {\\n        if (!original.has(value)) {\\n            const _path = basePath.concat([index]);\\n            const path = escapePath(_path, pathAsArray);\\n            patches.push({\\n                op: Operation.Add,\\n                path,\\n                value,\\n            });\\n            inversePatches.unshift({\\n                op: Operation.Remove,\\n                path,\\n                value,\\n            });\\n        }\\n        index += 1;\\n    });\\n}\\nfunction generatePatches(proxyState, basePath, patches, inversePatches) {\\n    const { pathAsArray = true } = proxyState.options.enablePatches;\\n    switch (proxyState.type) {\\n        case 0 /* DraftType.Object */:\\n        case 2 /* DraftType.Map */:\\n            return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);\\n        case 1 /* DraftType.Array */:\\n            return generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray);\\n        case 3 /* DraftType.Set */:\\n            return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);\\n    }\\n}\\n\\nlet readable = false;\\nconst checkReadable = (value, options, ignoreCheckDraftable = false) => {\\n    if (typeof value === 'object' &&\\n        value !== null &&\\n        (!isDraftable(value, options) || ignoreCheckDraftable) &&\\n        !readable) {\\n        throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);\\n    }\\n};\\n/**\\n * `unsafe(callback)` to access mutable data directly in strict mode.\\n *\\n * ## Example\\n *\\n * ```ts\\n * import { create, unsafe } from '../index';\\n *\\n * class Foobar {\\n *   bar = 1;\\n * }\\n *\\n * const baseState = { foobar: new Foobar() };\\n * const state = create(\\n *   baseState,\\n *   (draft) => {\\n *    unsafe(() => {\\n *      draft.foobar.bar = 2;\\n *    });\\n *   },\\n *   {\\n *     strict: true,\\n *   }\\n * );\\n *\\n * expect(state).toBe(baseState);\\n * expect(state.foobar).toBe(baseState.foobar);\\n * expect(state.foobar.bar).toBe(2);\\n * ```\\n */\\nfunction unsafe(callback) {\\n    readable = true;\\n    let result;\\n    try {\\n        result = callback();\\n    }\\n    finally {\\n        readable = false;\\n    }\\n    return result;\\n}\\n\\nconst mapHandler = {\\n    get size() {\\n        const current = latest(getProxyDraft(this));\\n        return current.size;\\n    },\\n    has(key) {\\n        return latest(getProxyDraft(this)).has(key);\\n    },\\n    set(key, value) {\\n        const target = getProxyDraft(this);\\n        const source = latest(target);\\n        if (!source.has(key) || !isEqual(source.get(key), value)) {\\n            ensureShallowCopy(target);\\n            markChanged(target);\\n            target.assignedMap.set(key, true);\\n            target.copy.set(key, value);\\n            markFinalization(target, key, value, generatePatches);\\n        }\\n        return this;\\n    },\\n    delete(key) {\\n        if (!this.has(key)) {\\n            return false;\\n        }\\n        const target = getProxyDraft(this);\\n        ensureShallowCopy(target);\\n        markChanged(target);\\n        if (target.original.has(key)) {\\n            target.assignedMap.set(key, false);\\n        }\\n        else {\\n            target.assignedMap.delete(key);\\n        }\\n        target.copy.delete(key);\\n        return true;\\n    },\\n    clear() {\\n        const target = getProxyDraft(this);\\n        if (!this.size)\\n            return;\\n        ensureShallowCopy(target);\\n        markChanged(target);\\n        target.assignedMap = new Map();\\n        for (const [key] of target.original) {\\n            target.assignedMap.set(key, false);\\n        }\\n        target.copy.clear();\\n    },\\n    forEach(callback, thisArg) {\\n        const target = getProxyDraft(this);\\n        latest(target).forEach((_value, _key) => {\\n            callback.call(thisArg, this.get(_key), _key, this);\\n        });\\n    },\\n    get(key) {\\n        var _a, _b;\\n        const target = getProxyDraft(this);\\n        const value = latest(target).get(key);\\n        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\\n        if (target.options.strict) {\\n            checkReadable(value, target.options, mutable);\\n        }\\n        if (mutable) {\\n            return value;\\n        }\\n        if (target.finalized || !isDraftable(value, target.options)) {\\n            return value;\\n        }\\n        // drafted or reassigned\\n        if (value !== target.original.get(key)) {\\n            return value;\\n        }\\n        const draft = internal.createDraft({\\n            original: value,\\n            parentDraft: target,\\n            key,\\n            finalities: target.finalities,\\n            options: target.options,\\n        });\\n        ensureShallowCopy(target);\\n        target.copy.set(key, draft);\\n        return draft;\\n    },\\n    keys() {\\n        return latest(getProxyDraft(this)).keys();\\n    },\\n    values() {\\n        const iterator = this.keys();\\n        return {\\n            [iteratorSymbol]: () => this.values(),\\n            next: () => {\\n                const result = iterator.next();\\n                if (result.done)\\n                    return result;\\n                const value = this.get(result.value);\\n                return {\\n                    done: false,\\n                    value,\\n                };\\n            },\\n        };\\n    },\\n    entries() {\\n        const iterator = this.keys();\\n        return {\\n            [iteratorSymbol]: () => this.entries(),\\n            next: () => {\\n                const result = iterator.next();\\n                if (result.done)\\n                    return result;\\n                const value = this.get(result.value);\\n                return {\\n                    done: false,\\n                    value: [result.value, value],\\n                };\\n            },\\n        };\\n    },\\n    [iteratorSymbol]() {\\n        return this.entries();\\n    },\\n};\\nconst mapHandlerKeys = Reflect.ownKeys(mapHandler);\\n\\nconst getNextIterator = (target, iterator, { isValuesIterator }) => () => {\\n    var _a, _b;\\n    const result = iterator.next();\\n    if (result.done)\\n        return result;\\n    const key = result.value;\\n    let value = target.setMap.get(key);\\n    const currentDraft = getProxyDraft(value);\\n    const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\\n    if (target.options.strict) {\\n        checkReadable(key, target.options, mutable);\\n    }\\n    if (!mutable &&\\n        !currentDraft &&\\n        isDraftable(key, target.options) &&\\n        !target.finalized &&\\n        target.original.has(key)) {\\n        // draft a draftable original set item\\n        const proxy = internal.createDraft({\\n            original: key,\\n            parentDraft: target,\\n            key,\\n            finalities: target.finalities,\\n            options: target.options,\\n        });\\n        target.setMap.set(key, proxy);\\n        value = proxy;\\n    }\\n    else if (currentDraft) {\\n        // drafted\\n        value = currentDraft.proxy;\\n    }\\n    return {\\n        done: false,\\n        value: isValuesIterator ? value : [value, value],\\n    };\\n};\\nconst setHandler = {\\n    get size() {\\n        const target = getProxyDraft(this);\\n        return target.setMap.size;\\n    },\\n    has(value) {\\n        const target = getProxyDraft(this);\\n        // reassigned or non-draftable values\\n        if (target.setMap.has(value))\\n            return true;\\n        ensureShallowCopy(target);\\n        const valueProxyDraft = getProxyDraft(value);\\n        // drafted\\n        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original))\\n            return true;\\n        return false;\\n    },\\n    add(value) {\\n        const target = getProxyDraft(this);\\n        if (!this.has(value)) {\\n            ensureShallowCopy(target);\\n            markChanged(target);\\n            target.assignedMap.set(value, true);\\n            target.setMap.set(value, value);\\n            markFinalization(target, value, value, generatePatches);\\n        }\\n        return this;\\n    },\\n    delete(value) {\\n        if (!this.has(value)) {\\n            return false;\\n        }\\n        const target = getProxyDraft(this);\\n        ensureShallowCopy(target);\\n        markChanged(target);\\n        const valueProxyDraft = getProxyDraft(value);\\n        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {\\n            // delete drafted\\n            target.assignedMap.set(valueProxyDraft.original, false);\\n            return target.setMap.delete(valueProxyDraft.original);\\n        }\\n        if (!valueProxyDraft && target.setMap.has(value)) {\\n            // non-draftable values\\n            target.assignedMap.set(value, false);\\n        }\\n        else {\\n            // reassigned\\n            target.assignedMap.delete(value);\\n        }\\n        // delete reassigned or non-draftable values\\n        return target.setMap.delete(value);\\n    },\\n    clear() {\\n        if (!this.size)\\n            return;\\n        const target = getProxyDraft(this);\\n        ensureShallowCopy(target);\\n        markChanged(target);\\n        for (const value of target.original) {\\n            target.assignedMap.set(value, false);\\n        }\\n        target.setMap.clear();\\n    },\\n    values() {\\n        const target = getProxyDraft(this);\\n        ensureShallowCopy(target);\\n        const iterator = target.setMap.keys();\\n        return {\\n            [Symbol.iterator]: () => this.values(),\\n            next: getNextIterator(target, iterator, { isValuesIterator: true }),\\n        };\\n    },\\n    entries() {\\n        const target = getProxyDraft(this);\\n        ensureShallowCopy(target);\\n        const iterator = target.setMap.keys();\\n        return {\\n            [Symbol.iterator]: () => this.entries(),\\n            next: getNextIterator(target, iterator, {\\n                isValuesIterator: false,\\n            }),\\n        };\\n    },\\n    keys() {\\n        return this.values();\\n    },\\n    [iteratorSymbol]() {\\n        return this.values();\\n    },\\n    forEach(callback, thisArg) {\\n        const iterator = this.values();\\n        let result = iterator.next();\\n        while (!result.done) {\\n            callback.call(thisArg, result.value, result.value, this);\\n            result = iterator.next();\\n        }\\n    },\\n};\\nif (Set.prototype.difference) {\\n    // for compatibility with new Set methods\\n    // https://github.com/tc39/proposal-set-methods\\n    // And `https://github.com/tc39/proposal-set-methods/blob/main/details.md#symbolspecies` has some details about the `@@species` symbol.\\n    // So we can't use SubSet instance constructor to get the constructor of the SubSet instance.\\n    Object.assign(setHandler, {\\n        intersection(other) {\\n            return Set.prototype.intersection.call(new Set(this.values()), other);\\n        },\\n        union(other) {\\n            return Set.prototype.union.call(new Set(this.values()), other);\\n        },\\n        difference(other) {\\n            return Set.prototype.difference.call(new Set(this.values()), other);\\n        },\\n        symmetricDifference(other) {\\n            return Set.prototype.symmetricDifference.call(new Set(this.values()), other);\\n        },\\n        isSubsetOf(other) {\\n            return Set.prototype.isSubsetOf.call(new Set(this.values()), other);\\n        },\\n        isSupersetOf(other) {\\n            return Set.prototype.isSupersetOf.call(new Set(this.values()), other);\\n        },\\n        isDisjointFrom(other) {\\n            return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);\\n        },\\n    });\\n}\\nconst setHandlerKeys = Reflect.ownKeys(setHandler);\\n\\nconst draftsCache = new WeakSet();\\nconst proxyHandler = {\\n    get(target, key, receiver) {\\n        var _a, _b;\\n        const copy = (_a = target.copy) === null || _a === void 0 ? void 0 : _a[key];\\n        // Improve draft reading performance by caching the draft copy.\\n        if (copy && draftsCache.has(copy)) {\\n            return copy;\\n        }\\n        if (key === PROXY_DRAFT)\\n            return target;\\n        let markResult;\\n        if (target.options.mark) {\\n            // handle `Uncaught TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>`\\n            // or `Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>`\\n            const value = key === 'size' &&\\n                (target.original instanceof Map || target.original instanceof Set)\\n                ? Reflect.get(target.original, key)\\n                : Reflect.get(target.original, key, receiver);\\n            markResult = target.options.mark(value, dataTypes);\\n            if (markResult === dataTypes.mutable) {\\n                if (target.options.strict) {\\n                    checkReadable(value, target.options, true);\\n                }\\n                return value;\\n            }\\n        }\\n        const source = latest(target);\\n        if (source instanceof Map && mapHandlerKeys.includes(key)) {\\n            if (key === 'size') {\\n                return Object.getOwnPropertyDescriptor(mapHandler, 'size').get.call(target.proxy);\\n            }\\n            const handle = mapHandler[key];\\n            if (handle) {\\n                return handle.bind(target.proxy);\\n            }\\n        }\\n        if (source instanceof Set && setHandlerKeys.includes(key)) {\\n            if (key === 'size') {\\n                return Object.getOwnPropertyDescriptor(setHandler, 'size').get.call(target.proxy);\\n            }\\n            const handle = setHandler[key];\\n            if (handle) {\\n                return handle.bind(target.proxy);\\n            }\\n        }\\n        if (!has(source, key)) {\\n            const desc = getDescriptor(source, key);\\n            return desc\\n                ? `value` in desc\\n                    ? desc.value\\n                    : // !case: support for getter\\n                        (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy)\\n                : undefined;\\n        }\\n        const value = source[key];\\n        if (target.options.strict) {\\n            checkReadable(value, target.options);\\n        }\\n        if (target.finalized || !isDraftable(value, target.options)) {\\n            return value;\\n        }\\n        // Ensure that the assigned values are not drafted\\n        if (value === peek(target.original, key)) {\\n            ensureShallowCopy(target);\\n            target.copy[key] = createDraft({\\n                original: target.original[key],\\n                parentDraft: target,\\n                key: target.type === 1 /* DraftType.Array */ ? Number(key) : key,\\n                finalities: target.finalities,\\n                options: target.options,\\n            });\\n            // !case: support for custom shallow copy function\\n            if (typeof markResult === 'function') {\\n                const subProxyDraft = getProxyDraft(target.copy[key]);\\n                ensureShallowCopy(subProxyDraft);\\n                // Trigger a custom shallow copy to update to a new copy\\n                markChanged(subProxyDraft);\\n                return subProxyDraft.copy;\\n            }\\n            return target.copy[key];\\n        }\\n        return value;\\n    },\\n    set(target, key, value) {\\n        var _a;\\n        if (target.type === 3 /* DraftType.Set */ || target.type === 2 /* DraftType.Map */) {\\n            throw new Error(`Map/Set draft does not support any property assignment.`);\\n        }\\n        let _key;\\n        if (target.type === 1 /* DraftType.Array */ &&\\n            key !== 'length' &&\\n            !(Number.isInteger((_key = Number(key))) &&\\n                _key >= 0 &&\\n                (key === 0 || _key === 0 || String(_key) === String(key)))) {\\n            throw new Error(`Only supports setting array indices and the 'length' property.`);\\n        }\\n        const desc = getDescriptor(latest(target), key);\\n        if (desc === null || desc === void 0 ? void 0 : desc.set) {\\n            // !case: cover the case of setter\\n            desc.set.call(target.proxy, value);\\n            return true;\\n        }\\n        const current = peek(latest(target), key);\\n        const currentProxyDraft = getProxyDraft(current);\\n        if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {\\n            // !case: ignore the case of assigning the original draftable value to a draft\\n            target.copy[key] = value;\\n            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();\\n            target.assignedMap.set(key, false);\\n            return true;\\n        }\\n        // !case: handle new props with value 'undefined'\\n        if (isEqual(value, current) &&\\n            (value !== undefined || has(target.original, key)))\\n            return true;\\n        ensureShallowCopy(target);\\n        markChanged(target);\\n        if (has(target.original, key) && isEqual(value, target.original[key])) {\\n            // !case: handle the case of assigning the original non-draftable value to a draft\\n            target.assignedMap.delete(key);\\n        }\\n        else {\\n            target.assignedMap.set(key, true);\\n        }\\n        target.copy[key] = value;\\n        markFinalization(target, key, value, generatePatches);\\n        return true;\\n    },\\n    has(target, key) {\\n        return key in latest(target);\\n    },\\n    ownKeys(target) {\\n        return Reflect.ownKeys(latest(target));\\n    },\\n    getOwnPropertyDescriptor(target, key) {\\n        const source = latest(target);\\n        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);\\n        if (!descriptor)\\n            return descriptor;\\n        return {\\n            writable: true,\\n            configurable: target.type !== 1 /* DraftType.Array */ || key !== 'length',\\n            enumerable: descriptor.enumerable,\\n            value: source[key],\\n        };\\n    },\\n    getPrototypeOf(target) {\\n        return Reflect.getPrototypeOf(target.original);\\n    },\\n    setPrototypeOf() {\\n        throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);\\n    },\\n    defineProperty() {\\n        throw new Error(`Cannot call 'defineProperty()' on drafts`);\\n    },\\n    deleteProperty(target, key) {\\n        var _a;\\n        if (target.type === 1 /* DraftType.Array */) {\\n            return proxyHandler.set.call(this, target, key, undefined, target.proxy);\\n        }\\n        if (peek(target.original, key) !== undefined || key in target.original) {\\n            // !case: delete an existing key\\n            ensureShallowCopy(target);\\n            markChanged(target);\\n            target.assignedMap.set(key, false);\\n        }\\n        else {\\n            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();\\n            // The original non-existent key has been deleted\\n            target.assignedMap.delete(key);\\n        }\\n        if (target.copy)\\n            delete target.copy[key];\\n        return true;\\n    },\\n};\\nfunction createDraft(createDraftOptions) {\\n    const { original, parentDraft, key, finalities, options } = createDraftOptions;\\n    const type = getType(original);\\n    const proxyDraft = {\\n        type,\\n        finalized: false,\\n        parent: parentDraft,\\n        original,\\n        copy: null,\\n        proxy: null,\\n        finalities,\\n        options,\\n        // Mapping of draft Set items to their corresponding draft values.\\n        setMap: type === 3 /* DraftType.Set */\\n            ? new Map(original.entries())\\n            : undefined,\\n    };\\n    // !case: undefined as a draft map key\\n    if (key || 'key' in createDraftOptions) {\\n        proxyDraft.key = key;\\n    }\\n    const { proxy, revoke } = Proxy.revocable(type === 1 /* DraftType.Array */ ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);\\n    finalities.revoke.push(revoke);\\n    draftsCache.add(proxy);\\n    proxyDraft.proxy = proxy;\\n    if (parentDraft) {\\n        const target = parentDraft;\\n        target.finalities.draft.push((patches, inversePatches) => {\\n            var _a, _b;\\n            const oldProxyDraft = getProxyDraft(proxy);\\n            // if target is a Set draft, `setMap` is the real Set copies proxy mapping.\\n            let copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\\n            const draft = get(copy, key);\\n            const proxyDraft = getProxyDraft(draft);\\n            if (proxyDraft) {\\n                // assign the updated value to the copy object\\n                let updatedValue = proxyDraft.original;\\n                if (proxyDraft.operated) {\\n                    updatedValue = getValue(draft);\\n                }\\n                finalizeSetValue(proxyDraft);\\n                finalizePatches(proxyDraft, generatePatches, patches, inversePatches);\\n                if (target.options.enableAutoFreeze) {\\n                    target.options.updatedValues =\\n                        (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();\\n                    target.options.updatedValues.set(updatedValue, proxyDraft.original);\\n                }\\n                // final update value\\n                set(copy, key, updatedValue);\\n            }\\n            // !case: handle the deleted key\\n            (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback) => {\\n                callback(patches, inversePatches);\\n            });\\n        });\\n    }\\n    else {\\n        // !case: handle the root draft\\n        const target = getProxyDraft(proxy);\\n        target.finalities.draft.push((patches, inversePatches) => {\\n            finalizeSetValue(target);\\n            finalizePatches(target, generatePatches, patches, inversePatches);\\n        });\\n    }\\n    return proxy;\\n}\\ninternal.createDraft = createDraft;\\nfunction finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {\\n    var _a;\\n    const proxyDraft = getProxyDraft(result);\\n    const original = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : result;\\n    const hasReturnedValue = !!returnedValue.length;\\n    if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {\\n        while (proxyDraft.finalities.draft.length > 0) {\\n            const finalize = proxyDraft.finalities.draft.pop();\\n            finalize(patches, inversePatches);\\n        }\\n    }\\n    const state = hasReturnedValue\\n        ? returnedValue[0]\\n        : proxyDraft\\n            ? proxyDraft.operated\\n                ? proxyDraft.copy\\n                : proxyDraft.original\\n            : result;\\n    if (proxyDraft)\\n        revokeProxy(proxyDraft);\\n    if (enableAutoFreeze) {\\n        deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);\\n    }\\n    return [\\n        state,\\n        patches && hasReturnedValue\\n            ? [{ op: Operation.Replace, path: [], value: returnedValue[0] }]\\n            : patches,\\n        inversePatches && hasReturnedValue\\n            ? [{ op: Operation.Replace, path: [], value: original }]\\n            : inversePatches,\\n    ];\\n}\\n\\nfunction draftify(baseState, options) {\\n    var _a;\\n    const finalities = {\\n        draft: [],\\n        revoke: [],\\n        handledSet: new WeakSet(),\\n    };\\n    let patches;\\n    let inversePatches;\\n    if (options.enablePatches) {\\n        patches = [];\\n        inversePatches = [];\\n    }\\n    const isMutable = ((_a = options.mark) === null || _a === void 0 ? void 0 : _a.call(options, baseState, dataTypes)) === dataTypes.mutable ||\\n        !isDraftable(baseState, options);\\n    const draft = isMutable\\n        ? baseState\\n        : createDraft({\\n            original: baseState,\\n            parentDraft: null,\\n            finalities,\\n            options,\\n        });\\n    return [\\n        draft,\\n        (returnedValue = []) => {\\n            const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);\\n            return (options.enablePatches\\n                ? [finalizedState, finalizedPatches, finalizedInversePatches]\\n                : finalizedState);\\n        },\\n    ];\\n}\\n\\nfunction handleReturnValue(options) {\\n    const { rootDraft, value, useRawReturn = false, isRoot = true } = options;\\n    forEach(value, (key, item, source) => {\\n        const proxyDraft = getProxyDraft(item);\\n        // just handle the draft which is created by the same rootDraft\\n        if (proxyDraft &&\\n            rootDraft &&\\n            proxyDraft.finalities === rootDraft.finalities) {\\n            options.isContainDraft = true;\\n            const currentValue = proxyDraft.original;\\n            // final update value, but just handle return value\\n            if (source instanceof Set) {\\n                const arr = Array.from(source);\\n                source.clear();\\n                arr.forEach((_item) => source.add(key === _item ? currentValue : _item));\\n            }\\n            else {\\n                set(source, key, currentValue);\\n            }\\n        }\\n        else if (typeof item === 'object' && item !== null) {\\n            options.value = item;\\n            options.isRoot = false;\\n            handleReturnValue(options);\\n        }\\n    });\\n    if (isRoot) {\\n        if (!options.isContainDraft)\\n            console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);\\n        if (useRawReturn) {\\n            console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);\\n        }\\n    }\\n}\\nfunction getCurrent(target) {\\n    var _a;\\n    const proxyDraft = getProxyDraft(target);\\n    if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options))\\n        return target;\\n    const type = getType(target);\\n    if (proxyDraft && !proxyDraft.operated)\\n        return proxyDraft.original;\\n    let currentValue;\\n    function ensureShallowCopy() {\\n        currentValue =\\n            type === 2 /* DraftType.Map */\\n                ? !isBaseMapInstance(target)\\n                    ? new (Object.getPrototypeOf(target).constructor)(target)\\n                    : new Map(target)\\n                : type === 3 /* DraftType.Set */\\n                    ? Array.from(proxyDraft.setMap.values())\\n                    : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);\\n    }\\n    if (proxyDraft) {\\n        // It's a proxy draft, let's create a shallow copy eagerly\\n        proxyDraft.finalized = true;\\n        try {\\n            ensureShallowCopy();\\n        }\\n        finally {\\n            proxyDraft.finalized = false;\\n        }\\n    }\\n    else {\\n        // It's not a proxy draft, let's use the target directly and let's see\\n        // lazily if we need to create a shallow copy\\n        currentValue = target;\\n    }\\n    forEach(currentValue, (key, value) => {\\n        if (proxyDraft && isEqual(get(proxyDraft.original, key), value))\\n            return;\\n        const newValue = getCurrent(value);\\n        if (newValue !== value) {\\n            if (currentValue === target)\\n                ensureShallowCopy();\\n            set(currentValue, key, newValue);\\n        }\\n    });\\n    if (type === 3 /* DraftType.Set */) {\\n        const value = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : currentValue;\\n        return !isBaseSetInstance(value)\\n            ? new (Object.getPrototypeOf(value).constructor)(currentValue)\\n            : new Set(currentValue);\\n    }\\n    return currentValue;\\n}\\nfunction current(target) {\\n    if (!isDraft(target)) {\\n        throw new Error(`current() is only used for Draft, parameter: ${target}`);\\n    }\\n    return getCurrent(target);\\n}\\n\\n/**\\n * `makeCreator(options)` to make a creator function.\\n *\\n * ## Example\\n *\\n * ```ts\\n * import { makeCreator } from '../index';\\n *\\n * const baseState = { foo: { bar: 'str' }, arr: [] };\\n * const create = makeCreator({ enableAutoFreeze: true });\\n * const state = create(\\n *   baseState,\\n *   (draft) => {\\n *     draft.foo.bar = 'str2';\\n *   },\\n * );\\n *\\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\\n * expect(state).not.toBe(baseState);\\n * expect(state.foo).not.toBe(baseState.foo);\\n * expect(state.arr).toBe(baseState.arr);\\n * expect(Object.isFrozen(state)).toBeTruthy();\\n * ```\\n */\\nconst makeCreator = (arg) => {\\n    if (arg !== undefined &&\\n        Object.prototype.toString.call(arg) !== '[object Object]') {\\n        throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);\\n    }\\n    return function create(arg0, arg1, arg2) {\\n        var _a, _b, _c;\\n        if (typeof arg0 === 'function' && typeof arg1 !== 'function') {\\n            return function (base, ...args) {\\n                return create(base, (draft) => arg0.call(this, draft, ...args), arg1);\\n            };\\n        }\\n        const base = arg0;\\n        const mutate = arg1;\\n        let options = arg2;\\n        if (typeof arg1 !== 'function') {\\n            options = arg1;\\n        }\\n        if (options !== undefined &&\\n            Object.prototype.toString.call(options) !== '[object Object]') {\\n            throw new Error(`Invalid options: ${options}, 'options' should be an object.`);\\n        }\\n        options = Object.assign(Object.assign({}, arg), options);\\n        const state = isDraft(base) ? current(base) : base;\\n        const mark = Array.isArray(options.mark)\\n            ? ((value, types) => {\\n                for (const mark of options.mark) {\\n                    if (typeof mark !== 'function') {\\n                        throw new Error(`Invalid mark: ${mark}, 'mark' should be a function.`);\\n                    }\\n                    const result = mark(value, types);\\n                    if (result) {\\n                        return result;\\n                    }\\n                }\\n                return;\\n            })\\n            : options.mark;\\n        const enablePatches = (_a = options.enablePatches) !== null && _a !== void 0 ? _a : false;\\n        const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;\\n        const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;\\n        const _options = {\\n            enableAutoFreeze,\\n            mark,\\n            strict,\\n            enablePatches,\\n        };\\n        if (!isDraftable(state, _options) &&\\n            typeof state === 'object' &&\\n            state !== null) {\\n            throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);\\n        }\\n        const [draft, finalize] = draftify(state, _options);\\n        if (typeof arg1 !== 'function') {\\n            if (!isDraftable(state, _options)) {\\n                throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);\\n            }\\n            return [draft, finalize];\\n        }\\n        let result;\\n        try {\\n            result = mutate(draft);\\n        }\\n        catch (error) {\\n            revokeProxy(getProxyDraft(draft));\\n            throw error;\\n        }\\n        const returnValue = (value) => {\\n            const proxyDraft = getProxyDraft(draft);\\n            if (!isDraft(value)) {\\n                if (value !== undefined &&\\n                    !isEqual(value, draft) &&\\n                    (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {\\n                    throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);\\n                }\\n                const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];\\n                if (rawReturnValue) {\\n                    const _value = rawReturnValue[0];\\n                    if (_options.strict && typeof value === 'object' && value !== null) {\\n                        handleReturnValue({\\n                            rootDraft: proxyDraft,\\n                            value,\\n                            useRawReturn: true,\\n                        });\\n                    }\\n                    return finalize([_value]);\\n                }\\n                if (value !== undefined) {\\n                    if (typeof value === 'object' && value !== null) {\\n                        handleReturnValue({ rootDraft: proxyDraft, value });\\n                    }\\n                    return finalize([value]);\\n                }\\n            }\\n            if (value === draft || value === undefined) {\\n                return finalize([]);\\n            }\\n            const returnedProxyDraft = getProxyDraft(value);\\n            if (_options === returnedProxyDraft.options) {\\n                if (returnedProxyDraft.operated) {\\n                    throw new Error(`Cannot return a modified child draft.`);\\n                }\\n                return finalize([current(value)]);\\n            }\\n            return finalize([value]);\\n        };\\n        if (result instanceof Promise) {\\n            return result.then(returnValue, (error) => {\\n                revokeProxy(getProxyDraft(draft));\\n                throw error;\\n            });\\n        }\\n        return returnValue(result);\\n    };\\n};\\n\\n/**\\n * `create(baseState, callback, options)` to create the next state\\n *\\n * ## Example\\n *\\n * ```ts\\n * import { create } from '../index';\\n *\\n * const baseState = { foo: { bar: 'str' }, arr: [] };\\n * const state = create(\\n *   baseState,\\n *   (draft) => {\\n *     draft.foo.bar = 'str2';\\n *   },\\n * );\\n *\\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\\n * expect(state).not.toBe(baseState);\\n * expect(state.foo).not.toBe(baseState.foo);\\n * expect(state.arr).toBe(baseState.arr);\\n * ```\\n */\\nconst create = makeCreator();\\n\\n/**\\n * `apply(state, patches)` to apply patches to state\\n *\\n * ## Example\\n *\\n * ```ts\\n * import { create, apply } from '../index';\\n *\\n * const baseState = { foo: { bar: 'str' }, arr: [] };\\n * const [state, patches] = create(\\n *   baseState,\\n *   (draft) => {\\n *     draft.foo.bar = 'str2';\\n *   },\\n *   { enablePatches: true }\\n * );\\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\\n * expect(patches).toEqual([{ op: 'replace', path: ['foo', 'bar'], value: 'str2' }]);\\n * expect(state).toEqual(apply(baseState, patches));\\n * ```\\n */\\nfunction apply(state, patches, applyOptions) {\\n    let i;\\n    for (i = patches.length - 1; i >= 0; i -= 1) {\\n        const { value, op, path } = patches[i];\\n        if ((!path.length && op === Operation.Replace) ||\\n            (path === '' && op === Operation.Add)) {\\n            state = value;\\n            break;\\n        }\\n    }\\n    if (i > -1) {\\n        patches = patches.slice(i + 1);\\n    }\\n    const mutate = (draft) => {\\n        patches.forEach((patch) => {\\n            const { path: _path, op } = patch;\\n            const path = unescapePath(_path);\\n            let base = draft;\\n            for (let index = 0; index < path.length - 1; index += 1) {\\n                const parentType = getType(base);\\n                let key = path[index];\\n                if (typeof key !== 'string' && typeof key !== 'number') {\\n                    key = String(key);\\n                }\\n                if (((parentType === 0 /* DraftType.Object */ ||\\n                    parentType === 1 /* DraftType.Array */) &&\\n                    (key === '__proto__' || key === 'constructor')) ||\\n                    (typeof base === 'function' && key === 'prototype')) {\\n                    throw new Error(`Patching reserved attributes like __proto__ and constructor is not allowed.`);\\n                }\\n                // use `index` in Set draft\\n                base = get(parentType === 3 /* DraftType.Set */ ? Array.from(base) : base, key);\\n                if (typeof base !== 'object') {\\n                    throw new Error(`Cannot apply patch at '${path.join('/')}'.`);\\n                }\\n            }\\n            const type = getType(base);\\n            // ensure the original patch is not modified.\\n            const value = deepClone(patch.value);\\n            const key = path[path.length - 1];\\n            switch (op) {\\n                case Operation.Replace:\\n                    switch (type) {\\n                        case 2 /* DraftType.Map */:\\n                            return base.set(key, value);\\n                        case 3 /* DraftType.Set */:\\n                            throw new Error(`Cannot apply replace patch to set.`);\\n                        default:\\n                            return (base[key] = value);\\n                    }\\n                case Operation.Add:\\n                    switch (type) {\\n                        case 1 /* DraftType.Array */:\\n                            // If the \\\"-\\\" character is used to\\n                            // index the end of the array (see [RFC6901](https://datatracker.ietf.org/doc/html/rfc6902)),\\n                            // this has the effect of appending the value to the array.\\n                            return key === '-'\\n                                ? base.push(value)\\n                                : base.splice(key, 0, value);\\n                        case 2 /* DraftType.Map */:\\n                            return base.set(key, value);\\n                        case 3 /* DraftType.Set */:\\n                            return base.add(value);\\n                        default:\\n                            return (base[key] = value);\\n                    }\\n                case Operation.Remove:\\n                    switch (type) {\\n                        case 1 /* DraftType.Array */:\\n                            return base.splice(key, 1);\\n                        case 2 /* DraftType.Map */:\\n                            return base.delete(key);\\n                        case 3 /* DraftType.Set */:\\n                            return base.delete(patch.value);\\n                        default:\\n                            return delete base[key];\\n                    }\\n                default:\\n                    throw new Error(`Unsupported patch operation: ${op}.`);\\n            }\\n        });\\n    };\\n    if (isDraft(state)) {\\n        if (applyOptions !== undefined) {\\n            throw new Error(`Cannot apply patches with options to a draft.`);\\n        }\\n        mutate(state);\\n        return state;\\n    }\\n    return create(state, mutate, Object.assign(Object.assign({}, applyOptions), { enablePatches: false }));\\n}\\n\\n/**\\n * `original(draft)` to get original state in the draft mutation function.\\n *\\n * ## Example\\n *\\n * ```ts\\n * import { create, original } from '../index';\\n *\\n * const baseState = { foo: { bar: 'str' }, arr: [] };\\n * const state = create(\\n *   baseState,\\n *   (draft) => {\\n *     draft.foo.bar = 'str2';\\n *     expect(original(draft.foo)).toEqual({ bar: 'str' });\\n *   }\\n * );\\n * ```\\n */\\nfunction original(target) {\\n    const proxyDraft = getProxyDraft(target);\\n    if (!proxyDraft) {\\n        throw new Error(`original() is only used for a draft, parameter: ${target}`);\\n    }\\n    return proxyDraft.original;\\n}\\n\\n/**\\n * Use rawReturn() to wrap the return value to skip the draft check and thus improve performance.\\n *\\n * ## Example\\n *\\n * ```ts\\n * import { create, rawReturn } from '../index';\\n *\\n * const baseState = { foo: { bar: 'str' }, arr: [] };\\n * const state = create(\\n *   baseState,\\n *   (draft) => {\\n *     return rawReturn(baseState);\\n *   },\\n * );\\n * expect(state).toBe(baseState);\\n * ```\\n */\\nfunction rawReturn(value) {\\n    if (arguments.length === 0) {\\n        throw new Error('rawReturn() must be called with a value.');\\n    }\\n    if (arguments.length > 1) {\\n        throw new Error('rawReturn() must be called with one argument.');\\n    }\\n    if (value !== undefined &&\\n        (typeof value !== 'object' || value === null)) {\\n        console.warn('rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().');\\n    }\\n    return {\\n        [RAW_RETURN_SYMBOL]: [value],\\n    };\\n}\\n\\nconst constructorString = Object.prototype.constructor.toString();\\n/**\\n * Check if the value is a simple object(No prototype chain object or iframe same-origin object),\\n * support case: https://github.com/unadlib/mutative/issues/17\\n */\\nconst isSimpleObject = (value) => {\\n    if (!value || typeof value !== 'object')\\n        return false;\\n    const prototype = Object.getPrototypeOf(value);\\n    if (prototype === null) {\\n        return true;\\n    }\\n    const constructor = Object.hasOwnProperty.call(prototype, 'constructor') &&\\n        prototype.constructor;\\n    if (constructor === Object)\\n        return true;\\n    return (typeof constructor === 'function' &&\\n        Function.toString.call(constructor) === constructorString);\\n};\\nconst markSimpleObject = (value) => {\\n    if (isSimpleObject(value)) {\\n        return dataTypes.immutable;\\n    }\\n    return;\\n};\\n\\n/**\\n * Cast a value to an Draft type value.\\n */\\nfunction castDraft(value) {\\n    return value;\\n}\\n/**\\n * Cast a value to an Immutable type value.\\n */\\nfunction castImmutable(value) {\\n    return value;\\n}\\n/**\\n * Cast a value to an Mutable type value.\\n */\\nfunction castMutable(draft) {\\n    return draft;\\n}\\n\\nexports.apply = apply;\\nexports.castDraft = castDraft;\\nexports.castImmutable = castImmutable;\\nexports.castMutable = castMutable;\\nexports.create = create;\\nexports.current = current;\\nexports.isDraft = isDraft;\\nexports.isDraftable = isDraftable;\\nexports.makeCreator = makeCreator;\\nexports.markSimpleObject = markSimpleObject;\\nexports.original = original;\\nexports.rawReturn = rawReturn;\\nexports.unsafe = unsafe;\\n//# sourceMappingURL=mutative.cjs.development.js.map\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"has\",\"target\",\"key\",\"Map\",\"Object\",\"prototype\",\"hasOwnProperty\",\"call\",\"getDescriptor\",\"Reflect\",\"getPrototypeOf\",\"descriptor\",\"getOwnPropertyDescriptor\",\"latest\",\"proxyDraft\",\"_a\",\"copy\",\"original\",\"isDraft\",\"getProxyDraft\",\"value\",\"PROXY_DRAFT\",\"getValue\",\"isDraftable\",\"options\",\"markResult\",\"Array\",\"isArray\",\"Set\",\"mark\",\"dataTypes\",\"immutable\",\"getPath\",\"path\",\"parentCopy\",\"parent\",\"get\",\"isSet\",\"type\",\"from\",\"setMap\",\"keys\",\"indexOf\",\"size\",\"push\",\"reverse\",\"index\",\"length\",\"base\",\"getType\",\"Error\",\"join\",\"e\",\"set\",\"peek\",\"state\",\"source\",\"isEqual\",\"x\",\"y\",\"revokeProxy\",\"finalities\",\"revoke\",\"pop\",\"escapePath\",\"pathAsArray\",\"concat\",\"map\",\"_item\",\"item\",\"replace\",\"unescapePath\",\"split\",\"slice\",\"strictCopy\",\"create\",\"ownKeys\",\"forEach\",\"desc\",\"enumerable\",\"configurable\",\"writable\",\"defineProperty\",\"shallowCopy\",\"constructor\",\"values\",\"difference\",\"undefined\",\"mutable\",\"enablePatches\",\"enableAutoFreeze\",\"getOwnPropertySymbols\",\"propIsEnum\",\"ensureShallowCopy\",\"deepClone\",\"iterable\",\"entries\",\"k\",\"v\",\"cloneIfNeeded\",\"markChanged\",\"assignedMap\",\"operated\",\"throwFrozenError\",\"deepFreeze\",\"subKey\",\"updatedValues\",\"stack\",\"WeakMap\",\"toString\",\"isFrozen\",\"clear\",\"delete\",\"add\",\"freeze\",\"name\",\"iter\",\"entry\",\"handleValue\",\"handledSet\",\"updatedValue\",\"finalizeSetValue\",\"finalizePatches\",\"generatePatches\",\"patches\",\"inversePatches\",\"finalized\",\"basePath\",\"markFinalization\",\"callbacks\",\"draft\",\"generatePatchesFromAssigned\",\"assignedValue\",\"originalValue\",\"op\",\"Operation\",\"Replace\",\"Add\",\"Remove\",\"_path\",\"generateSetPatches\",\"unshift\",\"proxyState\",\"arrayLengthAssignment\",\"createDraft\",\"createDraftOptions\",\"parentDraft\",\"proxy\",\"Proxy\",\"revocable\",\"assign\",\"proxyHandler\",\"draftsCache\",\"_b\",\"oldProxyDraft\",\"callback\",\"draftify\",\"baseState\",\"WeakSet\",\"returnedValue\",\"hasReturnedValue\",\"finalize\",\"finalizedState\",\"finalizedPatches\",\"finalizedInversePatches\",\"handleReturnValue\",\"rootDraft\",\"useRawReturn\",\"isRoot\",\"isContainDraft\",\"currentValue\",\"arr\",\"console\",\"warn\",\"getCurrent\",\"newValue\",\"current\",\"Symbol\",\"for\",\"RAW_RETURN_SYMBOL\",\"iteratorSymbol\",\"iterator\",\"internal\",\"propertyIsEnumerable\",\"readable\",\"checkReadable\",\"ignoreCheckDraftable\",\"mapHandler\",\"thisArg\",\"_value\",\"_key\",\"strict\",\"next\",\"result\",\"done\",\"mapHandlerKeys\",\"getNextIterator\",\"isValuesIterator\",\"currentDraft\",\"setHandler\",\"valueProxyDraft\",\"intersection\",\"other\",\"union\",\"symmetricDifference\",\"isSubsetOf\",\"isSupersetOf\",\"isDisjointFrom\",\"setHandlerKeys\",\"receiver\",\"includes\",\"handle\",\"bind\",\"Number\",\"subProxyDraft\",\"isInteger\",\"String\",\"currentProxyDraft\",\"setPrototypeOf\",\"deleteProperty\",\"makeCreator\",\"arg\",\"arg0\",\"arg1\",\"arg2\",\"_c\",\"args\",\"types\",\"_options\",\"error\",\"returnValue\",\"rawReturnValue\",\"returnedProxyDraft\",\"Promise\",\"then\",\"constructorString\",\"apply\",\"applyOptions\",\"i\",\"mutate\",\"patch\",\"parentType\",\"splice\",\"castDraft\",\"castImmutable\",\"castMutable\",\"markSimpleObject\",\"Function\",\"rawReturn\",\"arguments\",\"unsafe\"]\n}\n"]