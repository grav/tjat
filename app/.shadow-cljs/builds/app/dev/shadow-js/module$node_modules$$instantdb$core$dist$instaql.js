["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@instantdb/core/dist/instaql.js"],"~:js","shadow$provide.module$node_modules$$instantdb$core$dist$instaql = function(global, require, module, exports) {\n  function wildcard(friendlyName) {\n    return makeVarImpl(`_${friendlyName}`, _seed++);\n  }\n  function makeVarImpl(x, level) {\n    return `?${x}-${level}`;\n  }\n  function eidWhere(makeVar, store, etype, level) {\n    var JSCompiler_temp_const = makeVar(etype, level);\n    store = s.getPrimaryKeyAttr(store, etype);\n    if (!store) {\n      throw new AttrNotFoundError(`Could not find id attr for ${etype}`);\n    }\n    return [JSCompiler_temp_const, store.id, makeVar(etype, level), makeVar(\"time\", level)];\n  }\n  function replaceInAttrPat(attrPat, needle, v) {\n    return attrPat.map(x => x === needle ? v : x);\n  }\n  function refAttrPat(makeVar, store, etype, level, label) {\n    const fwdAttr = s.getAttrByFwdIdentName(store, etype, label);\n    store = s.getAttrByReverseIdentName(store, etype, label);\n    store = fwdAttr || store;\n    if (!store) {\n      throw new AttrNotFoundError(`Could not find attr for ${[etype, label]}`);\n    }\n    if (\"ref\" !== store[\"value-type\"]) {\n      throw Error(`Attr ${store.id} is not a ref`);\n    }\n    [, etype] = store[\"forward-identity\"];\n    [, label] = store[\"reverse-identity\"];\n    const nextLevel = level + 1;\n    makeVar = fwdAttr ? [makeVar(etype, level), store.id, makeVar(label, nextLevel), wildcard(\"time\")] : [makeVar(etype, nextLevel), store.id, makeVar(label, level), wildcard(\"time\")];\n    return [fwdAttr ? label : etype, nextLevel, makeVar, store, !!fwdAttr];\n  }\n  function makeLikeMatcher(caseSensitive, pattern) {\n    if (\"string\" !== typeof pattern) {\n      return function(_value) {\n        return !1;\n      };\n    }\n    pattern = pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$\\x26\").replace(/%/g, \".*\").replace(/_/g, \".\");\n    const regex = new RegExp(`^${pattern}$`, caseSensitive ? void 0 : \"i\");\n    return function(value) {\n      return \"string\" !== typeof value ? !1 : regex.test(value);\n    };\n  }\n  function parseValue(attr, v) {\n    if (\"object\" !== typeof v || v.hasOwnProperty(\"$in\") || v.hasOwnProperty(\"in\")) {\n      return v;\n    }\n    attr = \"date\" === attr[\"checked-data-type\"];\n    if (v.hasOwnProperty(\"$gt\")) {\n      return {$comparator:!0, $op:attr ? function(triple) {\n        return new Date(triple[2]) > new Date(v.$gt);\n      } : function(triple) {\n        return triple[2] > v.$gt;\n      }};\n    }\n    if (v.hasOwnProperty(\"$gte\")) {\n      return {$comparator:!0, $op:attr ? function(triple) {\n        return new Date(triple[2]) >= new Date(v.$gte);\n      } : function(triple) {\n        return triple[2] >= v.$gte;\n      }};\n    }\n    if (v.hasOwnProperty(\"$lt\")) {\n      return {$comparator:!0, $op:attr ? function(triple) {\n        return new Date(triple[2]) < new Date(v.$lt);\n      } : function(triple) {\n        return triple[2] < v.$lt;\n      }};\n    }\n    if (v.hasOwnProperty(\"$lte\")) {\n      return {$comparator:!0, $op:attr ? function(triple) {\n        return new Date(triple[2]) <= new Date(v.$lte);\n      } : function(triple) {\n        return triple[2] <= v.$lte;\n      }};\n    }\n    if (v.hasOwnProperty(\"$like\")) {\n      const matcher = makeLikeMatcher(!0, v.$like);\n      return {$comparator:!0, $op:function(triple) {\n        return matcher(triple[2]);\n      }};\n    }\n    if (v.hasOwnProperty(\"$ilike\")) {\n      const matcher = makeLikeMatcher(!1, v.$ilike);\n      return {$comparator:!0, $op:function(triple) {\n        return matcher(triple[2]);\n      }};\n    }\n    return v;\n  }\n  function refAttrPats(makeVar, store, etype, level, refsPath) {\n    const [lastEtype, lastLevel, attrPats] = refsPath.reduce((acc, label) => {\n      const [etype, level, attrPats] = acc, [nextEtype, nextLevel, attrPat] = refAttrPat(makeVar, store, etype, level, label);\n      return [nextEtype, nextLevel, [...attrPats, attrPat]];\n    }, [etype, level, []]);\n    return [lastEtype, lastLevel, attrPats];\n  }\n  function whereCondAttrPats(makeVar, store, etype, level, path, v) {\n    const refsPath = path.slice(0, path.length - 1);\n    path = path[path.length - 1];\n    const [lastEtype, lastLevel, refPats] = refAttrPats(makeVar, store, etype, level, refsPath);\n    etype = s.getAttrByFwdIdentName(store, lastEtype, path);\n    level = s.getAttrByReverseIdentName(store, lastEtype, path);\n    level = etype || level;\n    if (!level) {\n      throw new AttrNotFoundError(`No attr for etype = ${lastEtype} label = ${path}`);\n    }\n    if (null === v || void 0 === v ? 0 : v.hasOwnProperty(\"$isNull\")) {\n      store = s.getAttrByFwdIdentName(store, lastEtype, \"id\");\n      if (!store) {\n        throw new AttrNotFoundError(`No attr for etype = ${lastEtype} label = id`);\n      }\n      makeVar = [makeVar(lastEtype, lastLevel), store.id, {$isNull:{attrId:level.id, isNull:v.$isNull, reverse:!etype}}, wildcard(\"time\")];\n    } else {\n      makeVar = etype ? [makeVar(lastEtype, lastLevel), level.id, parseValue(level, v), wildcard(\"time\")] : [v, level.id, makeVar(lastEtype, lastLevel), wildcard(\"time\")];\n    }\n    return refPats.concat([makeVar]);\n  }\n  function isOrClauses([k, v]) {\n    return \"or\" === k && Array.isArray(v);\n  }\n  function isAndClauses([k, v]) {\n    return \"and\" === k && Array.isArray(v);\n  }\n  function genMakeVar(baseMakeVar, joinSym, orIdx) {\n    return (x, lvl) => {\n      x = baseMakeVar(x, lvl);\n      return joinSym == x ? x : `${x}-${orIdx}`;\n    };\n  }\n  function parseWhereClauses(makeVar, clauseType, store, etype, level, whereValue) {\n    const joinSym = makeVar(etype, level);\n    whereValue = whereValue.map((w, i) => {\n      i = genMakeVar(makeVar, joinSym, i);\n      return parseWhere(i, store, etype, level, w);\n    });\n    return {[clauseType]:{patterns:whereValue, joinSym}};\n  }\n  function growPath(path) {\n    const ret = [];\n    for (let i = 1; i <= path.length; i++) {\n      ret.push(path.slice(0, i));\n    }\n    return ret;\n  }\n  function whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path) {\n    return growPath(path).map(path => whereCondAttrPats(makeVar, store, etype, level, path, {$isNull:!0}));\n  }\n  function parseWhere(makeVar, store, etype, level, where) {\n    return Object.entries(where).flatMap(([k, v]) => {\n      if (isOrClauses([k, v])) {\n        return parseWhereClauses(makeVar, \"or\", store, etype, level, v);\n      }\n      if (isAndClauses([k, v])) {\n        return parseWhereClauses(makeVar, \"and\", store, etype, level, v);\n      }\n      if (\"$entityIdStartsWith\" === k) {\n        return [];\n      }\n      k = k.split(\".\");\n      return (null === v || void 0 === v ? 0 : v.hasOwnProperty(\"$not\")) ? (v = whereCondAttrPats(makeVar, store, etype, level, k, v), k = whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, k), [{or:{patterns:[v, ...k], joinSym:makeVar(etype, level)}}]) : (null === v || void 0 === v ? 0 : v.hasOwnProperty(\"$isNull\")) && !0 === v.$isNull && 1 < k.length ? [{or:{patterns:whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, k), joinSym:makeVar(etype, level)}}] : whereCondAttrPats(makeVar, \n      store, etype, level, k, v);\n    });\n  }\n  function extendObjects(makeVar, store, {etype, level, form}, objects) {\n    const childQueries = Object.keys(form).filter(c => \"$\" !== c);\n    return childQueries.length ? Object.entries(objects).map(function([eid, parent]) {\n      return childQueries.map(function(label) {\n        var _a, _b, _c;\n        const isSingular = !!(store.cardinalityInference && (null === (_c = null === (_b = null === (_a = store.linkIndex) || void 0 === _a ? void 0 : _a[etype]) || void 0 === _b ? void 0 : _b[label]) || void 0 === _c ? 0 : _c.isSingular));\n        try {\n          const [nextEtype, nextLevel, pat, attr, isForward] = refAttrPat(makeVar, store, etype, level, label), actualized = replaceInAttrPat(pat, makeVar(etype, level), eid), [nextEtype$jscomp$0, nextLevel$jscomp$0, join] = [nextEtype, nextLevel, actualized, attr, isForward], childrenArray = queryOne(store, {etype:nextEtype$jscomp$0, level:nextLevel$jscomp$0, form:form[label], join});\n          return {[label]:isSingular ? childrenArray[0] : childrenArray};\n        } catch (e) {\n          if (e instanceof AttrNotFoundError) {\n            return {[label]:isSingular ? void 0 : []};\n          }\n          throw e;\n        }\n      }).reduce(function(parent, child) {\n        return Object.assign(Object.assign({}, parent), child);\n      }, parent);\n    }) : Object.values(objects);\n  }\n  function compareOrder([id_a, v_a], [id_b, v_b]) {\n    return v_a === v_b || null == v_a && null == v_b ? (0,uuid_1.uuidCompare)(id_a, id_b) : null == v_b ? 1 : null == v_a ? -1 : v_a > v_b ? 1 : -1;\n  }\n  function comparableDate(x) {\n    return null == x ? x : (new Date(x)).getTime();\n  }\n  function isBefore(startCursor, orderAttr, direction, idVec) {\n    var _a;\n    const [c_e, , c_v, c_t] = startCursor;\n    startCursor = \"desc\" === direction ? 1 : -1;\n    if (\"id\" === (null === (_a = orderAttr[\"forward-identity\"]) || void 0 === _a ? void 0 : _a[2])) {\n      return compareOrder(idVec, [c_e, c_t]) === startCursor;\n    }\n    const [e, v] = idVec;\n    idVec = \"date\" === orderAttr[\"checked-data-type\"] ? comparableDate(v) : v;\n    orderAttr = \"date\" === orderAttr[\"checked-data-type\"] ? comparableDate(c_v) : c_v;\n    return compareOrder([e, idVec], [c_e, orderAttr]) === startCursor;\n  }\n  function getOrderAttr(store, etype, cursor, order) {\n    if (cursor) {\n      return store.attrs[cursor[1]];\n    }\n    if (order) {\n      return cursor = Object.keys(order)[0], s.getAttrByFwdIdentName(store, etype, cursor);\n    }\n  }\n  function runDataloadAndReturnObjects(store, etype, direction, pageInfo, order, dq) {\n    var _a;\n    dq = (0,datalog_1.query)(store, dq);\n    pageInfo = null === pageInfo || void 0 === pageInfo ? void 0 : pageInfo[\"start-cursor\"];\n    if ((order = getOrderAttr(store, etype, pageInfo, order)) && \"id\" !== (null === (_a = null === order || void 0 === order ? void 0 : order[\"forward-identity\"]) || void 0 === _a ? void 0 : _a[2])) {\n      const isDate = \"date\" === order[\"checked-data-type\"], a = order.id;\n      dq = dq.map(([id]) => {\n        var _a, _b, _c, _d, _e;\n        let v = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = store.eav.get(id)) || void 0 === _a ? void 0 : _a.get(a)) || void 0 === _b ? void 0 : _b.values()) || void 0 === _c ? void 0 : _c.next()) || void 0 === _d ? void 0 : _d.value) || void 0 === _e ? void 0 : _e[2];\n        isDate && (v = comparableDate(v));\n        return [id, v];\n      });\n    }\n    dq.sort(\"asc\" === direction ? function(a, b) {\n      return compareOrder(a, b);\n    } : function(a, b) {\n      return compareOrder(b, a);\n    });\n    _a = {};\n    for (const idVec of dq) {\n      [dq] = idVec;\n      if (_a[dq]) {\n        continue;\n      }\n      if (pageInfo && order && isBefore(pageInfo, order, direction, idVec)) {\n        continue;\n      }\n      const obj = s.getAsObject(store, etype, dq);\n      obj && (_a[dq] = obj);\n    }\n    return _a;\n  }\n  function resolveObjects(store, {etype, level, form, join, pageInfo}) {\n    var _a, _b, _c, _d, _e, _g, _h, _j;\n    const limit = (null === (_a = form.$) || void 0 === _a ? void 0 : _a.limit) || (null === (_b = form.$) || void 0 === _b ? void 0 : _b.first) || (null === (_c = form.$) || void 0 === _c ? void 0 : _c.last);\n    _a = null === (_d = form.$) || void 0 === _d ? void 0 : _d.offset;\n    _d = null === (_e = form.$) || void 0 === _e ? void 0 : _e.before;\n    _e = null === (_g = form.$) || void 0 === _g ? void 0 : _g.after;\n    _g = null === (_h = form.$) || void 0 === _h ? void 0 : _h.order;\n    if ((_a || _d || _e) && (!pageInfo || !pageInfo[\"start-cursor\"])) {\n      return [];\n    }\n    _h = null === (_j = form.$) || void 0 === _j ? void 0 : _j.where;\n    _j = makeVarImpl;\n    _j = _h ? parseWhere(_j, store, etype, level, _h).concat([eidWhere(_j, store, etype, level)]) : [eidWhere(_j, store, etype, level)];\n    join = join ? [join].concat(_j) : _j;\n    _j = makeVarImpl;\n    level = [_j(etype, level), _j(\"time\", level)];\n    _j = runDataloadAndReturnObjects;\n    var JSCompiler_inline_result = (form = null === (JSCompiler_inline_result = form.$) || void 0 === JSCompiler_inline_result ? void 0 : JSCompiler_inline_result.order) ? form[Object.keys(form)[0]] || \"asc\" : \"asc\";\n    store = _j(store, etype, JSCompiler_inline_result, pageInfo, _g, {where:join, find:level});\n    return null != limit ? (etype = Object.entries(store), etype.length <= limit ? store : Object.fromEntries(etype.slice(0, limit))) : store;\n  }\n  function queryOne(store, opts) {\n    try {\n      var JSCompiler_inline_result = resolveObjects(store, opts);\n    } catch (e) {\n      if (e instanceof AttrNotFoundError) {\n        JSCompiler_inline_result = {};\n      } else {\n        throw e;\n      }\n    }\n    return extendObjects(makeVarImpl, store, opts, JSCompiler_inline_result);\n  }\n  function formatPageInfo(pageInfo) {\n    const res = {};\n    for (const [k, v] of Object.entries(pageInfo)) {\n      res[k] = {startCursor:v[\"start-cursor\"], endCursor:v[\"end-cursor\"], hasNextPage:v[\"has-next-page?\"], hasPreviousPage:v[\"has-previous-page?\"]};\n    }\n    return res;\n  }\n  var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = {enumerable:!0, get:function() {\n        return m[k];\n      }};\n    }\n    Object.defineProperty(o, k2, desc);\n  } : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    o[k2] = m[k];\n  }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {enumerable:!0, value:v});\n  } : function(o, v) {\n    o[\"default\"] = v;\n  });\n  global = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) {\n      return mod;\n    }\n    var result = {};\n    if (null != mod) {\n      for (var k in mod) {\n        \"default\" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);\n      }\n    }\n    __setModuleDefault(result, mod);\n    return result;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.default = function({store, pageInfo, aggregate}, q) {\n    const result = {data:Object.keys(q).reduce(function(res, k) {\n      if (null === aggregate || void 0 === aggregate ? 0 : aggregate[k]) {\n        return res;\n      }\n      res[k] = queryOne(store, {etype:k, form:q[k], level:0, pageInfo:null === pageInfo || void 0 === pageInfo ? void 0 : pageInfo[k]});\n      return res;\n    }, {})};\n    pageInfo && (result.pageInfo = formatPageInfo(pageInfo));\n    aggregate && (result.aggregate = aggregate);\n    return result;\n  };\n  const datalog_1 = require(\"module$node_modules$$instantdb$core$dist$datalog\"), uuid_1 = require(\"module$node_modules$$instantdb$core$dist$utils$uuid\"), s = global(require(\"module$node_modules$$instantdb$core$dist$store\"));\n  let _seed = 0;\n  class AttrNotFoundError extends Error {\n    constructor(message) {\n      super(message);\n      this.name = \"AttrNotFoundError\";\n    }\n  }\n};\n","~:source","shadow$provide[\"module$node_modules$$instantdb$core$dist$instaql\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = query;\nconst datalog_1 = require(\"./datalog\");\nconst uuid_1 = require(\"./utils/uuid\");\nconst s = __importStar(require(\"./store\"));\n// Pattern variables\n// -----------------\nlet _seed = 0;\nfunction wildcard(friendlyName) {\n    return makeVarImpl(`_${friendlyName}`, _seed++);\n}\nfunction makeVarImpl(x, level) {\n    return `?${x}-${level}`;\n}\n// Where\n// -----------------\nclass AttrNotFoundError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'AttrNotFoundError';\n    }\n}\nfunction idAttr(store, ns) {\n    const attr = s.getPrimaryKeyAttr(store, ns);\n    if (!attr) {\n        throw new AttrNotFoundError(`Could not find id attr for ${ns}`);\n    }\n    return attr;\n}\nfunction defaultWhere(makeVar, store, etype, level) {\n    return [eidWhere(makeVar, store, etype, level)];\n}\nfunction eidWhere(makeVar, store, etype, level) {\n    return [\n        makeVar(etype, level),\n        idAttr(store, etype).id,\n        makeVar(etype, level),\n        makeVar('time', level),\n    ];\n}\nfunction replaceInAttrPat(attrPat, needle, v) {\n    return attrPat.map((x) => (x === needle ? v : x));\n}\nfunction refAttrPat(makeVar, store, etype, level, label) {\n    const fwdAttr = s.getAttrByFwdIdentName(store, etype, label);\n    const revAttr = s.getAttrByReverseIdentName(store, etype, label);\n    const attr = fwdAttr || revAttr;\n    if (!attr) {\n        throw new AttrNotFoundError(`Could not find attr for ${[etype, label]}`);\n    }\n    if (attr['value-type'] !== 'ref') {\n        throw new Error(`Attr ${attr.id} is not a ref`);\n    }\n    const [_f, fwdEtype] = attr['forward-identity'];\n    const [_r, revEtype] = attr['reverse-identity'];\n    const nextLevel = level + 1;\n    const attrPat = fwdAttr\n        ? [\n            makeVar(fwdEtype, level),\n            attr.id,\n            makeVar(revEtype, nextLevel),\n            wildcard('time'),\n        ]\n        : [\n            makeVar(fwdEtype, nextLevel),\n            attr.id,\n            makeVar(revEtype, level),\n            wildcard('time'),\n        ];\n    const nextEtype = fwdAttr ? revEtype : fwdEtype;\n    const isForward = Boolean(fwdAttr);\n    return [nextEtype, nextLevel, attrPat, attr, isForward];\n}\nfunction makeLikeMatcher(caseSensitive, pattern) {\n    if (typeof pattern !== 'string') {\n        return function likeMatcher(_value) {\n            return false;\n        };\n    }\n    const escapedPattern = pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const regexPattern = escapedPattern.replace(/%/g, '.*').replace(/_/g, '.');\n    const regex = new RegExp(`^${regexPattern}$`, caseSensitive ? undefined : 'i');\n    return function likeMatcher(value) {\n        if (typeof value !== 'string') {\n            return false;\n        }\n        return regex.test(value);\n    };\n}\nfunction parseValue(attr, v) {\n    if (typeof v !== 'object' ||\n        v.hasOwnProperty('$in') ||\n        v.hasOwnProperty('in')) {\n        return v;\n    }\n    const isDate = attr['checked-data-type'] === 'date';\n    if (v.hasOwnProperty('$gt')) {\n        return {\n            $comparator: true,\n            $op: isDate\n                ? function gtDate(triple) {\n                    return new Date(triple[2]) > new Date(v.$gt);\n                }\n                : function gt(triple) {\n                    return triple[2] > v.$gt;\n                },\n        };\n    }\n    if (v.hasOwnProperty('$gte')) {\n        return {\n            $comparator: true,\n            $op: isDate\n                ? function gteDate(triple) {\n                    return new Date(triple[2]) >= new Date(v.$gte);\n                }\n                : function gte(triple) {\n                    return triple[2] >= v.$gte;\n                },\n        };\n    }\n    if (v.hasOwnProperty('$lt')) {\n        return {\n            $comparator: true,\n            $op: isDate\n                ? function ltDate(triple) {\n                    return new Date(triple[2]) < new Date(v.$lt);\n                }\n                : function lt(triple) {\n                    return triple[2] < v.$lt;\n                },\n        };\n    }\n    if (v.hasOwnProperty('$lte')) {\n        return {\n            $comparator: true,\n            $op: isDate\n                ? function lteDate(triple) {\n                    return new Date(triple[2]) <= new Date(v.$lte);\n                }\n                : function lte(triple) {\n                    return triple[2] <= v.$lte;\n                },\n        };\n    }\n    if (v.hasOwnProperty('$like')) {\n        const matcher = makeLikeMatcher(true, v.$like);\n        return {\n            $comparator: true,\n            $op: function like(triple) {\n                return matcher(triple[2]);\n            },\n        };\n    }\n    if (v.hasOwnProperty('$ilike')) {\n        const matcher = makeLikeMatcher(false, v.$ilike);\n        return {\n            $comparator: true,\n            $op: function ilike(triple) {\n                return matcher(triple[2]);\n            },\n        };\n    }\n    return v;\n}\nfunction valueAttrPat(makeVar, store, valueEtype, valueLevel, valueLabel, v) {\n    const fwdAttr = s.getAttrByFwdIdentName(store, valueEtype, valueLabel);\n    const revAttr = s.getAttrByReverseIdentName(store, valueEtype, valueLabel);\n    const attr = fwdAttr || revAttr;\n    if (!attr) {\n        throw new AttrNotFoundError(`No attr for etype = ${valueEtype} label = ${valueLabel}`);\n    }\n    if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$isNull')) {\n        const idAttr = s.getAttrByFwdIdentName(store, valueEtype, 'id');\n        if (!idAttr) {\n            throw new AttrNotFoundError(`No attr for etype = ${valueEtype} label = id`);\n        }\n        return [\n            makeVar(valueEtype, valueLevel),\n            idAttr.id,\n            { $isNull: { attrId: attr.id, isNull: v.$isNull, reverse: !fwdAttr } },\n            wildcard('time'),\n        ];\n    }\n    if (fwdAttr) {\n        return [\n            makeVar(valueEtype, valueLevel),\n            attr.id,\n            parseValue(attr, v),\n            wildcard('time'),\n        ];\n    }\n    return [v, attr.id, makeVar(valueEtype, valueLevel), wildcard('time')];\n}\nfunction refAttrPats(makeVar, store, etype, level, refsPath) {\n    const [lastEtype, lastLevel, attrPats] = refsPath.reduce((acc, label) => {\n        const [etype, level, attrPats] = acc;\n        const [nextEtype, nextLevel, attrPat] = refAttrPat(makeVar, store, etype, level, label);\n        return [nextEtype, nextLevel, [...attrPats, attrPat]];\n    }, [etype, level, []]);\n    return [lastEtype, lastLevel, attrPats];\n}\nfunction whereCondAttrPats(makeVar, store, etype, level, path, v) {\n    const refsPath = path.slice(0, path.length - 1);\n    const valueLabel = path[path.length - 1];\n    const [lastEtype, lastLevel, refPats] = refAttrPats(makeVar, store, etype, level, refsPath);\n    const valuePat = valueAttrPat(makeVar, store, lastEtype, lastLevel, valueLabel, v);\n    return refPats.concat([valuePat]);\n}\nfunction withJoin(where, join) {\n    return join ? [join].concat(where) : where;\n}\nfunction isOrClauses([k, v]) {\n    return k === 'or' && Array.isArray(v);\n}\nfunction isAndClauses([k, v]) {\n    return k === 'and' && Array.isArray(v);\n}\n// Creates a makeVar that will namespace symbols for or clauses\n// to prevent conflicts, except for the base etype\nfunction genMakeVar(baseMakeVar, joinSym, orIdx) {\n    return (x, lvl) => {\n        const base = baseMakeVar(x, lvl);\n        if (joinSym == base) {\n            return base;\n        }\n        return `${base}-${orIdx}`;\n    };\n}\nfunction parseWhereClauses(makeVar, clauseType /* 'or' | 'and' */, store, etype, level, whereValue) {\n    const joinSym = makeVar(etype, level);\n    const patterns = whereValue.map((w, i) => {\n        const makeNamespacedVar = genMakeVar(makeVar, joinSym, i);\n        return parseWhere(makeNamespacedVar, store, etype, level, w);\n    });\n    return { [clauseType]: { patterns, joinSym } };\n}\n// Given a path, returns a list of paths leading up to this path:\n// growPath([1, 2, 3]) -> [[1], [1, 2], [1, 2, 3]]\nfunction growPath(path) {\n    const ret = [];\n    for (let i = 1; i <= path.length; i++) {\n        ret.push(path.slice(0, i));\n    }\n    return ret;\n}\n// Returns array of pattern arrays that should be grouped in OR\n// to capture any intermediate nulls\nfunction whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path) {\n    return growPath(path).map((path) => whereCondAttrPats(makeVar, store, etype, level, path, { $isNull: true }));\n}\nfunction parseWhere(makeVar, store, etype, level, where) {\n    return Object.entries(where).flatMap(([k, v]) => {\n        if (isOrClauses([k, v])) {\n            return parseWhereClauses(makeVar, 'or', store, etype, level, v);\n        }\n        if (isAndClauses([k, v])) {\n            return parseWhereClauses(makeVar, 'and', store, etype, level, v);\n        }\n        // Temporary hack until we have support for a uuid index on `id`\n        if (k === '$entityIdStartsWith') {\n            return [];\n        }\n        const path = k.split('.');\n        if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$not')) {\n            // `$not` won't pick up entities that are missing the attr, so we\n            // add in a `$isNull` to catch those too.\n            const notPats = whereCondAttrPats(makeVar, store, etype, level, path, v);\n            const nilPats = whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path);\n            return [\n                {\n                    or: {\n                        patterns: [notPats, ...nilPats],\n                        joinSym: makeVar(etype, level),\n                    },\n                },\n            ];\n        }\n        if ((v === null || v === void 0 ? void 0 : v.hasOwnProperty('$isNull')) && v.$isNull === true && path.length > 1) {\n            // Make sure we're capturing all of the intermediate paths that might be null\n            // by checking for null at each step along the path\n            return [\n                {\n                    or: {\n                        patterns: whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path),\n                        joinSym: makeVar(etype, level),\n                    },\n                },\n            ];\n        }\n        return whereCondAttrPats(makeVar, store, etype, level, path, v);\n    });\n}\nfunction makeWhere(store, etype, level, where) {\n    const makeVar = makeVarImpl;\n    if (!where) {\n        return defaultWhere(makeVar, store, etype, level);\n    }\n    const parsedWhere = parseWhere(makeVar, store, etype, level, where);\n    return parsedWhere.concat(defaultWhere(makeVar, store, etype, level));\n}\n// Find\n// -----------------\nfunction makeFind(makeVar, etype, level) {\n    return [makeVar(etype, level), makeVar('time', level)];\n}\n// extendObjects\n// -----------------\nfunction makeJoin(makeVar, store, etype, level, label, eid) {\n    const [nextEtype, nextLevel, pat, attr, isForward] = refAttrPat(makeVar, store, etype, level, label);\n    const actualized = replaceInAttrPat(pat, makeVar(etype, level), eid);\n    return [nextEtype, nextLevel, actualized, attr, isForward];\n}\nfunction extendObjects(makeVar, store, { etype, level, form }, objects) {\n    const childQueries = Object.keys(form).filter((c) => c !== '$');\n    if (!childQueries.length) {\n        return Object.values(objects);\n    }\n    return Object.entries(objects).map(function extendChildren([eid, parent]) {\n        const childResults = childQueries.map(function getChildResult(label) {\n            var _a, _b, _c;\n            const isSingular = Boolean(store.cardinalityInference &&\n                ((_c = (_b = (_a = store.linkIndex) === null || _a === void 0 ? void 0 : _a[etype]) === null || _b === void 0 ? void 0 : _b[label]) === null || _c === void 0 ? void 0 : _c.isSingular));\n            try {\n                const [nextEtype, nextLevel, join] = makeJoin(makeVar, store, etype, level, label, eid);\n                const childrenArray = queryOne(store, {\n                    etype: nextEtype,\n                    level: nextLevel,\n                    form: form[label],\n                    join,\n                });\n                const childOrChildren = isSingular ? childrenArray[0] : childrenArray;\n                return { [label]: childOrChildren };\n            }\n            catch (e) {\n                if (e instanceof AttrNotFoundError) {\n                    return { [label]: isSingular ? undefined : [] };\n                }\n                throw e;\n            }\n        });\n        return childResults.reduce(function reduceChildren(parent, child) {\n            return Object.assign(Object.assign({}, parent), child);\n        }, parent);\n    });\n}\n// resolveObjects\n// -----------------\nfunction shouldIgnoreAttr(attrs, id) {\n    const attr = attrs[id];\n    return attr['value-type'] === 'ref' && attr['forward-identity'][2] !== 'id';\n}\nfunction compareOrder([id_a, v_a], [id_b, v_b]) {\n    if (v_a === v_b || (v_a == null && v_b == null)) {\n        return (0, uuid_1.uuidCompare)(id_a, id_b);\n    }\n    if (v_b == null) {\n        return 1;\n    }\n    if (v_a == null) {\n        return -1;\n    }\n    if (v_a > v_b) {\n        return 1;\n    }\n    return -1;\n}\nfunction comparableDate(x) {\n    if (x == null) {\n        return x;\n    }\n    return new Date(x).getTime();\n}\nfunction isBefore(startCursor, orderAttr, direction, idVec) {\n    var _a;\n    const [c_e, _c_a, c_v, c_t] = startCursor;\n    const compareVal = direction === 'desc' ? 1 : -1;\n    if (((_a = orderAttr['forward-identity']) === null || _a === void 0 ? void 0 : _a[2]) === 'id') {\n        return compareOrder(idVec, [c_e, c_t]) === compareVal;\n    }\n    const [e, v] = idVec;\n    const v_new = orderAttr['checked-data-type'] === 'date' ? comparableDate(v) : v;\n    const c_v_new = orderAttr['checked-data-type'] === 'date' ? comparableDate(c_v) : c_v;\n    return compareOrder([e, v_new], [c_e, c_v_new]) === compareVal;\n}\nfunction orderAttrFromCursor(store, cursor) {\n    const cursorAttrId = cursor[1];\n    return store.attrs[cursorAttrId];\n}\nfunction orderAttrFromOrder(store, etype, order) {\n    const label = Object.keys(order)[0];\n    return s.getAttrByFwdIdentName(store, etype, label);\n}\nfunction getOrderAttr(store, etype, cursor, order) {\n    if (cursor) {\n        return orderAttrFromCursor(store, cursor);\n    }\n    if (order) {\n        return orderAttrFromOrder(store, etype, order);\n    }\n}\nfunction runDataloadAndReturnObjects(store, etype, direction, pageInfo, order, dq) {\n    var _a;\n    let idVecs = (0, datalog_1.query)(store, dq);\n    const startCursor = pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo['start-cursor'];\n    const orderAttr = getOrderAttr(store, etype, startCursor, order);\n    if (orderAttr && ((_a = orderAttr === null || orderAttr === void 0 ? void 0 : orderAttr['forward-identity']) === null || _a === void 0 ? void 0 : _a[2]) !== 'id') {\n        const isDate = orderAttr['checked-data-type'] === 'date';\n        const a = orderAttr.id;\n        idVecs = idVecs.map(([id]) => {\n            var _a, _b, _c, _d, _e;\n            // order attr is required to be cardinality one, so there will\n            // be at most one value here\n            let v = (_e = (_d = (_c = (_b = (_a = store.eav.get(id)) === null || _a === void 0 ? void 0 : _a.get(a)) === null || _b === void 0 ? void 0 : _b.values()) === null || _c === void 0 ? void 0 : _c.next()) === null || _d === void 0 ? void 0 : _d.value) === null || _e === void 0 ? void 0 : _e[2];\n            if (isDate) {\n                v = comparableDate(v);\n            }\n            return [id, v];\n        });\n    }\n    idVecs.sort(direction === 'asc'\n        ? function compareIdVecs(a, b) {\n            return compareOrder(a, b);\n        }\n        : function compareIdVecs(a, b) {\n            return compareOrder(b, a);\n        });\n    let objects = {};\n    for (const idVec of idVecs) {\n        const [id] = idVec;\n        if (objects[id]) {\n            continue;\n        }\n        if (startCursor &&\n            orderAttr &&\n            isBefore(startCursor, orderAttr, direction, idVec)) {\n            continue;\n        }\n        const obj = s.getAsObject(store, etype, id);\n        if (obj) {\n            objects[id] = obj;\n        }\n    }\n    return objects;\n}\nfunction determineOrder(form) {\n    var _a;\n    const orderOpts = (_a = form.$) === null || _a === void 0 ? void 0 : _a.order;\n    if (!orderOpts) {\n        return 'asc';\n    }\n    return orderOpts[Object.keys(orderOpts)[0]] || 'asc';\n}\n/**\n * Given a query like:\n *\n * {\n *   users: {\n *     $: { where: { name: \"Joe\" } },\n *   },\n * };\n *\n * `resolveObjects`, turns where clause: `{ name: \"Joe\" }`\n * into a datalog query. We then run the datalog query,\n * and reduce all the triples into objects.\n */\nfunction resolveObjects(store, { etype, level, form, join, pageInfo }) {\n    var _a, _b, _c, _d, _e, _g, _h, _j;\n    const limit = ((_a = form.$) === null || _a === void 0 ? void 0 : _a.limit) || ((_b = form.$) === null || _b === void 0 ? void 0 : _b.first) || ((_c = form.$) === null || _c === void 0 ? void 0 : _c.last);\n    const offset = (_d = form.$) === null || _d === void 0 ? void 0 : _d.offset;\n    const before = (_e = form.$) === null || _e === void 0 ? void 0 : _e.before;\n    const after = (_g = form.$) === null || _g === void 0 ? void 0 : _g.after;\n    const order = (_h = form.$) === null || _h === void 0 ? void 0 : _h.order;\n    // Wait for server to tell us where we start if we don't start from the beginning\n    if ((offset || before || after) && (!pageInfo || !pageInfo['start-cursor'])) {\n        return [];\n    }\n    const where = withJoin(makeWhere(store, etype, level, (_j = form.$) === null || _j === void 0 ? void 0 : _j.where), join);\n    const find = makeFind(makeVarImpl, etype, level);\n    const objs = runDataloadAndReturnObjects(store, etype, determineOrder(form), pageInfo, order, { where, find });\n    if (limit != null) {\n        const entries = Object.entries(objs);\n        if (entries.length <= limit) {\n            return objs;\n        }\n        return Object.fromEntries(entries.slice(0, limit));\n    }\n    return objs;\n}\n/**\n * It's possible that we query\n * for an attribute that doesn't exist yet.\n *\n * { users: { $: { where: { nonExistentProperty: \"foo\" } } } }\n *\n * This swallows the missing attr error and returns\n * an empty result instead\n */\nfunction guardedResolveObjects(store, opts) {\n    try {\n        return resolveObjects(store, opts);\n    }\n    catch (e) {\n        if (e instanceof AttrNotFoundError) {\n            return {};\n        }\n        throw e;\n    }\n}\n/**\n * Given a query like:\n *\n * {\n *   users: {\n *     $: { where: { name: \"Joe\" } },\n *     posts: {},\n *   },\n * };\n *\n * `guardResolveObjects` will return the relevant `users` objects\n * `extendObjects` will then extend each `user` object with relevant `posts`.\n */\nfunction queryOne(store, opts) {\n    const objects = guardedResolveObjects(store, opts);\n    return extendObjects(makeVarImpl, store, opts, objects);\n}\nfunction formatPageInfo(pageInfo) {\n    const res = {};\n    for (const [k, v] of Object.entries(pageInfo)) {\n        res[k] = {\n            startCursor: v['start-cursor'],\n            endCursor: v['end-cursor'],\n            hasNextPage: v['has-next-page?'],\n            hasPreviousPage: v['has-previous-page?'],\n        };\n    }\n    return res;\n}\nfunction query({ store, pageInfo, aggregate }, q) {\n    const data = Object.keys(q).reduce(function reduceResult(res, k) {\n        if (aggregate === null || aggregate === void 0 ? void 0 : aggregate[k]) {\n            // Aggregate doesn't return any join rows and has no children,\n            // so don't bother querying further\n            return res;\n        }\n        res[k] = queryOne(store, {\n            etype: k,\n            form: q[k],\n            level: 0,\n            pageInfo: pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo[k],\n        });\n        return res;\n    }, {});\n    const result = { data };\n    if (pageInfo) {\n        result.pageInfo = formatPageInfo(pageInfo);\n    }\n    if (aggregate) {\n        result.aggregate = aggregate;\n    }\n    return result;\n}\n//# sourceMappingURL=instaql.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$instantdb$core$dist$store","~$shadow.js","~$module$node_modules$$instantdb$core$dist$datalog","~$module$node_modules$$instantdb$core$dist$utils$uuid"]],"~:properties",["^5",["$isNull","etype","endCursor","isNull","find","$comparator","reverse","form","__esModule","pageInfo","startCursor","where","$op","name","level","value","aggregate","enumerable","or","attrId","joinSym","join","hasPreviousPage","patterns","hasNextPage","data","get","default"]],"~:compiled-at",1756239699964,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$instantdb$core$dist$instaql.js\",\n\"lineCount\":338,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@instantdb/core/dist/instaql.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$instantdb$core$dist$instaql\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\\n    if (k2 === undefined) k2 = k;\\n    var desc = Object.getOwnPropertyDescriptor(m, k);\\n    if (!desc || (\\\"get\\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\\n      desc = { enumerable: true, get: function() { return m[k]; } };\\n    }\\n    Object.defineProperty(o, k2, desc);\\n}) : (function(o, m, k, k2) {\\n    if (k2 === undefined) k2 = k;\\n    o[k2] = m[k];\\n}));\\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\\n    Object.defineProperty(o, \\\"default\\\", { enumerable: true, value: v });\\n}) : function(o, v) {\\n    o[\\\"default\\\"] = v;\\n});\\nvar __importStar = (this && this.__importStar) || function (mod) {\\n    if (mod && mod.__esModule) return mod;\\n    var result = {};\\n    if (mod != null) for (var k in mod) if (k !== \\\"default\\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\\n    __setModuleDefault(result, mod);\\n    return result;\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.default = query;\\nconst datalog_1 = require(\\\"./datalog\\\");\\nconst uuid_1 = require(\\\"./utils/uuid\\\");\\nconst s = __importStar(require(\\\"./store\\\"));\\n// Pattern variables\\n// -----------------\\nlet _seed = 0;\\nfunction wildcard(friendlyName) {\\n    return makeVarImpl(`_${friendlyName}`, _seed++);\\n}\\nfunction makeVarImpl(x, level) {\\n    return `?${x}-${level}`;\\n}\\n// Where\\n// -----------------\\nclass AttrNotFoundError extends Error {\\n    constructor(message) {\\n        super(message);\\n        this.name = 'AttrNotFoundError';\\n    }\\n}\\nfunction idAttr(store, ns) {\\n    const attr = s.getPrimaryKeyAttr(store, ns);\\n    if (!attr) {\\n        throw new AttrNotFoundError(`Could not find id attr for ${ns}`);\\n    }\\n    return attr;\\n}\\nfunction defaultWhere(makeVar, store, etype, level) {\\n    return [eidWhere(makeVar, store, etype, level)];\\n}\\nfunction eidWhere(makeVar, store, etype, level) {\\n    return [\\n        makeVar(etype, level),\\n        idAttr(store, etype).id,\\n        makeVar(etype, level),\\n        makeVar('time', level),\\n    ];\\n}\\nfunction replaceInAttrPat(attrPat, needle, v) {\\n    return attrPat.map((x) => (x === needle ? v : x));\\n}\\nfunction refAttrPat(makeVar, store, etype, level, label) {\\n    const fwdAttr = s.getAttrByFwdIdentName(store, etype, label);\\n    const revAttr = s.getAttrByReverseIdentName(store, etype, label);\\n    const attr = fwdAttr || revAttr;\\n    if (!attr) {\\n        throw new AttrNotFoundError(`Could not find attr for ${[etype, label]}`);\\n    }\\n    if (attr['value-type'] !== 'ref') {\\n        throw new Error(`Attr ${attr.id} is not a ref`);\\n    }\\n    const [_f, fwdEtype] = attr['forward-identity'];\\n    const [_r, revEtype] = attr['reverse-identity'];\\n    const nextLevel = level + 1;\\n    const attrPat = fwdAttr\\n        ? [\\n            makeVar(fwdEtype, level),\\n            attr.id,\\n            makeVar(revEtype, nextLevel),\\n            wildcard('time'),\\n        ]\\n        : [\\n            makeVar(fwdEtype, nextLevel),\\n            attr.id,\\n            makeVar(revEtype, level),\\n            wildcard('time'),\\n        ];\\n    const nextEtype = fwdAttr ? revEtype : fwdEtype;\\n    const isForward = Boolean(fwdAttr);\\n    return [nextEtype, nextLevel, attrPat, attr, isForward];\\n}\\nfunction makeLikeMatcher(caseSensitive, pattern) {\\n    if (typeof pattern !== 'string') {\\n        return function likeMatcher(_value) {\\n            return false;\\n        };\\n    }\\n    const escapedPattern = pattern.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, '\\\\\\\\$&');\\n    const regexPattern = escapedPattern.replace(/%/g, '.*').replace(/_/g, '.');\\n    const regex = new RegExp(`^${regexPattern}$`, caseSensitive ? undefined : 'i');\\n    return function likeMatcher(value) {\\n        if (typeof value !== 'string') {\\n            return false;\\n        }\\n        return regex.test(value);\\n    };\\n}\\nfunction parseValue(attr, v) {\\n    if (typeof v !== 'object' ||\\n        v.hasOwnProperty('$in') ||\\n        v.hasOwnProperty('in')) {\\n        return v;\\n    }\\n    const isDate = attr['checked-data-type'] === 'date';\\n    if (v.hasOwnProperty('$gt')) {\\n        return {\\n            $comparator: true,\\n            $op: isDate\\n                ? function gtDate(triple) {\\n                    return new Date(triple[2]) > new Date(v.$gt);\\n                }\\n                : function gt(triple) {\\n                    return triple[2] > v.$gt;\\n                },\\n        };\\n    }\\n    if (v.hasOwnProperty('$gte')) {\\n        return {\\n            $comparator: true,\\n            $op: isDate\\n                ? function gteDate(triple) {\\n                    return new Date(triple[2]) >= new Date(v.$gte);\\n                }\\n                : function gte(triple) {\\n                    return triple[2] >= v.$gte;\\n                },\\n        };\\n    }\\n    if (v.hasOwnProperty('$lt')) {\\n        return {\\n            $comparator: true,\\n            $op: isDate\\n                ? function ltDate(triple) {\\n                    return new Date(triple[2]) < new Date(v.$lt);\\n                }\\n                : function lt(triple) {\\n                    return triple[2] < v.$lt;\\n                },\\n        };\\n    }\\n    if (v.hasOwnProperty('$lte')) {\\n        return {\\n            $comparator: true,\\n            $op: isDate\\n                ? function lteDate(triple) {\\n                    return new Date(triple[2]) <= new Date(v.$lte);\\n                }\\n                : function lte(triple) {\\n                    return triple[2] <= v.$lte;\\n                },\\n        };\\n    }\\n    if (v.hasOwnProperty('$like')) {\\n        const matcher = makeLikeMatcher(true, v.$like);\\n        return {\\n            $comparator: true,\\n            $op: function like(triple) {\\n                return matcher(triple[2]);\\n            },\\n        };\\n    }\\n    if (v.hasOwnProperty('$ilike')) {\\n        const matcher = makeLikeMatcher(false, v.$ilike);\\n        return {\\n            $comparator: true,\\n            $op: function ilike(triple) {\\n                return matcher(triple[2]);\\n            },\\n        };\\n    }\\n    return v;\\n}\\nfunction valueAttrPat(makeVar, store, valueEtype, valueLevel, valueLabel, v) {\\n    const fwdAttr = s.getAttrByFwdIdentName(store, valueEtype, valueLabel);\\n    const revAttr = s.getAttrByReverseIdentName(store, valueEtype, valueLabel);\\n    const attr = fwdAttr || revAttr;\\n    if (!attr) {\\n        throw new AttrNotFoundError(`No attr for etype = ${valueEtype} label = ${valueLabel}`);\\n    }\\n    if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$isNull')) {\\n        const idAttr = s.getAttrByFwdIdentName(store, valueEtype, 'id');\\n        if (!idAttr) {\\n            throw new AttrNotFoundError(`No attr for etype = ${valueEtype} label = id`);\\n        }\\n        return [\\n            makeVar(valueEtype, valueLevel),\\n            idAttr.id,\\n            { $isNull: { attrId: attr.id, isNull: v.$isNull, reverse: !fwdAttr } },\\n            wildcard('time'),\\n        ];\\n    }\\n    if (fwdAttr) {\\n        return [\\n            makeVar(valueEtype, valueLevel),\\n            attr.id,\\n            parseValue(attr, v),\\n            wildcard('time'),\\n        ];\\n    }\\n    return [v, attr.id, makeVar(valueEtype, valueLevel), wildcard('time')];\\n}\\nfunction refAttrPats(makeVar, store, etype, level, refsPath) {\\n    const [lastEtype, lastLevel, attrPats] = refsPath.reduce((acc, label) => {\\n        const [etype, level, attrPats] = acc;\\n        const [nextEtype, nextLevel, attrPat] = refAttrPat(makeVar, store, etype, level, label);\\n        return [nextEtype, nextLevel, [...attrPats, attrPat]];\\n    }, [etype, level, []]);\\n    return [lastEtype, lastLevel, attrPats];\\n}\\nfunction whereCondAttrPats(makeVar, store, etype, level, path, v) {\\n    const refsPath = path.slice(0, path.length - 1);\\n    const valueLabel = path[path.length - 1];\\n    const [lastEtype, lastLevel, refPats] = refAttrPats(makeVar, store, etype, level, refsPath);\\n    const valuePat = valueAttrPat(makeVar, store, lastEtype, lastLevel, valueLabel, v);\\n    return refPats.concat([valuePat]);\\n}\\nfunction withJoin(where, join) {\\n    return join ? [join].concat(where) : where;\\n}\\nfunction isOrClauses([k, v]) {\\n    return k === 'or' && Array.isArray(v);\\n}\\nfunction isAndClauses([k, v]) {\\n    return k === 'and' && Array.isArray(v);\\n}\\n// Creates a makeVar that will namespace symbols for or clauses\\n// to prevent conflicts, except for the base etype\\nfunction genMakeVar(baseMakeVar, joinSym, orIdx) {\\n    return (x, lvl) => {\\n        const base = baseMakeVar(x, lvl);\\n        if (joinSym == base) {\\n            return base;\\n        }\\n        return `${base}-${orIdx}`;\\n    };\\n}\\nfunction parseWhereClauses(makeVar, clauseType /* 'or' | 'and' */, store, etype, level, whereValue) {\\n    const joinSym = makeVar(etype, level);\\n    const patterns = whereValue.map((w, i) => {\\n        const makeNamespacedVar = genMakeVar(makeVar, joinSym, i);\\n        return parseWhere(makeNamespacedVar, store, etype, level, w);\\n    });\\n    return { [clauseType]: { patterns, joinSym } };\\n}\\n// Given a path, returns a list of paths leading up to this path:\\n// growPath([1, 2, 3]) -> [[1], [1, 2], [1, 2, 3]]\\nfunction growPath(path) {\\n    const ret = [];\\n    for (let i = 1; i <= path.length; i++) {\\n        ret.push(path.slice(0, i));\\n    }\\n    return ret;\\n}\\n// Returns array of pattern arrays that should be grouped in OR\\n// to capture any intermediate nulls\\nfunction whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path) {\\n    return growPath(path).map((path) => whereCondAttrPats(makeVar, store, etype, level, path, { $isNull: true }));\\n}\\nfunction parseWhere(makeVar, store, etype, level, where) {\\n    return Object.entries(where).flatMap(([k, v]) => {\\n        if (isOrClauses([k, v])) {\\n            return parseWhereClauses(makeVar, 'or', store, etype, level, v);\\n        }\\n        if (isAndClauses([k, v])) {\\n            return parseWhereClauses(makeVar, 'and', store, etype, level, v);\\n        }\\n        // Temporary hack until we have support for a uuid index on `id`\\n        if (k === '$entityIdStartsWith') {\\n            return [];\\n        }\\n        const path = k.split('.');\\n        if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$not')) {\\n            // `$not` won't pick up entities that are missing the attr, so we\\n            // add in a `$isNull` to catch those too.\\n            const notPats = whereCondAttrPats(makeVar, store, etype, level, path, v);\\n            const nilPats = whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path);\\n            return [\\n                {\\n                    or: {\\n                        patterns: [notPats, ...nilPats],\\n                        joinSym: makeVar(etype, level),\\n                    },\\n                },\\n            ];\\n        }\\n        if ((v === null || v === void 0 ? void 0 : v.hasOwnProperty('$isNull')) && v.$isNull === true && path.length > 1) {\\n            // Make sure we're capturing all of the intermediate paths that might be null\\n            // by checking for null at each step along the path\\n            return [\\n                {\\n                    or: {\\n                        patterns: whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path),\\n                        joinSym: makeVar(etype, level),\\n                    },\\n                },\\n            ];\\n        }\\n        return whereCondAttrPats(makeVar, store, etype, level, path, v);\\n    });\\n}\\nfunction makeWhere(store, etype, level, where) {\\n    const makeVar = makeVarImpl;\\n    if (!where) {\\n        return defaultWhere(makeVar, store, etype, level);\\n    }\\n    const parsedWhere = parseWhere(makeVar, store, etype, level, where);\\n    return parsedWhere.concat(defaultWhere(makeVar, store, etype, level));\\n}\\n// Find\\n// -----------------\\nfunction makeFind(makeVar, etype, level) {\\n    return [makeVar(etype, level), makeVar('time', level)];\\n}\\n// extendObjects\\n// -----------------\\nfunction makeJoin(makeVar, store, etype, level, label, eid) {\\n    const [nextEtype, nextLevel, pat, attr, isForward] = refAttrPat(makeVar, store, etype, level, label);\\n    const actualized = replaceInAttrPat(pat, makeVar(etype, level), eid);\\n    return [nextEtype, nextLevel, actualized, attr, isForward];\\n}\\nfunction extendObjects(makeVar, store, { etype, level, form }, objects) {\\n    const childQueries = Object.keys(form).filter((c) => c !== '$');\\n    if (!childQueries.length) {\\n        return Object.values(objects);\\n    }\\n    return Object.entries(objects).map(function extendChildren([eid, parent]) {\\n        const childResults = childQueries.map(function getChildResult(label) {\\n            var _a, _b, _c;\\n            const isSingular = Boolean(store.cardinalityInference &&\\n                ((_c = (_b = (_a = store.linkIndex) === null || _a === void 0 ? void 0 : _a[etype]) === null || _b === void 0 ? void 0 : _b[label]) === null || _c === void 0 ? void 0 : _c.isSingular));\\n            try {\\n                const [nextEtype, nextLevel, join] = makeJoin(makeVar, store, etype, level, label, eid);\\n                const childrenArray = queryOne(store, {\\n                    etype: nextEtype,\\n                    level: nextLevel,\\n                    form: form[label],\\n                    join,\\n                });\\n                const childOrChildren = isSingular ? childrenArray[0] : childrenArray;\\n                return { [label]: childOrChildren };\\n            }\\n            catch (e) {\\n                if (e instanceof AttrNotFoundError) {\\n                    return { [label]: isSingular ? undefined : [] };\\n                }\\n                throw e;\\n            }\\n        });\\n        return childResults.reduce(function reduceChildren(parent, child) {\\n            return Object.assign(Object.assign({}, parent), child);\\n        }, parent);\\n    });\\n}\\n// resolveObjects\\n// -----------------\\nfunction shouldIgnoreAttr(attrs, id) {\\n    const attr = attrs[id];\\n    return attr['value-type'] === 'ref' && attr['forward-identity'][2] !== 'id';\\n}\\nfunction compareOrder([id_a, v_a], [id_b, v_b]) {\\n    if (v_a === v_b || (v_a == null && v_b == null)) {\\n        return (0, uuid_1.uuidCompare)(id_a, id_b);\\n    }\\n    if (v_b == null) {\\n        return 1;\\n    }\\n    if (v_a == null) {\\n        return -1;\\n    }\\n    if (v_a > v_b) {\\n        return 1;\\n    }\\n    return -1;\\n}\\nfunction comparableDate(x) {\\n    if (x == null) {\\n        return x;\\n    }\\n    return new Date(x).getTime();\\n}\\nfunction isBefore(startCursor, orderAttr, direction, idVec) {\\n    var _a;\\n    const [c_e, _c_a, c_v, c_t] = startCursor;\\n    const compareVal = direction === 'desc' ? 1 : -1;\\n    if (((_a = orderAttr['forward-identity']) === null || _a === void 0 ? void 0 : _a[2]) === 'id') {\\n        return compareOrder(idVec, [c_e, c_t]) === compareVal;\\n    }\\n    const [e, v] = idVec;\\n    const v_new = orderAttr['checked-data-type'] === 'date' ? comparableDate(v) : v;\\n    const c_v_new = orderAttr['checked-data-type'] === 'date' ? comparableDate(c_v) : c_v;\\n    return compareOrder([e, v_new], [c_e, c_v_new]) === compareVal;\\n}\\nfunction orderAttrFromCursor(store, cursor) {\\n    const cursorAttrId = cursor[1];\\n    return store.attrs[cursorAttrId];\\n}\\nfunction orderAttrFromOrder(store, etype, order) {\\n    const label = Object.keys(order)[0];\\n    return s.getAttrByFwdIdentName(store, etype, label);\\n}\\nfunction getOrderAttr(store, etype, cursor, order) {\\n    if (cursor) {\\n        return orderAttrFromCursor(store, cursor);\\n    }\\n    if (order) {\\n        return orderAttrFromOrder(store, etype, order);\\n    }\\n}\\nfunction runDataloadAndReturnObjects(store, etype, direction, pageInfo, order, dq) {\\n    var _a;\\n    let idVecs = (0, datalog_1.query)(store, dq);\\n    const startCursor = pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo['start-cursor'];\\n    const orderAttr = getOrderAttr(store, etype, startCursor, order);\\n    if (orderAttr && ((_a = orderAttr === null || orderAttr === void 0 ? void 0 : orderAttr['forward-identity']) === null || _a === void 0 ? void 0 : _a[2]) !== 'id') {\\n        const isDate = orderAttr['checked-data-type'] === 'date';\\n        const a = orderAttr.id;\\n        idVecs = idVecs.map(([id]) => {\\n            var _a, _b, _c, _d, _e;\\n            // order attr is required to be cardinality one, so there will\\n            // be at most one value here\\n            let v = (_e = (_d = (_c = (_b = (_a = store.eav.get(id)) === null || _a === void 0 ? void 0 : _a.get(a)) === null || _b === void 0 ? void 0 : _b.values()) === null || _c === void 0 ? void 0 : _c.next()) === null || _d === void 0 ? void 0 : _d.value) === null || _e === void 0 ? void 0 : _e[2];\\n            if (isDate) {\\n                v = comparableDate(v);\\n            }\\n            return [id, v];\\n        });\\n    }\\n    idVecs.sort(direction === 'asc'\\n        ? function compareIdVecs(a, b) {\\n            return compareOrder(a, b);\\n        }\\n        : function compareIdVecs(a, b) {\\n            return compareOrder(b, a);\\n        });\\n    let objects = {};\\n    for (const idVec of idVecs) {\\n        const [id] = idVec;\\n        if (objects[id]) {\\n            continue;\\n        }\\n        if (startCursor &&\\n            orderAttr &&\\n            isBefore(startCursor, orderAttr, direction, idVec)) {\\n            continue;\\n        }\\n        const obj = s.getAsObject(store, etype, id);\\n        if (obj) {\\n            objects[id] = obj;\\n        }\\n    }\\n    return objects;\\n}\\nfunction determineOrder(form) {\\n    var _a;\\n    const orderOpts = (_a = form.$) === null || _a === void 0 ? void 0 : _a.order;\\n    if (!orderOpts) {\\n        return 'asc';\\n    }\\n    return orderOpts[Object.keys(orderOpts)[0]] || 'asc';\\n}\\n/**\\n * Given a query like:\\n *\\n * {\\n *   users: {\\n *     $: { where: { name: \\\"Joe\\\" } },\\n *   },\\n * };\\n *\\n * `resolveObjects`, turns where clause: `{ name: \\\"Joe\\\" }`\\n * into a datalog query. We then run the datalog query,\\n * and reduce all the triples into objects.\\n */\\nfunction resolveObjects(store, { etype, level, form, join, pageInfo }) {\\n    var _a, _b, _c, _d, _e, _g, _h, _j;\\n    const limit = ((_a = form.$) === null || _a === void 0 ? void 0 : _a.limit) || ((_b = form.$) === null || _b === void 0 ? void 0 : _b.first) || ((_c = form.$) === null || _c === void 0 ? void 0 : _c.last);\\n    const offset = (_d = form.$) === null || _d === void 0 ? void 0 : _d.offset;\\n    const before = (_e = form.$) === null || _e === void 0 ? void 0 : _e.before;\\n    const after = (_g = form.$) === null || _g === void 0 ? void 0 : _g.after;\\n    const order = (_h = form.$) === null || _h === void 0 ? void 0 : _h.order;\\n    // Wait for server to tell us where we start if we don't start from the beginning\\n    if ((offset || before || after) && (!pageInfo || !pageInfo['start-cursor'])) {\\n        return [];\\n    }\\n    const where = withJoin(makeWhere(store, etype, level, (_j = form.$) === null || _j === void 0 ? void 0 : _j.where), join);\\n    const find = makeFind(makeVarImpl, etype, level);\\n    const objs = runDataloadAndReturnObjects(store, etype, determineOrder(form), pageInfo, order, { where, find });\\n    if (limit != null) {\\n        const entries = Object.entries(objs);\\n        if (entries.length <= limit) {\\n            return objs;\\n        }\\n        return Object.fromEntries(entries.slice(0, limit));\\n    }\\n    return objs;\\n}\\n/**\\n * It's possible that we query\\n * for an attribute that doesn't exist yet.\\n *\\n * { users: { $: { where: { nonExistentProperty: \\\"foo\\\" } } } }\\n *\\n * This swallows the missing attr error and returns\\n * an empty result instead\\n */\\nfunction guardedResolveObjects(store, opts) {\\n    try {\\n        return resolveObjects(store, opts);\\n    }\\n    catch (e) {\\n        if (e instanceof AttrNotFoundError) {\\n            return {};\\n        }\\n        throw e;\\n    }\\n}\\n/**\\n * Given a query like:\\n *\\n * {\\n *   users: {\\n *     $: { where: { name: \\\"Joe\\\" } },\\n *     posts: {},\\n *   },\\n * };\\n *\\n * `guardResolveObjects` will return the relevant `users` objects\\n * `extendObjects` will then extend each `user` object with relevant `posts`.\\n */\\nfunction queryOne(store, opts) {\\n    const objects = guardedResolveObjects(store, opts);\\n    return extendObjects(makeVarImpl, store, opts, objects);\\n}\\nfunction formatPageInfo(pageInfo) {\\n    const res = {};\\n    for (const [k, v] of Object.entries(pageInfo)) {\\n        res[k] = {\\n            startCursor: v['start-cursor'],\\n            endCursor: v['end-cursor'],\\n            hasNextPage: v['has-next-page?'],\\n            hasPreviousPage: v['has-previous-page?'],\\n        };\\n    }\\n    return res;\\n}\\nfunction query({ store, pageInfo, aggregate }, q) {\\n    const data = Object.keys(q).reduce(function reduceResult(res, k) {\\n        if (aggregate === null || aggregate === void 0 ? void 0 : aggregate[k]) {\\n            // Aggregate doesn't return any join rows and has no children,\\n            // so don't bother querying further\\n            return res;\\n        }\\n        res[k] = queryOne(store, {\\n            etype: k,\\n            form: q[k],\\n            level: 0,\\n            pageInfo: pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo[k],\\n        });\\n        return res;\\n    }, {});\\n    const result = { data };\\n    if (pageInfo) {\\n        result.pageInfo = formatPageInfo(pageInfo);\\n    }\\n    if (aggregate) {\\n        result.aggregate = aggregate;\\n    }\\n    return result;\\n}\\n//# sourceMappingURL=instaql.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"wildcard\",\"friendlyName\",\"makeVarImpl\",\"_seed\",\"x\",\"level\",\"eidWhere\",\"makeVar\",\"store\",\"etype\",\"attr\",\"s\",\"getPrimaryKeyAttr\",\"AttrNotFoundError\",\"id\",\"replaceInAttrPat\",\"attrPat\",\"needle\",\"v\",\"map\",\"refAttrPat\",\"label\",\"fwdAttr\",\"getAttrByFwdIdentName\",\"revAttr\",\"getAttrByReverseIdentName\",\"Error\",\"fwdEtype\",\"revEtype\",\"nextLevel\",\"nextEtype\",\"isForward\",\"makeLikeMatcher\",\"caseSensitive\",\"pattern\",\"likeMatcher\",\"_value\",\"regexPattern\",\"replace\",\"escapedPattern\",\"regex\",\"RegExp\",\"undefined\",\"value\",\"test\",\"parseValue\",\"hasOwnProperty\",\"isDate\",\"$comparator\",\"$op\",\"gtDate\",\"triple\",\"Date\",\"$gt\",\"gt\",\"gteDate\",\"$gte\",\"gte\",\"ltDate\",\"$lt\",\"lt\",\"lteDate\",\"$lte\",\"lte\",\"matcher\",\"$like\",\"like\",\"$ilike\",\"ilike\",\"refAttrPats\",\"refsPath\",\"lastEtype\",\"lastLevel\",\"attrPats\",\"reduce\",\"acc\",\"whereCondAttrPats\",\"path\",\"slice\",\"length\",\"valueLabel\",\"refPats\",\"idAttr\",\"$isNull\",\"attrId\",\"isNull\",\"reverse\",\"concat\",\"valuePat\",\"isOrClauses\",\"k\",\"Array\",\"isArray\",\"isAndClauses\",\"genMakeVar\",\"baseMakeVar\",\"joinSym\",\"orIdx\",\"lvl\",\"base\",\"parseWhereClauses\",\"clauseType\",\"whereValue\",\"patterns\",\"w\",\"i\",\"makeNamespacedVar\",\"parseWhere\",\"growPath\",\"ret\",\"push\",\"whereCondAttrPatsForNullIsTrue\",\"where\",\"Object\",\"entries\",\"flatMap\",\"split\",\"notPats\",\"nilPats\",\"or\",\"extendObjects\",\"form\",\"objects\",\"childQueries\",\"keys\",\"filter\",\"c\",\"extendChildren\",\"eid\",\"parent\",\"childResults\",\"getChildResult\",\"_a\",\"_b\",\"_c\",\"isSingular\",\"cardinalityInference\",\"linkIndex\",\"pat\",\"actualized\",\"join\",\"childrenArray\",\"queryOne\",\"childOrChildren\",\"e\",\"reduceChildren\",\"child\",\"assign\",\"values\",\"compareOrder\",\"id_a\",\"v_a\",\"id_b\",\"v_b\",\"uuid_1\",\"uuidCompare\",\"comparableDate\",\"getTime\",\"isBefore\",\"startCursor\",\"orderAttr\",\"direction\",\"idVec\",\"c_e\",\"c_v\",\"c_t\",\"compareVal\",\"v_new\",\"c_v_new\",\"getOrderAttr\",\"cursor\",\"order\",\"attrs\",\"cursorAttrId\",\"runDataloadAndReturnObjects\",\"pageInfo\",\"dq\",\"idVecs\",\"datalog_1\",\"query\",\"a\",\"_d\",\"_e\",\"eav\",\"get\",\"next\",\"sort\",\"compareIdVecs\",\"b\",\"obj\",\"getAsObject\",\"resolveObjects\",\"_g\",\"_h\",\"_j\",\"limit\",\"$\",\"first\",\"last\",\"offset\",\"before\",\"after\",\"parsedWhere\",\"orderOpts\",\"objs\",\"find\",\"fromEntries\",\"opts\",\"formatPageInfo\",\"res\",\"endCursor\",\"hasNextPage\",\"hasPreviousPage\",\"__createBinding\",\"create\",\"o\",\"m\",\"k2\",\"desc\",\"getOwnPropertyDescriptor\",\"__esModule\",\"writable\",\"configurable\",\"enumerable\",\"defineProperty\",\"__setModuleDefault\",\"__importStar\",\"mod\",\"result\",\"prototype\",\"call\",\"default\",\"aggregate\",\"q\",\"data\",\"reduceResult\",\"constructor\",\"message\",\"name\"]\n}\n"]