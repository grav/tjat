["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@instantdb/core/dist/utils/weakHash.js"],"~:js","shadow$provide.module$node_modules$$instantdb$core$dist$utils$weakHash = function(global, require, module, exports) {\n  function weakHash(input) {\n    if (\"number\" === typeof input) {\n      return (Math.abs(2654435761 * input) >>> 0).toString(16);\n    }\n    if (\"boolean\" === typeof input) {\n      return input ? \"1\" : \"0\";\n    }\n    if (null === input) {\n      return \"null\";\n    }\n    if (void 0 === input) {\n      return \"undefined\";\n    }\n    if (\"string\" === typeof input) {\n      var hash = 2166136261;\n      for (var i = 0; i < input.length; i++) {\n        hash ^= input.charCodeAt(i), hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24), hash >>>= 0;\n      }\n      return hash.toString(16);\n    }\n    if (Array.isArray(input)) {\n      hash = 2166136261;\n      for (i = 0; i < input.length; i++) {\n        hash ^= 2654435761 * (i + 1);\n        var elementHash = weakHash(input[i]);\n        for (var j = 0; j < elementHash.length; j++) {\n          hash ^= elementHash.charCodeAt(j), hash *= 16777619, hash >>>= 0;\n        }\n      }\n      return hash.toString(16);\n    }\n    if (\"object\" === typeof input) {\n      hash = 2166136261;\n      i = Object.keys(input).sort();\n      for (elementHash = 0; elementHash < i.length; elementHash++) {\n        j = i[elementHash];\n        const keyHash = weakHash(j);\n        hash ^= parseInt(keyHash, 16);\n        hash *= 16777619;\n        hash >>>= 0;\n        j = weakHash(input[j]);\n        hash ^= parseInt(j, 16);\n        hash *= 16777619;\n        hash >>>= 0;\n      }\n      return hash.toString(16);\n    }\n    return weakHash(String(input));\n  }\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.default = weakHash;\n};\n","~:source","shadow$provide[\"module$node_modules$$instantdb$core$dist$utils$weakHash\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = weakHash;\n/**\n *\n * Unique Hashing implementation inspired by djb2/fnv1a algorithms,\n * where we are not concerned with the hash being decoded.\n * Focuses on speed while maintaining good hash distribution\n *\n * Note: We could also use something like Murmurhash instead\n * https://github.com/jensyt/imurmurhash-js/blob/master/imurmurhash.js\n *\n * @param {any} input - Value to hash\n * @returns {string} - Hash in hex format\n */\nfunction weakHash(input) {\n    // Handle primitives without JSON stringify for better performance\n    if (typeof input === 'number') {\n        // Use a larger number space for numeric values\n        return (Math.abs(input * 2654435761) >>> 0).toString(16);\n    }\n    if (typeof input === 'boolean')\n        return input ? '1' : '0';\n    if (input === null)\n        return 'null';\n    if (input === undefined)\n        return 'undefined';\n    // For strings, use FNV-1a algorithm\n    if (typeof input === 'string') {\n        let hash = 0x811c9dc5; // FNV offset basis (32 bit)\n        for (let i = 0; i < input.length; i++) {\n            hash ^= input.charCodeAt(i);\n            hash +=\n                (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n            hash = hash >>> 0; // Convert to unsigned 32-bit after each iteration\n        }\n        return hash.toString(16);\n    }\n    // For arrays, hash elements directly\n    if (Array.isArray(input)) {\n        let hash = 0x811c9dc5;\n        for (let i = 0; i < input.length; i++) {\n            // Add array position to hash calculation\n            hash ^= (i + 1) * 2654435761;\n            // Recursively hash array elements\n            const elementHash = weakHash(input[i]);\n            // Mix the element hash into the running hash\n            for (let j = 0; j < elementHash.length; j++) {\n                hash ^= elementHash.charCodeAt(j);\n                hash *= 16777619; // FNV prime (32 bit)\n                hash = hash >>> 0;\n            }\n        }\n        return hash.toString(16);\n    }\n    // For objects, hash keys and values\n    if (typeof input === 'object') {\n        let hash = 0x811c9dc5;\n        const keys = Object.keys(input).sort(); // Sort for consistency\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            // Hash the key using string hash\n            const keyHash = weakHash(key);\n            hash ^= parseInt(keyHash, 16);\n            hash *= 16777619;\n            hash = hash >>> 0;\n            // Hash the value recursively\n            const valueHash = weakHash(input[key]);\n            hash ^= parseInt(valueHash, 16);\n            hash *= 16777619;\n            hash = hash >>> 0;\n        }\n        return hash.toString(16);\n    }\n    // Fallback for other types\n    return weakHash(String(input));\n}\n//# sourceMappingURL=weakHash.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","value","default"]],"~:compiled-at",1756239699913,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$instantdb$core$dist$utils$weakHash.js\",\n\"lineCount\":54,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@instantdb/core/dist/utils/weakHash.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$instantdb$core$dist$utils$weakHash\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.default = weakHash;\\n/**\\n *\\n * Unique Hashing implementation inspired by djb2/fnv1a algorithms,\\n * where we are not concerned with the hash being decoded.\\n * Focuses on speed while maintaining good hash distribution\\n *\\n * Note: We could also use something like Murmurhash instead\\n * https://github.com/jensyt/imurmurhash-js/blob/master/imurmurhash.js\\n *\\n * @param {any} input - Value to hash\\n * @returns {string} - Hash in hex format\\n */\\nfunction weakHash(input) {\\n    // Handle primitives without JSON stringify for better performance\\n    if (typeof input === 'number') {\\n        // Use a larger number space for numeric values\\n        return (Math.abs(input * 2654435761) >>> 0).toString(16);\\n    }\\n    if (typeof input === 'boolean')\\n        return input ? '1' : '0';\\n    if (input === null)\\n        return 'null';\\n    if (input === undefined)\\n        return 'undefined';\\n    // For strings, use FNV-1a algorithm\\n    if (typeof input === 'string') {\\n        let hash = 0x811c9dc5; // FNV offset basis (32 bit)\\n        for (let i = 0; i < input.length; i++) {\\n            hash ^= input.charCodeAt(i);\\n            hash +=\\n                (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\\n            hash = hash >>> 0; // Convert to unsigned 32-bit after each iteration\\n        }\\n        return hash.toString(16);\\n    }\\n    // For arrays, hash elements directly\\n    if (Array.isArray(input)) {\\n        let hash = 0x811c9dc5;\\n        for (let i = 0; i < input.length; i++) {\\n            // Add array position to hash calculation\\n            hash ^= (i + 1) * 2654435761;\\n            // Recursively hash array elements\\n            const elementHash = weakHash(input[i]);\\n            // Mix the element hash into the running hash\\n            for (let j = 0; j < elementHash.length; j++) {\\n                hash ^= elementHash.charCodeAt(j);\\n                hash *= 16777619; // FNV prime (32 bit)\\n                hash = hash >>> 0;\\n            }\\n        }\\n        return hash.toString(16);\\n    }\\n    // For objects, hash keys and values\\n    if (typeof input === 'object') {\\n        let hash = 0x811c9dc5;\\n        const keys = Object.keys(input).sort(); // Sort for consistency\\n        for (let i = 0; i < keys.length; i++) {\\n            const key = keys[i];\\n            // Hash the key using string hash\\n            const keyHash = weakHash(key);\\n            hash ^= parseInt(keyHash, 16);\\n            hash *= 16777619;\\n            hash = hash >>> 0;\\n            // Hash the value recursively\\n            const valueHash = weakHash(input[key]);\\n            hash ^= parseInt(valueHash, 16);\\n            hash *= 16777619;\\n            hash = hash >>> 0;\\n        }\\n        return hash.toString(16);\\n    }\\n    // Fallback for other types\\n    return weakHash(String(input));\\n}\\n//# sourceMappingURL=weakHash.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"weakHash\",\"input\",\"toString\",\"Math\",\"abs\",\"undefined\",\"hash\",\"i\",\"length\",\"charCodeAt\",\"Array\",\"isArray\",\"elementHash\",\"j\",\"keys\",\"Object\",\"sort\",\"key\",\"keyHash\",\"parseInt\",\"valueHash\",\"String\",\"defineProperty\",\"value\",\"default\"]\n}\n"]