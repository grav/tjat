["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@instantdb/core/dist/instaml.js"],"~:js","shadow$provide.module$node_modules$$instantdb$core$dist$instaml = function(global, require, module, exports) {\n  function getAttrByFwdIdentName(attrs, inputEtype, inputIdentName) {\n    return Object.values(attrs).find(attr => {\n      const [, etype, label] = attr[\"forward-identity\"];\n      return etype === inputEtype && label === inputIdentName;\n    });\n  }\n  function getAttrByReverseIdentName(attrs, inputEtype, inputIdentName) {\n    return Object.values(attrs).find(attr => {\n      attr = attr[\"reverse-identity\"];\n      if (!attr) {\n        return !1;\n      }\n      const [, etype, label] = attr;\n      return etype === inputEtype && label === inputIdentName;\n    });\n  }\n  function isRefLookupIdent(attrs, etype, identName) {\n    return -1 !== identName.indexOf(\".\") && !getAttrByFwdIdentName(attrs, etype, identName);\n  }\n  function extractRefLookupFwdName(identName) {\n    const [fwdName, idIdent, ...rest] = identName.split(\".\");\n    if (0 < rest.length || \"id\" !== idIdent) {\n      throw Error(`${identName} is not a valid lookup attribute.`);\n    }\n    return fwdName;\n  }\n  function lookupPairOfEid(eid) {\n    if (\"string\" === typeof eid && !(0,instatx_1.isLookup)(eid)) {\n      return null;\n    }\n    if (\"string\" === typeof eid && (0,instatx_1.isLookup)(eid)) {\n      eid = (0,instatx_1.parseLookup)(eid);\n    } else {\n      if (!Array.isArray(eid)) {\n        eid = Object.entries(eid);\n        if (1 !== eid.length) {\n          throw Error(\"lookup must be an object with a single unique attr and value.\");\n        }\n        eid = eid[0];\n      }\n    }\n    return eid;\n  }\n  function extractLookup(attrs, etype, eid) {\n    const lookupPair = lookupPairOfEid(eid);\n    if (null === lookupPair) {\n      return eid;\n    }\n    const [identName, value] = lookupPair;\n    if (isRefLookupIdent(attrs, etype, identName)) {\n      if (eid = extractRefLookupFwdName(identName), (attrs = getAttrByFwdIdentName(attrs, etype, eid) || getAttrByReverseIdentName(attrs, etype, eid)) && \"ref\" !== attrs[\"value-type\"]) {\n        throw Error(`${identName} does not reference a valid link attribute.`);\n      }\n    } else {\n      attrs = getAttrByFwdIdentName(attrs, etype, identName);\n    }\n    if (!attrs || !attrs[\"unique?\"]) {\n      throw Error(`${identName} is not a unique attribute.`);\n    }\n    return [attrs.id, value];\n  }\n  function expandLink(attrs, [etype, eidA, obj]) {\n    return Object.entries(obj).flatMap(([label, eidOrEids]) => {\n      eidOrEids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];\n      const fwdAttr = getAttrByFwdIdentName(attrs, etype, label), revAttr = getAttrByReverseIdentName(attrs, etype, label);\n      return eidOrEids.map(eidB => fwdAttr ? [\"add-triple\", extractLookup(attrs, etype, eidA), fwdAttr.id, extractLookup(attrs, fwdAttr[\"reverse-identity\"][1], eidB)] : [\"add-triple\", extractLookup(attrs, revAttr[\"forward-identity\"][1], eidB), revAttr.id, extractLookup(attrs, etype, eidA)]);\n    });\n  }\n  function expandUnlink(attrs, [etype, eidA, obj]) {\n    return Object.entries(obj).flatMap(([label, eidOrEids]) => {\n      eidOrEids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];\n      const fwdAttr = getAttrByFwdIdentName(attrs, etype, label), revAttr = getAttrByReverseIdentName(attrs, etype, label);\n      return eidOrEids.map(eidB => fwdAttr ? [\"retract-triple\", extractLookup(attrs, etype, eidA), fwdAttr.id, extractLookup(attrs, fwdAttr[\"reverse-identity\"][1], eidB)] : [\"retract-triple\", extractLookup(attrs, revAttr[\"forward-identity\"][1], eidB), revAttr.id, extractLookup(attrs, etype, eidA)]);\n    });\n  }\n  function expandUpdate(attrs, [etype, eid, obj]) {\n    const lookup = extractLookup(attrs, etype, eid);\n    return [[\"id\", extractLookup(attrs, etype, eid)]].concat(Object.entries(obj)).map(([identName, value]) => {\n      identName = getAttrByFwdIdentName(attrs, etype, identName);\n      return [\"add-triple\", lookup, identName.id, value];\n    });\n  }\n  function expandDelete(attrs, [etype, eid]) {\n    return [[\"delete-entity\", extractLookup(attrs, etype, eid), etype]];\n  }\n  function expandDeepMerge(attrs, [etype, eid, obj]) {\n    const lookup = extractLookup(attrs, etype, eid);\n    eid = Object.entries(obj).map(([identName, value]) => {\n      identName = getAttrByFwdIdentName(attrs, etype, identName);\n      value = (0,object_1.immutableDeepReplace)(value, void 0, null);\n      return [\"deep-merge-triple\", lookup, identName.id, value];\n    });\n    return [[\"add-triple\", lookup, getAttrByFwdIdentName(attrs, etype, \"id\").id, lookup]].concat(eid);\n  }\n  function toTxSteps(attrs, step) {\n    {\n      const [op, etype, eid, obj] = step;\n      obj && (step = Object.assign({}, obj), delete step.id, step = [op, etype, eid, step]);\n    }\n    const [action, ...args] = step;\n    switch(action) {\n      case \"merge\":\n        return expandDeepMerge(attrs, args);\n      case \"update\":\n        return expandUpdate(attrs, args);\n      case \"link\":\n        return expandLink(attrs, args);\n      case \"unlink\":\n        return expandUnlink(attrs, args);\n      case \"delete\":\n        return expandDelete(attrs, args);\n      default:\n        throw Error(`unsupported action ${action}`);\n    }\n  }\n  function createObjectAttr(schema, etype, label, props) {\n    var JSCompiler_temp;\n    if (schema) {\n      var _b;\n      schema = null === (_b = null === (JSCompiler_temp = schema.entities[etype]) || void 0 === JSCompiler_temp ? void 0 : JSCompiler_temp.attrs) || void 0 === _b ? void 0 : _b[label];\n      if (\"id\" === label) {\n        JSCompiler_temp = null;\n      } else {\n        if (!schema) {\n          throw Error(`${etype}.${label} does not exist in your schema`);\n        }\n        var {unique, indexed} = null === schema || void 0 === schema ? void 0 : schema.config;\n        b: {\n          JSCompiler_temp = null === schema || void 0 === schema ? void 0 : schema.valueType;\n          switch(JSCompiler_temp) {\n            case \"string\":\n            case \"date\":\n            case \"boolean\":\n            case \"number\":\n              break b;\n          }\n          JSCompiler_temp = void 0;\n        }\n        JSCompiler_temp = {\"index?\":indexed, \"unique?\":unique, \"checked-data-type\":JSCompiler_temp};\n      }\n    } else {\n      JSCompiler_temp = null;\n    }\n    _b = (0,uuid_1.default)();\n    etype = [(0,uuid_1.default)(), etype, label];\n    return Object.assign(Object.assign({id:_b, \"forward-identity\":etype, \"value-type\":\"blob\", cardinality:\"one\", \"unique?\":!1, \"index?\":!1, isUnsynced:!0}, JSCompiler_temp || {}), props || {});\n  }\n  function findSchemaLink(schema, etype, label) {\n    return Object.values(schema.links).find(x => x.forward.on === etype && x.forward.label === label || x.reverse.on === etype && x.reverse.label === label);\n  }\n  function createRefAttr(schema, etype, label, props) {\n    if (schema) {\n      schema = findSchemaLink(schema, etype, label);\n      if (!schema) {\n        throw Error(`Couldn't find the link ${etype}.${label} in your schema`);\n      }\n      const {forward, reverse} = schema;\n      schema = {\"forward-identity\":[(0,uuid_1.default)(), forward.on, forward.label], \"reverse-identity\":[(0,uuid_1.default)(), reverse.on, reverse.label], cardinality:\"one\" === forward.has ? \"one\" : \"many\", \"unique?\":\"one\" === reverse.has};\n    } else {\n      schema = null;\n    }\n    const attrId = (0,uuid_1.default)(), fwdIdent = [(0,uuid_1.default)(), etype, label];\n    etype = [(0,uuid_1.default)(), label, etype];\n    return Object.assign(Object.assign({id:attrId, \"forward-identity\":fwdIdent, \"reverse-identity\":etype, \"value-type\":\"ref\", cardinality:\"many\", \"unique?\":!1, \"index?\":!1, isUnsynced:!0}, schema || {}), props || {});\n  }\n  function lookupPairsOfOp(op) {\n    const res = [], [action, etype, eid, obj] = op;\n    if (!SUPPORTS_LOOKUP_ACTIONS.has(action)) {\n      return res;\n    }\n    (op = lookupPairOfEid(eid)) && res.push({etype, lookupPair:op});\n    if (\"link\" === action) {\n      for (const [label, eidOrEids] of Object.entries(obj)) {\n        op = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];\n        for (const linkEid of op) {\n          (op = lookupPairOfEid(linkEid)) && res.push({etype, lookupPair:op, linkLabel:label});\n        }\n      }\n    }\n    return res;\n  }\n  function createMissingAttrs({attrs:existingAttrs, schema}, ops) {\n    function addAttr(attr) {\n      attrs[attr.id] = attr;\n      addOps.push([\"add-attr\", attr]);\n      addedIds.add(attr.id);\n    }\n    function addUnsynced(attr) {\n      (null === attr || void 0 === attr ? 0 : attr.isUnsynced) && !addedIds.has(attr.id) && (addOps.push([\"add-attr\", attr]), addedIds.add(attr.id));\n    }\n    function addForRef(etype, label) {\n      const fwdAttr = getAttrByFwdIdentName(attrs, etype, label), revAttr = getAttrByReverseIdentName(attrs, etype, label);\n      addUnsynced(fwdAttr);\n      addUnsynced(revAttr);\n      fwdAttr || revAttr || addAttr(createRefAttr(schema, etype, label, refLookupProps));\n    }\n    var _a, _b;\n    const [addedIds, attrs, addOps] = [new Set(), Object.assign({}, existingAttrs), []];\n    for (const op of ops) {\n      for (const {etype, lookupPair, linkLabel} of lookupPairsOfOp(op)) {\n        if (existingAttrs = lookupPair[0], linkLabel) {\n          addForRef(etype, linkLabel);\n          var fwdAttr = getAttrByFwdIdentName(attrs, etype, linkLabel), revAttr = getAttrByReverseIdentName(attrs, etype, linkLabel);\n          addUnsynced(fwdAttr);\n          addUnsynced(revAttr);\n          fwdAttr = (null === (_a = null === fwdAttr || void 0 === fwdAttr ? void 0 : fwdAttr[\"reverse-identity\"]) || void 0 === _a ? void 0 : _a[1]) || (null === (_b = null === revAttr || void 0 === revAttr ? void 0 : revAttr[\"forward-identity\"]) || void 0 === _b ? void 0 : _b[1]) || linkLabel;\n          isRefLookupIdent(attrs, fwdAttr, existingAttrs) ? addForRef(fwdAttr, extractRefLookupFwdName(existingAttrs)) : ((revAttr = getAttrByFwdIdentName(attrs, fwdAttr, existingAttrs)) || addAttr(createObjectAttr(schema, fwdAttr, existingAttrs, lookupProps)), addUnsynced(revAttr));\n        } else {\n          isRefLookupIdent(attrs, etype, existingAttrs) ? addForRef(etype, extractRefLookupFwdName(existingAttrs)) : ((revAttr = getAttrByFwdIdentName(attrs, etype, existingAttrs)) || addAttr(createObjectAttr(schema, etype, existingAttrs, lookupProps)), addUnsynced(revAttr));\n        }\n      }\n    }\n    for (const op of ops) {\n      const [action, etype, , obj] = op;\n      if (OBJ_ACTIONS.has(action)) {\n        ops = Object.keys(obj);\n        ops.push(\"id\");\n        for (const label of ops) {\n          ops = getAttrByFwdIdentName(attrs, etype, label), addUnsynced(ops), UPDATE_ACTIONS.has(action) && (ops || addAttr(createObjectAttr(schema, etype, label, \"id\" === label ? {\"unique?\":!0} : null))), REF_ACTIONS.has(action) && (_a = getAttrByReverseIdentName(attrs, etype, label), ops || _a || addAttr(createRefAttr(schema, etype, label)), addUnsynced(_a));\n        }\n      }\n    }\n    return [attrs, addOps];\n  }\n  global = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\"default\":mod};\n  };\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.rewriteStep = function(attrMapping, txStep) {\n    const {attrIdMap, refSwapAttrIds} = attrMapping;\n    attrMapping = [];\n    for (var part of txStep) {\n      const newValue = attrIdMap[part];\n      if (newValue) {\n        attrMapping.push(newValue);\n      } else if (Array.isArray(part) && 2 == part.length && attrIdMap[part[0]]) {\n        const [aid, value] = part;\n        attrMapping.push([attrIdMap[aid], value]);\n      } else {\n        attrMapping.push(part);\n      }\n    }\n    [part] = txStep;\n    \"add-triple\" !== part && \"retract-triple\" !== part || !refSwapAttrIds.has(txStep[2]) || (txStep = attrMapping[1], attrMapping[1] = attrMapping[3], attrMapping[3] = txStep);\n    return attrMapping;\n  };\n  exports.getAttrByFwdIdentName = getAttrByFwdIdentName;\n  exports.getAttrByReverseIdentName = getAttrByReverseIdentName;\n  exports.transform = function(ctx, inputChunks) {\n    inputChunks = (Array.isArray(inputChunks) ? inputChunks : [inputChunks]).flatMap(tx => (0,instatx_1.getOps)(tx));\n    const [newAttrs, addAttrTxSteps] = createMissingAttrs(ctx, inputChunks);\n    ctx = inputChunks.flatMap(op => toTxSteps(newAttrs, op));\n    return [...addAttrTxSteps, ...ctx];\n  };\n  const instatx_1 = require(\"module$node_modules$$instantdb$core$dist$instatx\"), object_1 = require(\"module$node_modules$$instantdb$core$dist$utils$object\"), uuid_1 = global(require(\"module$node_modules$$instantdb$core$dist$utils$uuid\")), OBJ_ACTIONS = new Set([\"update\", \"merge\", \"link\", \"unlink\"]), REF_ACTIONS = new Set([\"link\", \"unlink\"]), UPDATE_ACTIONS = new Set([\"update\", \"merge\"]), SUPPORTS_LOOKUP_ACTIONS = new Set([\"link\", \"unlink\", \"update\", \"merge\", \"delete\"]), lookupProps = {\"unique?\":!0, \n  \"index?\":!0}, refLookupProps = Object.assign(Object.assign({}, lookupProps), {cardinality:\"one\"});\n};\n","~:source","shadow$provide[\"module$node_modules$$instantdb$core$dist$instaml\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rewriteStep = rewriteStep;\nexports.getAttrByFwdIdentName = getAttrByFwdIdentName;\nexports.getAttrByReverseIdentName = getAttrByReverseIdentName;\nexports.transform = transform;\nconst instatx_1 = require(\"./instatx\");\nconst object_1 = require(\"./utils/object\");\nconst uuid_1 = __importDefault(require(\"./utils/uuid\"));\n// Rewrites optimistic attrs with the attrs we get back from the server.\nfunction rewriteStep(attrMapping, txStep) {\n    const { attrIdMap, refSwapAttrIds } = attrMapping;\n    const rewritten = [];\n    for (const part of txStep) {\n        const newValue = attrIdMap[part];\n        if (newValue) {\n            // Rewrites attr id\n            rewritten.push(newValue);\n        }\n        else if (Array.isArray(part) && part.length == 2 && attrIdMap[part[0]]) {\n            // Rewrites attr id in lookups\n            const [aid, value] = part;\n            rewritten.push([attrIdMap[aid], value]);\n        }\n        else {\n            rewritten.push(part);\n        }\n    }\n    const [action] = txStep;\n    if ((action === 'add-triple' || action === 'retract-triple') &&\n        refSwapAttrIds.has(txStep[2])) {\n        // Reverse links if the optimistic link attr is backwards\n        const tmp = rewritten[1];\n        rewritten[1] = rewritten[3];\n        rewritten[3] = tmp;\n    }\n    return rewritten;\n}\nfunction getAttrByFwdIdentName(attrs, inputEtype, inputIdentName) {\n    return Object.values(attrs).find((attr) => {\n        const [_id, etype, label] = attr['forward-identity'];\n        return etype === inputEtype && label === inputIdentName;\n    });\n}\nfunction getAttrByReverseIdentName(attrs, inputEtype, inputIdentName) {\n    return Object.values(attrs).find((attr) => {\n        const revIdent = attr['reverse-identity'];\n        if (!revIdent)\n            return false;\n        const [_id, etype, label] = revIdent;\n        return etype === inputEtype && label === inputIdentName;\n    });\n}\nfunction explodeLookupRef(eid) {\n    if (Array.isArray(eid)) {\n        return eid;\n    }\n    const entries = Object.entries(eid);\n    if (entries.length !== 1) {\n        throw new Error('lookup must be an object with a single unique attr and value.');\n    }\n    return entries[0];\n}\nfunction isRefLookupIdent(attrs, etype, identName) {\n    return (identName.indexOf('.') !== -1 &&\n        // attr names can have `.` in them, so use the attr we find with a `.`\n        // before assuming it's a ref lookup.\n        !getAttrByFwdIdentName(attrs, etype, identName));\n}\nfunction extractRefLookupFwdName(identName) {\n    const [fwdName, idIdent, ...rest] = identName.split('.');\n    if (rest.length > 0 || idIdent !== 'id') {\n        throw new Error(`${identName} is not a valid lookup attribute.`);\n    }\n    return fwdName;\n}\nfunction lookupIdentToAttr(attrs, etype, identName) {\n    if (!isRefLookupIdent(attrs, etype, identName)) {\n        return getAttrByFwdIdentName(attrs, etype, identName);\n    }\n    const fwdName = extractRefLookupFwdName(identName);\n    const refAttr = getAttrByFwdIdentName(attrs, etype, fwdName) ||\n        getAttrByReverseIdentName(attrs, etype, fwdName);\n    if (refAttr && refAttr['value-type'] !== 'ref') {\n        throw new Error(`${identName} does not reference a valid link attribute.`);\n    }\n    return refAttr;\n}\n// Returns [attr, value] for the eid if the eid is a lookup.\n// If it's a regular eid, returns null\nfunction lookupPairOfEid(eid) {\n    if (typeof eid === 'string' && !(0, instatx_1.isLookup)(eid)) {\n        return null;\n    }\n    return typeof eid === 'string' && (0, instatx_1.isLookup)(eid)\n        ? (0, instatx_1.parseLookup)(eid)\n        : explodeLookupRef(eid);\n}\nfunction extractLookup(attrs, etype, eid) {\n    const lookupPair = lookupPairOfEid(eid);\n    if (lookupPair === null) {\n        return eid;\n    }\n    const [identName, value] = lookupPair;\n    const attr = lookupIdentToAttr(attrs, etype, identName);\n    if (!attr || !attr['unique?']) {\n        throw new Error(`${identName} is not a unique attribute.`);\n    }\n    return [attr.id, value];\n}\nfunction expandLink(attrs, [etype, eidA, obj]) {\n    const addTriples = Object.entries(obj).flatMap(([label, eidOrEids]) => {\n        const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];\n        const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);\n        const revAttr = getAttrByReverseIdentName(attrs, etype, label);\n        return eids.map((eidB) => {\n            const txStep = fwdAttr\n                ? [\n                    'add-triple',\n                    extractLookup(attrs, etype, eidA),\n                    fwdAttr.id,\n                    extractLookup(attrs, fwdAttr['reverse-identity'][1], eidB),\n                ]\n                : [\n                    'add-triple',\n                    extractLookup(attrs, revAttr['forward-identity'][1], eidB),\n                    revAttr.id,\n                    extractLookup(attrs, etype, eidA),\n                ];\n            return txStep;\n        });\n    });\n    return addTriples;\n}\nfunction expandUnlink(attrs, [etype, eidA, obj]) {\n    const retractTriples = Object.entries(obj).flatMap(([label, eidOrEids]) => {\n        const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];\n        const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);\n        const revAttr = getAttrByReverseIdentName(attrs, etype, label);\n        return eids.map((eidB) => {\n            const txStep = fwdAttr\n                ? [\n                    'retract-triple',\n                    extractLookup(attrs, etype, eidA),\n                    fwdAttr.id,\n                    extractLookup(attrs, fwdAttr['reverse-identity'][1], eidB),\n                ]\n                : [\n                    'retract-triple',\n                    extractLookup(attrs, revAttr['forward-identity'][1], eidB),\n                    revAttr.id,\n                    extractLookup(attrs, etype, eidA),\n                ];\n            return txStep;\n        });\n    });\n    return retractTriples;\n}\nfunction expandUpdate(attrs, [etype, eid, obj]) {\n    const lookup = extractLookup(attrs, etype, eid);\n    // id first so that we don't clobber updates on the lookup field\n    const attrTuples = [['id', extractLookup(attrs, etype, eid)]]\n        .concat(Object.entries(obj))\n        .map(([identName, value]) => {\n        const attr = getAttrByFwdIdentName(attrs, etype, identName);\n        return ['add-triple', lookup, attr.id, value];\n    });\n    return attrTuples;\n}\nfunction expandDelete(attrs, [etype, eid]) {\n    const lookup = extractLookup(attrs, etype, eid);\n    return [['delete-entity', lookup, etype]];\n}\nfunction expandDeepMerge(attrs, [etype, eid, obj]) {\n    const lookup = extractLookup(attrs, etype, eid);\n    const attrTuples = Object.entries(obj).map(([identName, value]) => {\n        const attr = getAttrByFwdIdentName(attrs, etype, identName);\n        const coercedValue = (0, object_1.immutableDeepReplace)(value, undefined, null);\n        return ['deep-merge-triple', lookup, attr.id, coercedValue];\n    });\n    const idTuple = [\n        'add-triple',\n        lookup,\n        getAttrByFwdIdentName(attrs, etype, 'id').id,\n        lookup,\n    ];\n    // id first so that we don't clobber updates on the lookup field\n    return [idTuple].concat(attrTuples);\n}\nfunction removeIdFromArgs(step) {\n    const [op, etype, eid, obj] = step;\n    if (!obj) {\n        return step;\n    }\n    const newObj = Object.assign({}, obj);\n    delete newObj.id;\n    return [op, etype, eid, newObj];\n}\nfunction toTxSteps(attrs, step) {\n    const [action, ...args] = removeIdFromArgs(step);\n    switch (action) {\n        case 'merge':\n            return expandDeepMerge(attrs, args);\n        case 'update':\n            return expandUpdate(attrs, args);\n        case 'link':\n            return expandLink(attrs, args);\n        case 'unlink':\n            return expandUnlink(attrs, args);\n        case 'delete':\n            return expandDelete(attrs, args);\n        default:\n            throw new Error(`unsupported action ${action}`);\n    }\n}\n// ---------\n// transform\nfunction checkedDataTypeOfValueType(valueType) {\n    switch (valueType) {\n        case 'string':\n        case 'date':\n        case 'boolean':\n        case 'number':\n            return valueType;\n        default:\n            return undefined;\n    }\n}\nfunction objectPropsFromSchema(schema, etype, label) {\n    var _a, _b;\n    const attr = (_b = (_a = schema.entities[etype]) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b[label];\n    if (label === 'id')\n        return null;\n    if (!attr) {\n        throw new Error(`${etype}.${label} does not exist in your schema`);\n    }\n    const { unique, indexed } = attr === null || attr === void 0 ? void 0 : attr.config;\n    const checkedDataType = checkedDataTypeOfValueType(attr === null || attr === void 0 ? void 0 : attr.valueType);\n    return {\n        'index?': indexed,\n        'unique?': unique,\n        'checked-data-type': checkedDataType,\n    };\n}\nfunction createObjectAttr(schema, etype, label, props) {\n    const schemaObjectProps = schema\n        ? objectPropsFromSchema(schema, etype, label)\n        : null;\n    const attrId = (0, uuid_1.default)();\n    const fwdIdentId = (0, uuid_1.default)();\n    const fwdIdent = [fwdIdentId, etype, label];\n    return Object.assign(Object.assign({ id: attrId, 'forward-identity': fwdIdent, 'value-type': 'blob', cardinality: 'one', 'unique?': false, 'index?': false, isUnsynced: true }, (schemaObjectProps || {})), (props || {}));\n}\nfunction findSchemaLink(schema, etype, label) {\n    const found = Object.values(schema.links).find((x) => {\n        return ((x.forward.on === etype && x.forward.label === label) ||\n            (x.reverse.on === etype && x.reverse.label === label));\n    });\n    return found;\n}\nfunction refPropsFromSchema(schema, etype, label) {\n    const found = findSchemaLink(schema, etype, label);\n    if (!found) {\n        throw new Error(`Couldn't find the link ${etype}.${label} in your schema`);\n    }\n    const { forward, reverse } = found;\n    return {\n        'forward-identity': [(0, uuid_1.default)(), forward.on, forward.label],\n        'reverse-identity': [(0, uuid_1.default)(), reverse.on, reverse.label],\n        cardinality: forward.has === 'one' ? 'one' : 'many',\n        'unique?': reverse.has === 'one',\n    };\n}\nfunction createRefAttr(schema, etype, label, props) {\n    const schemaRefProps = schema\n        ? refPropsFromSchema(schema, etype, label)\n        : null;\n    const attrId = (0, uuid_1.default)();\n    const fwdIdent = [(0, uuid_1.default)(), etype, label];\n    const revIdent = [(0, uuid_1.default)(), label, etype];\n    return Object.assign(Object.assign({ id: attrId, 'forward-identity': fwdIdent, 'reverse-identity': revIdent, 'value-type': 'ref', cardinality: 'many', 'unique?': false, 'index?': false, isUnsynced: true }, (schemaRefProps || {})), (props || {}));\n}\n// Actions that have an object, e.g. not delete\nconst OBJ_ACTIONS = new Set(['update', 'merge', 'link', 'unlink']);\nconst REF_ACTIONS = new Set(['link', 'unlink']);\nconst UPDATE_ACTIONS = new Set(['update', 'merge']);\nconst SUPPORTS_LOOKUP_ACTIONS = new Set([\n    'link',\n    'unlink',\n    'update',\n    'merge',\n    'delete',\n]);\nconst lookupProps = { 'unique?': true, 'index?': true };\nconst refLookupProps = Object.assign(Object.assign({}, lookupProps), { cardinality: 'one' });\nfunction lookupPairsOfOp(op) {\n    const res = [];\n    const [action, etype, eid, obj] = op;\n    if (!SUPPORTS_LOOKUP_ACTIONS.has(action)) {\n        return res;\n    }\n    const eidLookupPair = lookupPairOfEid(eid);\n    if (eidLookupPair) {\n        res.push({ etype: etype, lookupPair: eidLookupPair });\n    }\n    if (action === 'link') {\n        for (const [label, eidOrEids] of Object.entries(obj)) {\n            const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];\n            for (const linkEid of eids) {\n                const linkEidLookupPair = lookupPairOfEid(linkEid);\n                if (linkEidLookupPair) {\n                    res.push({\n                        etype: etype,\n                        lookupPair: linkEidLookupPair,\n                        linkLabel: label,\n                    });\n                }\n            }\n        }\n    }\n    return res;\n}\nfunction createMissingAttrs({ attrs: existingAttrs, schema }, ops) {\n    var _a, _b;\n    const [addedIds, attrs, addOps] = [new Set(), Object.assign({}, existingAttrs), []];\n    function addAttr(attr) {\n        attrs[attr.id] = attr;\n        addOps.push(['add-attr', attr]);\n        addedIds.add(attr.id);\n    }\n    function addUnsynced(attr) {\n        if ((attr === null || attr === void 0 ? void 0 : attr.isUnsynced) && !addedIds.has(attr.id)) {\n            addOps.push(['add-attr', attr]);\n            addedIds.add(attr.id);\n        }\n    }\n    // Adds attrs needed for a ref lookup\n    function addForRef(etype, label) {\n        const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);\n        const revAttr = getAttrByReverseIdentName(attrs, etype, label);\n        addUnsynced(fwdAttr);\n        addUnsynced(revAttr);\n        if (!fwdAttr && !revAttr) {\n            addAttr(createRefAttr(schema, etype, label, refLookupProps));\n        }\n    }\n    // Create attrs for lookups if we need to\n    // Do these first because otherwise we might add a non-unique attr\n    // before we get to it\n    for (const op of ops) {\n        for (const { etype, lookupPair, linkLabel } of lookupPairsOfOp(op)) {\n            const identName = lookupPair[0];\n            // We got a link eid that's a lookup, linkLabel is the label of the ident,\n            // e.g. `posts` in `link({posts: postIds})`\n            if (linkLabel) {\n                // Add our ref attr, e.g. users.posts\n                addForRef(etype, linkLabel);\n                // Figure out the link etype so we can make sure we have the attrs\n                // for the link lookup\n                const fwdAttr = getAttrByFwdIdentName(attrs, etype, linkLabel);\n                const revAttr = getAttrByReverseIdentName(attrs, etype, linkLabel);\n                addUnsynced(fwdAttr);\n                addUnsynced(revAttr);\n                const linkEtype = ((_a = fwdAttr === null || fwdAttr === void 0 ? void 0 : fwdAttr['reverse-identity']) === null || _a === void 0 ? void 0 : _a[1]) ||\n                    ((_b = revAttr === null || revAttr === void 0 ? void 0 : revAttr['forward-identity']) === null || _b === void 0 ? void 0 : _b[1]) ||\n                    linkLabel;\n                if (isRefLookupIdent(attrs, linkEtype, identName)) {\n                    addForRef(linkEtype, extractRefLookupFwdName(identName));\n                }\n                else {\n                    const attr = getAttrByFwdIdentName(attrs, linkEtype, identName);\n                    if (!attr) {\n                        addAttr(createObjectAttr(schema, linkEtype, identName, lookupProps));\n                    }\n                    addUnsynced(attr);\n                }\n            }\n            else if (isRefLookupIdent(attrs, etype, identName)) {\n                addForRef(etype, extractRefLookupFwdName(identName));\n            }\n            else {\n                const attr = getAttrByFwdIdentName(attrs, etype, identName);\n                if (!attr) {\n                    addAttr(createObjectAttr(schema, etype, identName, lookupProps));\n                }\n                addUnsynced(attr);\n            }\n        }\n    }\n    // Create object and ref attrs\n    for (const op of ops) {\n        const [action, etype, eid, obj] = op;\n        if (OBJ_ACTIONS.has(action)) {\n            const labels = Object.keys(obj);\n            labels.push('id');\n            for (const label of labels) {\n                const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);\n                addUnsynced(fwdAttr);\n                if (UPDATE_ACTIONS.has(action)) {\n                    if (!fwdAttr) {\n                        addAttr(createObjectAttr(schema, etype, label, label === 'id' ? { 'unique?': true } : null));\n                    }\n                }\n                if (REF_ACTIONS.has(action)) {\n                    const revAttr = getAttrByReverseIdentName(attrs, etype, label);\n                    if (!fwdAttr && !revAttr) {\n                        addAttr(createRefAttr(schema, etype, label));\n                    }\n                    addUnsynced(revAttr);\n                }\n            }\n        }\n    }\n    return [attrs, addOps];\n}\nfunction transform(ctx, inputChunks) {\n    const chunks = Array.isArray(inputChunks) ? inputChunks : [inputChunks];\n    const ops = chunks.flatMap((tx) => (0, instatx_1.getOps)(tx));\n    const [newAttrs, addAttrTxSteps] = createMissingAttrs(ctx, ops);\n    const txSteps = ops.flatMap((op) => toTxSteps(newAttrs, op));\n    return [...addAttrTxSteps, ...txSteps];\n}\n//# sourceMappingURL=instaml.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$instantdb$core$dist$instatx","~$shadow.js","~$module$node_modules$$instantdb$core$dist$utils$object","~$module$node_modules$$instantdb$core$dist$utils$uuid"]],"~:properties",["^5",["etype","getAttrByReverseIdentName","__esModule","id","transform","value","rewriteStep","getAttrByFwdIdentName","isUnsynced","lookupPair","cardinality","linkLabel"]],"~:compiled-at",1756239699969,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$instantdb$core$dist$instaml.js\",\n\"lineCount\":259,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@instantdb/core/dist/instaml.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$instantdb$core$dist$instaml\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __importDefault = (this && this.__importDefault) || function (mod) {\\n    return (mod && mod.__esModule) ? mod : { \\\"default\\\": mod };\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.rewriteStep = rewriteStep;\\nexports.getAttrByFwdIdentName = getAttrByFwdIdentName;\\nexports.getAttrByReverseIdentName = getAttrByReverseIdentName;\\nexports.transform = transform;\\nconst instatx_1 = require(\\\"./instatx\\\");\\nconst object_1 = require(\\\"./utils/object\\\");\\nconst uuid_1 = __importDefault(require(\\\"./utils/uuid\\\"));\\n// Rewrites optimistic attrs with the attrs we get back from the server.\\nfunction rewriteStep(attrMapping, txStep) {\\n    const { attrIdMap, refSwapAttrIds } = attrMapping;\\n    const rewritten = [];\\n    for (const part of txStep) {\\n        const newValue = attrIdMap[part];\\n        if (newValue) {\\n            // Rewrites attr id\\n            rewritten.push(newValue);\\n        }\\n        else if (Array.isArray(part) && part.length == 2 && attrIdMap[part[0]]) {\\n            // Rewrites attr id in lookups\\n            const [aid, value] = part;\\n            rewritten.push([attrIdMap[aid], value]);\\n        }\\n        else {\\n            rewritten.push(part);\\n        }\\n    }\\n    const [action] = txStep;\\n    if ((action === 'add-triple' || action === 'retract-triple') &&\\n        refSwapAttrIds.has(txStep[2])) {\\n        // Reverse links if the optimistic link attr is backwards\\n        const tmp = rewritten[1];\\n        rewritten[1] = rewritten[3];\\n        rewritten[3] = tmp;\\n    }\\n    return rewritten;\\n}\\nfunction getAttrByFwdIdentName(attrs, inputEtype, inputIdentName) {\\n    return Object.values(attrs).find((attr) => {\\n        const [_id, etype, label] = attr['forward-identity'];\\n        return etype === inputEtype && label === inputIdentName;\\n    });\\n}\\nfunction getAttrByReverseIdentName(attrs, inputEtype, inputIdentName) {\\n    return Object.values(attrs).find((attr) => {\\n        const revIdent = attr['reverse-identity'];\\n        if (!revIdent)\\n            return false;\\n        const [_id, etype, label] = revIdent;\\n        return etype === inputEtype && label === inputIdentName;\\n    });\\n}\\nfunction explodeLookupRef(eid) {\\n    if (Array.isArray(eid)) {\\n        return eid;\\n    }\\n    const entries = Object.entries(eid);\\n    if (entries.length !== 1) {\\n        throw new Error('lookup must be an object with a single unique attr and value.');\\n    }\\n    return entries[0];\\n}\\nfunction isRefLookupIdent(attrs, etype, identName) {\\n    return (identName.indexOf('.') !== -1 &&\\n        // attr names can have `.` in them, so use the attr we find with a `.`\\n        // before assuming it's a ref lookup.\\n        !getAttrByFwdIdentName(attrs, etype, identName));\\n}\\nfunction extractRefLookupFwdName(identName) {\\n    const [fwdName, idIdent, ...rest] = identName.split('.');\\n    if (rest.length > 0 || idIdent !== 'id') {\\n        throw new Error(`${identName} is not a valid lookup attribute.`);\\n    }\\n    return fwdName;\\n}\\nfunction lookupIdentToAttr(attrs, etype, identName) {\\n    if (!isRefLookupIdent(attrs, etype, identName)) {\\n        return getAttrByFwdIdentName(attrs, etype, identName);\\n    }\\n    const fwdName = extractRefLookupFwdName(identName);\\n    const refAttr = getAttrByFwdIdentName(attrs, etype, fwdName) ||\\n        getAttrByReverseIdentName(attrs, etype, fwdName);\\n    if (refAttr && refAttr['value-type'] !== 'ref') {\\n        throw new Error(`${identName} does not reference a valid link attribute.`);\\n    }\\n    return refAttr;\\n}\\n// Returns [attr, value] for the eid if the eid is a lookup.\\n// If it's a regular eid, returns null\\nfunction lookupPairOfEid(eid) {\\n    if (typeof eid === 'string' && !(0, instatx_1.isLookup)(eid)) {\\n        return null;\\n    }\\n    return typeof eid === 'string' && (0, instatx_1.isLookup)(eid)\\n        ? (0, instatx_1.parseLookup)(eid)\\n        : explodeLookupRef(eid);\\n}\\nfunction extractLookup(attrs, etype, eid) {\\n    const lookupPair = lookupPairOfEid(eid);\\n    if (lookupPair === null) {\\n        return eid;\\n    }\\n    const [identName, value] = lookupPair;\\n    const attr = lookupIdentToAttr(attrs, etype, identName);\\n    if (!attr || !attr['unique?']) {\\n        throw new Error(`${identName} is not a unique attribute.`);\\n    }\\n    return [attr.id, value];\\n}\\nfunction expandLink(attrs, [etype, eidA, obj]) {\\n    const addTriples = Object.entries(obj).flatMap(([label, eidOrEids]) => {\\n        const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];\\n        const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);\\n        const revAttr = getAttrByReverseIdentName(attrs, etype, label);\\n        return eids.map((eidB) => {\\n            const txStep = fwdAttr\\n                ? [\\n                    'add-triple',\\n                    extractLookup(attrs, etype, eidA),\\n                    fwdAttr.id,\\n                    extractLookup(attrs, fwdAttr['reverse-identity'][1], eidB),\\n                ]\\n                : [\\n                    'add-triple',\\n                    extractLookup(attrs, revAttr['forward-identity'][1], eidB),\\n                    revAttr.id,\\n                    extractLookup(attrs, etype, eidA),\\n                ];\\n            return txStep;\\n        });\\n    });\\n    return addTriples;\\n}\\nfunction expandUnlink(attrs, [etype, eidA, obj]) {\\n    const retractTriples = Object.entries(obj).flatMap(([label, eidOrEids]) => {\\n        const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];\\n        const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);\\n        const revAttr = getAttrByReverseIdentName(attrs, etype, label);\\n        return eids.map((eidB) => {\\n            const txStep = fwdAttr\\n                ? [\\n                    'retract-triple',\\n                    extractLookup(attrs, etype, eidA),\\n                    fwdAttr.id,\\n                    extractLookup(attrs, fwdAttr['reverse-identity'][1], eidB),\\n                ]\\n                : [\\n                    'retract-triple',\\n                    extractLookup(attrs, revAttr['forward-identity'][1], eidB),\\n                    revAttr.id,\\n                    extractLookup(attrs, etype, eidA),\\n                ];\\n            return txStep;\\n        });\\n    });\\n    return retractTriples;\\n}\\nfunction expandUpdate(attrs, [etype, eid, obj]) {\\n    const lookup = extractLookup(attrs, etype, eid);\\n    // id first so that we don't clobber updates on the lookup field\\n    const attrTuples = [['id', extractLookup(attrs, etype, eid)]]\\n        .concat(Object.entries(obj))\\n        .map(([identName, value]) => {\\n        const attr = getAttrByFwdIdentName(attrs, etype, identName);\\n        return ['add-triple', lookup, attr.id, value];\\n    });\\n    return attrTuples;\\n}\\nfunction expandDelete(attrs, [etype, eid]) {\\n    const lookup = extractLookup(attrs, etype, eid);\\n    return [['delete-entity', lookup, etype]];\\n}\\nfunction expandDeepMerge(attrs, [etype, eid, obj]) {\\n    const lookup = extractLookup(attrs, etype, eid);\\n    const attrTuples = Object.entries(obj).map(([identName, value]) => {\\n        const attr = getAttrByFwdIdentName(attrs, etype, identName);\\n        const coercedValue = (0, object_1.immutableDeepReplace)(value, undefined, null);\\n        return ['deep-merge-triple', lookup, attr.id, coercedValue];\\n    });\\n    const idTuple = [\\n        'add-triple',\\n        lookup,\\n        getAttrByFwdIdentName(attrs, etype, 'id').id,\\n        lookup,\\n    ];\\n    // id first so that we don't clobber updates on the lookup field\\n    return [idTuple].concat(attrTuples);\\n}\\nfunction removeIdFromArgs(step) {\\n    const [op, etype, eid, obj] = step;\\n    if (!obj) {\\n        return step;\\n    }\\n    const newObj = Object.assign({}, obj);\\n    delete newObj.id;\\n    return [op, etype, eid, newObj];\\n}\\nfunction toTxSteps(attrs, step) {\\n    const [action, ...args] = removeIdFromArgs(step);\\n    switch (action) {\\n        case 'merge':\\n            return expandDeepMerge(attrs, args);\\n        case 'update':\\n            return expandUpdate(attrs, args);\\n        case 'link':\\n            return expandLink(attrs, args);\\n        case 'unlink':\\n            return expandUnlink(attrs, args);\\n        case 'delete':\\n            return expandDelete(attrs, args);\\n        default:\\n            throw new Error(`unsupported action ${action}`);\\n    }\\n}\\n// ---------\\n// transform\\nfunction checkedDataTypeOfValueType(valueType) {\\n    switch (valueType) {\\n        case 'string':\\n        case 'date':\\n        case 'boolean':\\n        case 'number':\\n            return valueType;\\n        default:\\n            return undefined;\\n    }\\n}\\nfunction objectPropsFromSchema(schema, etype, label) {\\n    var _a, _b;\\n    const attr = (_b = (_a = schema.entities[etype]) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b[label];\\n    if (label === 'id')\\n        return null;\\n    if (!attr) {\\n        throw new Error(`${etype}.${label} does not exist in your schema`);\\n    }\\n    const { unique, indexed } = attr === null || attr === void 0 ? void 0 : attr.config;\\n    const checkedDataType = checkedDataTypeOfValueType(attr === null || attr === void 0 ? void 0 : attr.valueType);\\n    return {\\n        'index?': indexed,\\n        'unique?': unique,\\n        'checked-data-type': checkedDataType,\\n    };\\n}\\nfunction createObjectAttr(schema, etype, label, props) {\\n    const schemaObjectProps = schema\\n        ? objectPropsFromSchema(schema, etype, label)\\n        : null;\\n    const attrId = (0, uuid_1.default)();\\n    const fwdIdentId = (0, uuid_1.default)();\\n    const fwdIdent = [fwdIdentId, etype, label];\\n    return Object.assign(Object.assign({ id: attrId, 'forward-identity': fwdIdent, 'value-type': 'blob', cardinality: 'one', 'unique?': false, 'index?': false, isUnsynced: true }, (schemaObjectProps || {})), (props || {}));\\n}\\nfunction findSchemaLink(schema, etype, label) {\\n    const found = Object.values(schema.links).find((x) => {\\n        return ((x.forward.on === etype && x.forward.label === label) ||\\n            (x.reverse.on === etype && x.reverse.label === label));\\n    });\\n    return found;\\n}\\nfunction refPropsFromSchema(schema, etype, label) {\\n    const found = findSchemaLink(schema, etype, label);\\n    if (!found) {\\n        throw new Error(`Couldn't find the link ${etype}.${label} in your schema`);\\n    }\\n    const { forward, reverse } = found;\\n    return {\\n        'forward-identity': [(0, uuid_1.default)(), forward.on, forward.label],\\n        'reverse-identity': [(0, uuid_1.default)(), reverse.on, reverse.label],\\n        cardinality: forward.has === 'one' ? 'one' : 'many',\\n        'unique?': reverse.has === 'one',\\n    };\\n}\\nfunction createRefAttr(schema, etype, label, props) {\\n    const schemaRefProps = schema\\n        ? refPropsFromSchema(schema, etype, label)\\n        : null;\\n    const attrId = (0, uuid_1.default)();\\n    const fwdIdent = [(0, uuid_1.default)(), etype, label];\\n    const revIdent = [(0, uuid_1.default)(), label, etype];\\n    return Object.assign(Object.assign({ id: attrId, 'forward-identity': fwdIdent, 'reverse-identity': revIdent, 'value-type': 'ref', cardinality: 'many', 'unique?': false, 'index?': false, isUnsynced: true }, (schemaRefProps || {})), (props || {}));\\n}\\n// Actions that have an object, e.g. not delete\\nconst OBJ_ACTIONS = new Set(['update', 'merge', 'link', 'unlink']);\\nconst REF_ACTIONS = new Set(['link', 'unlink']);\\nconst UPDATE_ACTIONS = new Set(['update', 'merge']);\\nconst SUPPORTS_LOOKUP_ACTIONS = new Set([\\n    'link',\\n    'unlink',\\n    'update',\\n    'merge',\\n    'delete',\\n]);\\nconst lookupProps = { 'unique?': true, 'index?': true };\\nconst refLookupProps = Object.assign(Object.assign({}, lookupProps), { cardinality: 'one' });\\nfunction lookupPairsOfOp(op) {\\n    const res = [];\\n    const [action, etype, eid, obj] = op;\\n    if (!SUPPORTS_LOOKUP_ACTIONS.has(action)) {\\n        return res;\\n    }\\n    const eidLookupPair = lookupPairOfEid(eid);\\n    if (eidLookupPair) {\\n        res.push({ etype: etype, lookupPair: eidLookupPair });\\n    }\\n    if (action === 'link') {\\n        for (const [label, eidOrEids] of Object.entries(obj)) {\\n            const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];\\n            for (const linkEid of eids) {\\n                const linkEidLookupPair = lookupPairOfEid(linkEid);\\n                if (linkEidLookupPair) {\\n                    res.push({\\n                        etype: etype,\\n                        lookupPair: linkEidLookupPair,\\n                        linkLabel: label,\\n                    });\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n}\\nfunction createMissingAttrs({ attrs: existingAttrs, schema }, ops) {\\n    var _a, _b;\\n    const [addedIds, attrs, addOps] = [new Set(), Object.assign({}, existingAttrs), []];\\n    function addAttr(attr) {\\n        attrs[attr.id] = attr;\\n        addOps.push(['add-attr', attr]);\\n        addedIds.add(attr.id);\\n    }\\n    function addUnsynced(attr) {\\n        if ((attr === null || attr === void 0 ? void 0 : attr.isUnsynced) && !addedIds.has(attr.id)) {\\n            addOps.push(['add-attr', attr]);\\n            addedIds.add(attr.id);\\n        }\\n    }\\n    // Adds attrs needed for a ref lookup\\n    function addForRef(etype, label) {\\n        const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);\\n        const revAttr = getAttrByReverseIdentName(attrs, etype, label);\\n        addUnsynced(fwdAttr);\\n        addUnsynced(revAttr);\\n        if (!fwdAttr && !revAttr) {\\n            addAttr(createRefAttr(schema, etype, label, refLookupProps));\\n        }\\n    }\\n    // Create attrs for lookups if we need to\\n    // Do these first because otherwise we might add a non-unique attr\\n    // before we get to it\\n    for (const op of ops) {\\n        for (const { etype, lookupPair, linkLabel } of lookupPairsOfOp(op)) {\\n            const identName = lookupPair[0];\\n            // We got a link eid that's a lookup, linkLabel is the label of the ident,\\n            // e.g. `posts` in `link({posts: postIds})`\\n            if (linkLabel) {\\n                // Add our ref attr, e.g. users.posts\\n                addForRef(etype, linkLabel);\\n                // Figure out the link etype so we can make sure we have the attrs\\n                // for the link lookup\\n                const fwdAttr = getAttrByFwdIdentName(attrs, etype, linkLabel);\\n                const revAttr = getAttrByReverseIdentName(attrs, etype, linkLabel);\\n                addUnsynced(fwdAttr);\\n                addUnsynced(revAttr);\\n                const linkEtype = ((_a = fwdAttr === null || fwdAttr === void 0 ? void 0 : fwdAttr['reverse-identity']) === null || _a === void 0 ? void 0 : _a[1]) ||\\n                    ((_b = revAttr === null || revAttr === void 0 ? void 0 : revAttr['forward-identity']) === null || _b === void 0 ? void 0 : _b[1]) ||\\n                    linkLabel;\\n                if (isRefLookupIdent(attrs, linkEtype, identName)) {\\n                    addForRef(linkEtype, extractRefLookupFwdName(identName));\\n                }\\n                else {\\n                    const attr = getAttrByFwdIdentName(attrs, linkEtype, identName);\\n                    if (!attr) {\\n                        addAttr(createObjectAttr(schema, linkEtype, identName, lookupProps));\\n                    }\\n                    addUnsynced(attr);\\n                }\\n            }\\n            else if (isRefLookupIdent(attrs, etype, identName)) {\\n                addForRef(etype, extractRefLookupFwdName(identName));\\n            }\\n            else {\\n                const attr = getAttrByFwdIdentName(attrs, etype, identName);\\n                if (!attr) {\\n                    addAttr(createObjectAttr(schema, etype, identName, lookupProps));\\n                }\\n                addUnsynced(attr);\\n            }\\n        }\\n    }\\n    // Create object and ref attrs\\n    for (const op of ops) {\\n        const [action, etype, eid, obj] = op;\\n        if (OBJ_ACTIONS.has(action)) {\\n            const labels = Object.keys(obj);\\n            labels.push('id');\\n            for (const label of labels) {\\n                const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);\\n                addUnsynced(fwdAttr);\\n                if (UPDATE_ACTIONS.has(action)) {\\n                    if (!fwdAttr) {\\n                        addAttr(createObjectAttr(schema, etype, label, label === 'id' ? { 'unique?': true } : null));\\n                    }\\n                }\\n                if (REF_ACTIONS.has(action)) {\\n                    const revAttr = getAttrByReverseIdentName(attrs, etype, label);\\n                    if (!fwdAttr && !revAttr) {\\n                        addAttr(createRefAttr(schema, etype, label));\\n                    }\\n                    addUnsynced(revAttr);\\n                }\\n            }\\n        }\\n    }\\n    return [attrs, addOps];\\n}\\nfunction transform(ctx, inputChunks) {\\n    const chunks = Array.isArray(inputChunks) ? inputChunks : [inputChunks];\\n    const ops = chunks.flatMap((tx) => (0, instatx_1.getOps)(tx));\\n    const [newAttrs, addAttrTxSteps] = createMissingAttrs(ctx, ops);\\n    const txSteps = ops.flatMap((op) => toTxSteps(newAttrs, op));\\n    return [...addAttrTxSteps, ...txSteps];\\n}\\n//# sourceMappingURL=instaml.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getAttrByFwdIdentName\",\"attrs\",\"inputEtype\",\"inputIdentName\",\"Object\",\"values\",\"find\",\"attr\",\"etype\",\"label\",\"getAttrByReverseIdentName\",\"revIdent\",\"isRefLookupIdent\",\"identName\",\"indexOf\",\"extractRefLookupFwdName\",\"fwdName\",\"idIdent\",\"rest\",\"split\",\"length\",\"Error\",\"lookupPairOfEid\",\"eid\",\"instatx_1\",\"isLookup\",\"Array\",\"isArray\",\"entries\",\"extractLookup\",\"lookupPair\",\"value\",\"refAttr\",\"id\",\"expandLink\",\"eidA\",\"obj\",\"flatMap\",\"addTriples\",\"eidOrEids\",\"eids\",\"fwdAttr\",\"revAttr\",\"map\",\"eidB\",\"txStep\",\"expandUnlink\",\"retractTriples\",\"expandUpdate\",\"lookup\",\"concat\",\"attrTuples\",\"expandDelete\",\"expandDeepMerge\",\"coercedValue\",\"object_1\",\"immutableDeepReplace\",\"undefined\",\"idTuple\",\"toTxSteps\",\"step\",\"op\",\"newObj\",\"assign\",\"action\",\"args\",\"createObjectAttr\",\"schema\",\"props\",\"_b\",\"_a\",\"entities\",\"unique\",\"indexed\",\"config\",\"valueType\",\"checkedDataType\",\"attrId\",\"uuid_1\",\"default\",\"fwdIdent\",\"fwdIdentId\",\"cardinality\",\"isUnsynced\",\"schemaObjectProps\",\"findSchemaLink\",\"links\",\"found\",\"x\",\"forward\",\"on\",\"reverse\",\"createRefAttr\",\"has\",\"schemaRefProps\",\"lookupPairsOfOp\",\"res\",\"SUPPORTS_LOOKUP_ACTIONS\",\"eidLookupPair\",\"push\",\"linkEid\",\"linkEidLookupPair\",\"linkLabel\",\"createMissingAttrs\",\"existingAttrs\",\"ops\",\"addAttr\",\"addOps\",\"addedIds\",\"add\",\"addUnsynced\",\"addForRef\",\"refLookupProps\",\"Set\",\"linkEtype\",\"lookupProps\",\"OBJ_ACTIONS\",\"labels\",\"keys\",\"UPDATE_ACTIONS\",\"REF_ACTIONS\",\"__importDefault\",\"mod\",\"__esModule\",\"defineProperty\",\"rewriteStep\",\"attrMapping\",\"attrIdMap\",\"refSwapAttrIds\",\"rewritten\",\"part\",\"newValue\",\"aid\",\"tmp\",\"transform\",\"ctx\",\"inputChunks\",\"chunks\",\"tx\",\"getOps\",\"newAttrs\",\"addAttrTxSteps\",\"txSteps\"]\n}\n"]